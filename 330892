format 74
"berlin test" // vendor::marvell::generic::frameworks::omx::tests::audio_renderer::berlin test
  revision 1
  modified_by 12 "shchen"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_h_dir "/home/shchen/work/jellybean/vendor/marvell/generic/frameworks/omx/tests/audio_renderer/"
  cpp_src_dir "/home/shchen/work/jellybean/vendor/marvell/generic/frameworks/omx/tests/audio_renderer/"
  cpp_namespace "berlin::test"
  classview 285580 "audio_renderer"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 2960652 "kdCondSignal"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      operation 11995020 "kdCondSignal"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} {
    mLock = kdThreadMutexCreate(KD_NULL);
    mCond = kdThreadCondCreate(KD_NULL);
    mSignled = KD_FALSE;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${synchronized}${name}${(}${)}${throws} {
  ${body}}
"
	
	
	
      end

      operation 11995148 "~kdCondSignal"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    kdThreadMutexFree(mLock);
    kdThreadCondFree(mCond);
  };
"
	
	
	
	
      end

      operation 11995276 "waitSignal"
	cpp_inline public explicit_return_type "KDint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    kdThreadMutexLock(mLock);
    if (mSignled) {
      return kdThreadMutexUnlock(mLock);
    } else {
      kdThreadCondWait(mCond, mLock);
      return kdThreadMutexUnlock(mLock);
    }
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11995404 "setSignal"
	cpp_inline public explicit_return_type "KDint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    kdThreadMutexLock(mLock);
    kdThreadCondSignal(mCond);
    mSignled = KD_TRUE;
    return kdThreadMutexUnlock(mLock);
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11995532 "resetSignal"
	cpp_inline public explicit_return_type "KDint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    kdThreadMutexLock(mLock);
    mSignled = KD_FALSE;
    return kdThreadMutexUnlock(mLock);
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      attribute 10615820 "mLock"
	private explicit_type "KDThreadMutex"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10615948 "mCond"
	private explicit_type "KDThreadCond"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10616076 "mSignled"
	private explicit_type "KDboolean"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 2960780 "OmxAudDecoderClient"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 5450764 // mCompHandle (<directional composition>)
	relation 5450636 *-->
	  a role_name "mCompHandle" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5450764 // mCompHandle (<directional composition>)
	  b parent class_ref 2635404 // OMX_HANDLETYPE
      end

      classrelation 5450892 // mCompName (<directional composition>)
	relation 5450764 *-->
	  a role_name "mCompName" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5450892 // mCompName (<directional composition>)
	  b parent class_ref 2633868 // OMX_STRING
      end

      classrelation 5451020 // decTestCallbacks (<directional composition>)
	relation 5450892 *-->
	  a role_name "decTestCallbacks" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451020 // decTestCallbacks (<directional composition>)
	  b parent class_ref 2633484 // OMX_CALLBACKTYPE
      end

      attribute 10616204 "mBufHdr"
	public type class_ref 2635660 // OMX_BUFFERHEADERTYPE
	multiplicity "[4]"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * * * ${name}${multiplicity}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 5451148 // mInputBuffers (<unidirectional association>)
	relation 5451020 --->
	  stereotype "vector"
	  a role_name "mInputBuffers" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}*> ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451148 // mInputBuffers (<unidirectional association>)
	  b parent class_ref 2635660 // OMX_BUFFERHEADERTYPE
      end

      classrelation 5451276 // mOutputBuffers (<unidirectional association>)
	relation 5451148 --->
	  stereotype "vector"
	  a role_name "mOutputBuffers" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}*> ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451276 // mOutputBuffers (<unidirectional association>)
	  b parent class_ref 2635660 // OMX_BUFFERHEADERTYPE
      end

      attribute 10616332 "mInBufferLock"
	public explicit_type "KDThreadMutex"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10616460 "mOutBufferLock"
	public explicit_type "KDThreadMutex"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10616588 "mInputFrameNum"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10616716 "mOutputFrameNum"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 5451404 // mEOS (<directional composition>)
	relation 5451276 *-->
	  a role_name "mEOS" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451404 // mEOS (<directional composition>)
	  b parent class_ref 2636172 // OMX_BOOL
      end

      classrelation 5451532 // mOutputEOS (<directional composition>)
	relation 5451404 *-->
	  a role_name "mOutputEOS" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451532 // mOutputEOS (<directional composition>)
	  b parent class_ref 2636172 // OMX_BOOL
      end

      classrelation 5451660 // mStateSignal (<unidirectional association>)
	relation 5451532 --->
	  a role_name "mStateSignal" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451660 // mStateSignal (<unidirectional association>)
	  b parent class_ref 2960652 // kdCondSignal
      end

      classrelation 5451788 // mEosSignal (<unidirectional association>)
	relation 5451660 --->
	  a role_name "mEosSignal" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451788 // mEosSignal (<unidirectional association>)
	  b parent class_ref 2960652 // kdCondSignal
      end

      attribute 10616844 "mAvFormatCtx"
	public explicit_type "AVFormatContext"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10616972 "mStreamIndex"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 10617100 "mStreamName"
	public explicit_type "char"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 11995660 "OmxAudDecoderClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} {
    OMX_LOGD(\"ENTER\");
    decTestCallbacks.EventHandler = decTestEventHandler;
    decTestCallbacks.EmptyBufferDone = decTestEmptyBufferDone;
    decTestCallbacks.FillBufferDone = decTestFillBufferDone;
    mAvFormatCtx = NULL;
    mStateSignal = new kdCondSignal();
    mEosSignal = new kdCondSignal();
    mInBufferLock = kdThreadMutexCreate(KD_NULL);
    mOutBufferLock = kdThreadMutexCreate(KD_NULL);
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${synchronized}${name}${(}${)}${throws} {
  ${body}}
"
	
	
	
      end

      operation 11995788 "~OmxAudDecoderClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    OMX_LOGD(\"ENTER\");
    cleanUp();
    closeStream();
    delete mStateSignal;
    delete mEosSignal;
    if (mInBufferLock) {
      kdThreadMutexFree(mInBufferLock);
    }
    if (mOutBufferLock) {
      kdThreadMutexFree(mOutBufferLock);
    }
    OMX_LOGD(\"EXIT\");
  };
"
	
	
	
	
      end

      operation 11995916 "decTestEventHandler"
	class_operation cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 6
	  param in name "hComponent" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "pAppData" type class_ref 2633612 // OMX_PTR
	  param in name "eEvent" type class_ref 2647308 // OMX_EVENTTYPE
	  param in name "Data1" type class_ref 2633996 // OMX_U32
	  param in name "Data2" type class_ref 2633996 // OMX_U32
	  param in name "pEventData" type class_ref 2633612 // OMX_PTR
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_LOGD(\"pAppData %p, event %x data %lX-%lX\", pAppData,
        eEvent, Data1, Data2);
    OmxAudDecoderClient *ctx = reinterpret_cast<OmxAudDecoderClient *>(pAppData);
    switch (eEvent) {
      case OMX_EventCmdComplete:
        if (Data1 == OMX_CommandStateSet) {
          ctx->mStateSignal->setSignal();
          OMX_LOGI(\"Complete change to state %lX\", Data2);
        }
        break;
      default:
        break;
    }
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996044 "decTestEmptyBufferDone"
	class_operation cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 3
	  param in name "hComponent" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "pAppData" type class_ref 2633612 // OMX_PTR
	  param inout name "pBuffer" type class_ref 2635660 // OMX_BUFFERHEADERTYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_LOGD(\"buffer %p\", pBuffer);
    OmxAudDecoderClient *ctx = reinterpret_cast<OmxAudDecoderClient *>(pAppData);
    kdThreadMutexLock(ctx->mInBufferLock);
    pBuffer->nFlags = 0;
    ctx->mInputBuffers.push_back(pBuffer);
    kdThreadMutexUnlock(ctx->mInBufferLock);
    if (ctx->mEOS == OMX_FALSE) {
      ctx->pushOneInputBuffer();
    }
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996172 "decTestFillBufferDone"
	class_operation cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 3
	  param in name "hComponent" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "pAppData" type class_ref 2633612 // OMX_PTR
	  param inout name "pBuffer" type class_ref 2635660 // OMX_BUFFERHEADERTYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OmxAudDecoderClient *ctx = reinterpret_cast<OmxAudDecoderClient *>(pAppData);
    OMX_LOGI(\"Frame %d, buffer %p, length %lu\",
        ctx->mOutputFrameNum, pBuffer, pBuffer->nFilledLen);
    ctx->renderOutputData();
    ctx->mOutputFrameNum++;
    OMX_BOOL isEOS =
        (pBuffer->nFlags & OMX_BUFFERFLAG_EOS) ? OMX_TRUE : OMX_FALSE;
    pBuffer->nFilledLen = 0;
    pBuffer->nFlags = 0;
    if (isEOS && ctx->mOutputEOS == OMX_FALSE) {
      OMX_LOGI(\"Receive EOS on output port\");
      ctx->mEosSignal->setSignal();
      ctx->mOutputEOS = OMX_TRUE;
    }
    if (!ctx->mOutputEOS) {
      kdThreadMutexLock(ctx->mOutBufferLock);
      ctx->mOutputBuffers.push_back(pBuffer);
      kdThreadMutexUnlock(ctx->mOutBufferLock);
      ctx->pushOutputBuffer();
    }
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996300 "allocateAllPortsBuffer"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "compHandle" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "domain" type class_ref 2648076 // OMX_PORTDOMAINTYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_PORT_PARAM_TYPE oParam;
    InitOmxHeader(&oParam);
    OMX_INDEXTYPE param_index = OMX_IndexComponentStartUnused;
    switch (domain) {
      case OMX_PortDomainAudio:
        param_index = OMX_IndexParamAudioInit;
        break;
      case OMX_PortDomainVideo:
        param_index = OMX_IndexParamVideoInit;
        break;
      case OMX_PortDomainImage:
        param_index = OMX_IndexParamImageInit;
        break;
      case OMX_PortDomainOther:
        param_index = OMX_IndexParamOtherInit;
        break;
      default:
        OMX_LOGE(\"Incoreect domain %x\", domain);
    }
    err = OMX_GetParameter(compHandle, param_index, &oParam);
    ASSERT_EQ(err, OMX_ErrorNone);
    if (oParam.nPorts > 0) {
      mBufHdr[domain] = new OMX_BUFFERHEADERTYPE **[oParam.nPorts];
    }
    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOmxHeader(&def);
    for (OMX_U32 i = oParam.nStartPortNumber, port = 0; i < oParam.nPorts;
        i++, port++) {
      if (i != oParam.nStartPortNumber) {
        OMX_LOGD(\"allocate the input buffers only.\");
        continue;
      }
      def.nPortIndex = i;
      err = OMX_GetParameter(
          compHandle, OMX_IndexParamPortDefinition, &def);
      ASSERT_EQ(err, OMX_ErrorNone);
      mBufHdr[domain][port] =
          new OMX_BUFFERHEADERTYPE *[def.nBufferCountActual];
      for (OMX_U32 j = 0; j < def.nBufferCountActual; j++) {
        err = OMX_AllocateBuffer(compHandle, &mBufHdr[domain][port][j], i, NULL,
            def.nBufferSize);
        OMX_LOGD(\"err = 0x%x, j = %d, def.nBufferCountActual = %d\", err, j, def.nBufferCountActual);
        ASSERT_EQ(err, OMX_ErrorNone);
      }
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996428 "getPortParam"
	cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "compHandle" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "domain" type class_ref 2648076 // OMX_PORTDOMAINTYPE
	  param inout name "param" type class_ref 2647948 // OMX_PORT_PARAM_TYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_INDEXTYPE param_index = OMX_IndexComponentStartUnused;
    switch (domain) {
      case OMX_PortDomainAudio:
        param_index = OMX_IndexParamAudioInit;
        break;
      case OMX_PortDomainVideo:
        param_index = OMX_IndexParamVideoInit;
        break;
      case OMX_PortDomainImage:
        param_index = OMX_IndexParamImageInit;
        break;
      case OMX_PortDomainOther:
        param_index = OMX_IndexParamOtherInit;
        break;
      default:
        OMX_LOGE(\"Incoreect domain %x\", domain);
        break;
    }
    ASSERT_NE(param_index, OMX_IndexComponentStartUnused);
    OMX_ERRORTYPE err = OMX_GetParameter(compHandle, param_index, param);
    ASSERT_EQ(err, OMX_ErrorNone);
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996556 "freeAllPortsBuffer"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "compHandle" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "domain" type class_ref 2648076 // OMX_PORTDOMAINTYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_PORT_PARAM_TYPE oParam;
    InitOmxHeader(&oParam);
    getPortParam(compHandle, domain, &oParam);
    if (oParam.nPorts <= 0) {
      return;
    }
    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOmxHeader(&def);
    for (OMX_U32 i = oParam.nStartPortNumber, port = 0; i < oParam.nPorts;
        i++, port++) {
      if (i != oParam.nStartPortNumber) {
        OMX_LOGD(\"free the input buffers only.\");
        continue;
      }
      def.nPortIndex = i;
      err = OMX_GetParameter(compHandle, OMX_IndexParamPortDefinition, &def);
      ASSERT_EQ(err, OMX_ErrorNone);
      for (OMX_U32 j = 0; j < def.nBufferCountActual; j++) {
        err = OMX_FreeBuffer(compHandle, i, mBufHdr[domain][port][j]);
        ASSERT_EQ(err, OMX_ErrorNone);
      }
      delete[] mBufHdr[domain][port];
    }
    delete[] mBufHdr[domain];
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996684 "queueAllPortsBuffer"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "domain" type class_ref 2648076 // OMX_PORTDOMAINTYPE
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_PORT_PARAM_TYPE oParam;
    InitOmxHeader(&oParam);
    getPortParam(mCompHandle, domain, &oParam);
    if (oParam.nPorts <= 0) {
      OMX_LOGD(\"EXIT\");
      return;
    }
    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOmxHeader(&def);
    for (OMX_U32 i = oParam.nStartPortNumber, port = 0; i < oParam.nPorts;
        i++, port++) {
      if (i != oParam.nStartPortNumber) {
        OMX_LOGD(\"queue the input buffers only.\");
        continue;
      }
      def.nPortIndex = i;
      err = OMX_GetParameter(mCompHandle, OMX_IndexParamPortDefinition, &def);
      ASSERT_EQ(err, OMX_ErrorNone);
      for (OMX_U32 j = 0; j < def.nBufferCountActual; j++) {
        if (def.eDir == OMX_DirInput) {
          mInputBuffers.push_back(mBufHdr[domain][port][j]);
        } else {
          mOutputBuffers.push_back(mBufHdr[domain][port][j]);
        }
        ASSERT_EQ(err, OMX_ErrorNone);
      }
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996812 "openStream"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    // register all file formats
    av_register_all();
    int err = avformat_open_input(&mAvFormatCtx, mStreamName, NULL, NULL);
    ASSERT_GE(err, 0);
    err = avformat_find_stream_info(mAvFormatCtx, NULL);
    ASSERT_GE(err, 0);
    // select the video or audio stream
    int idx  = av_find_best_stream(mAvFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);

    // stream index should be >=0
    ASSERT_GE(idx, 0);
    mStreamIndex = idx;
    OMX_LOGD(\"Using stream %d\", idx);
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11996940 "closeStream"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    if (NULL != mAvFormatCtx) {
      avformat_close_input(&mAvFormatCtx);
      mAvFormatCtx = NULL;
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997068 "pushCodecConfigData"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE ret;
    AVCodecContext *codec_ctx = mAvFormatCtx->streams[mStreamIndex]->codec;
    if (codec_ctx->extradata_size > 0) {
      vector<OMX_BUFFERHEADERTYPE *>::iterator it = mInputBuffers.begin();
      OMX_BUFFERHEADERTYPE *buf = *it;
      AVCodecContext *codec_ctx = mAvFormatCtx->streams[mStreamIndex]->codec;
      kdMemcpy(buf->pBuffer, codec_ctx->extradata, codec_ctx->extradata_size);
      buf->nFilledLen = codec_ctx->extradata_size;
      buf->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;
      //dump_bytes(codec_ctx->extradata, codec_ctx->extradata_size);
      ret = OMX_EmptyThisBuffer(mCompHandle, buf);
      mInputBuffers.erase(it);
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997196 "setPCMFormat"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "inputPortIdx" type class_ref 2633996 // OMX_U32
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE ret = OMX_ErrorNone;
    AVCodecContext *codec_ctx = mAvFormatCtx->streams[mStreamIndex]->codec;

    OMX_AUDIO_PARAM_PCMMODETYPE param;
    InitOmxHeader(&param);
    param.nPortIndex = inputPortIdx;
    ret = OMX_GetParameter(mCompHandle, OMX_IndexParamAudioPcm, &param);
    if (OMX_ErrorNone != ret) {
      OMX_LOGE(\"Failed to OMX_GetParameter(OMX_IndexParamAudioPcm) with error %d\", ret);
      return;
    }

    param.eNumData = OMX_NumericalDataSigned;
    param.eEndian = OMX_EndianLittle;
    param.bInterleaved = OMX_TRUE;
    param.ePCMMode = OMX_AUDIO_PCMModeLinear;
    param.nSamplingRate = codec_ctx->sample_rate;
    param.nChannels = codec_ctx->channels;
    switch (codec_ctx->codec_id) {
      case CODEC_ID_PCM_U8:
        param.nBitPerSample = 8;
        param.eNumData = OMX_NumericalDataUnsigned;
        break;
      case CODEC_ID_PCM_S16LE:
        param.nBitPerSample = 16;
        break;
      case CODEC_ID_PCM_S16BE:
        param.nBitPerSample = 16;
        param.eEndian = OMX_EndianBig;
        break;
      case CODEC_ID_PCM_S24LE:
        param.nBitPerSample = 24;
        break;
        break;
      case CODEC_ID_PCM_S24BE:
        param.nBitPerSample = 24;
        param.eEndian = OMX_EndianBig;
        break;
      default:
        param.nBitPerSample = 16;
    }
    OMX_LOGE(\"param.nBitPerSample = %d, SamplingRate = %d, Channels = %d\",
        param.nBitPerSample, param.nSamplingRate, param.nChannels);

    ret = OMX_SetParameter(mCompHandle, OMX_IndexParamAudioPcm, &param);
    if (OMX_ErrorNone != ret) {
      OMX_LOGE(\"Failed to OMX_SetParameter(OMX_IndexParamAudioPcm) with error %d\", ret);
      return;
    }

    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997324 "configOutputPort"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE ret = OMX_ErrorNone;
    AVCodecContext *codec_ctx = mAvFormatCtx->streams[mStreamIndex]->codec;
    OMX_PORT_PARAM_TYPE oParam;
    InitOmxHeader(&oParam);
    if (strstr(mCompName, \"video_decoder\")) {
      ret = OMX_GetParameter(mCompHandle, OMX_IndexParamVideoInit, &oParam);
    } else if (strstr(mCompName, \"audio_decoder\")) {
      if (CODEC_ID_AAC == codec_ctx->codec_id) {
        ret = OMX_GetParameter(mCompHandle, OMX_IndexParamAudioInit, &oParam);
        if (strstr(mCompName, \"aac\")) {
          OMX_LOGD(\"aac config\\n\");
          OMX_AUDIO_PARAM_AACPROFILETYPE profile;
          InitOmxHeader(&profile);
          profile.nPortIndex = 0;

          ret = OMX_GetParameter(
              mCompHandle, OMX_IndexParamAudioAac, &profile);
          ASSERT_EQ(ret, OMX_ErrorNone);
          profile.nChannels = codec_ctx->channels;
          profile.nSampleRate = codec_ctx->sample_rate;

          profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;

          ret = OMX_SetParameter(
              mCompHandle, OMX_IndexParamAudioAac, &profile);

          ASSERT_EQ(ret, OMX_ErrorNone);
        }
      } else if ((CODEC_ID_PCM_S16LE == codec_ctx->codec_id) ||
          (CODEC_ID_PCM_S16BE == codec_ctx->codec_id) ||
          (CODEC_ID_PCM_U8 == codec_ctx->codec_id) ||
          (CODEC_ID_PCM_S24LE == codec_ctx->codec_id) ||
          (CODEC_ID_PCM_S24BE == codec_ctx->codec_id)) {
        InitOmxHeader(&oParam);
        ret = OMX_GetParameter(mCompHandle, OMX_IndexParamAudioInit, &oParam);
        if (OMX_ErrorNone != ret) {
          OMX_LOGE(\"Failed to OMX_GetParameter(OMX_IndexParamAudioInit) with error %d\", ret);
          return;
        }
        OMX_LOGD(\"oParam.nStartPortNumber = %d, oParam.nPorts = %d\",
            oParam.nStartPortNumber, oParam.nPorts);
        setPCMFormat(oParam.nStartPortNumber);
      }
      OMX_LOGD(\"EXIT\");
      return;
    } else {
      OMX_LOGE(\"Invalid component name %s\\n\", mCompName);
    }
    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOmxHeader(&def);
    for (OMX_U32 i = oParam.nStartPortNumber; i < oParam.nPorts; i++) {
      def.nPortIndex = i;
      ret = OMX_GetParameter(mCompHandle, OMX_IndexParamPortDefinition, &def);
      ASSERT_EQ(ret, OMX_ErrorNone);
      if (def.eDir == OMX_DirOutput) {
        OMX_LOGD(\"Change output: width %d, height %d\", codec_ctx->coded_width,
            codec_ctx->coded_height);
        def.format.video.nFrameWidth = codec_ctx->coded_width;
        def.format.video.nFrameHeight = codec_ctx->coded_height;
        def.format.video.nStride = codec_ctx->coded_width;
        def.format.video.nSliceHeight = codec_ctx->coded_height;
        def.format.video.eColorFormat = OMX_COLOR_FormatYUV422Planar;
        def.nBufferSize = codec_ctx->coded_width * codec_ctx->coded_height * 2;
        ret = OMX_SetParameter(mCompHandle, OMX_IndexParamPortDefinition, &def);
        ASSERT_EQ(ret, OMX_ErrorNone);
      }
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997452 "GetTimeStampInUs"
	cpp_inline public explicit_return_type "uint64_t"
	nparams 2
	  param in name "time_stamp" type class_ref 2603788 // int64_t
	  param inout name "pAVRational" explicit_type "AVRational"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    // If the pAVRational->num is too big, we have to use float type, otherwise it will overflow
    if (pAVRational->num > INT64_MAX / (int64_t)TIME_BASE_NUMER_1MHZ / 1000000) {
      return ((float)pAVRational->num / pAVRational->den) * TIME_BASE_NUMER_1MHZ * time_stamp;
    }

    if (INT64_MAX / TIME_BASE_NUMER_1MHZ >=
       (time_stamp < 0) ? time_stamp * -1 : time_stamp) {
     return (time_stamp * TIME_BASE_NUMER_1MHZ * pAVRational->num) /
         static_cast<int64_t>(pAVRational->den);
    } else {
     return (time_stamp * TIME_BASE_NUMER_1KHZ * pAVRational->num) /
         static_cast<int64_t>(pAVRational->den * UINT64_C(1000000));
    }
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997580 "feedInputData"
	cpp_inline public return_type class_ref 2636172 // OMX_BOOL
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE ret = OMX_ErrorNone;
    OMX_BOOL feeded = OMX_FALSE;
    AVStream *current_stream = NULL;
    int err = 0;

    AVPacket pkt;
    av_init_packet(&pkt);
    err = av_read_frame(mAvFormatCtx, &pkt);
    if (pkt.stream_index == mStreamIndex || (mEOS == OMX_FALSE && err < 0)) {
      vector<OMX_BUFFERHEADERTYPE *>::iterator it = mInputBuffers.begin();
      OMX_BUFFERHEADERTYPE *buf = *it;
      if (err < 0) {
        buf->nFlags = OMX_BUFFERFLAG_EOS;
        buf->nFilledLen = 0;
        mEOS = OMX_TRUE;
        OMX_LOGI(\"Input port got EOS\");
      } else {
        kdMemcpy(buf->pBuffer, pkt.data, pkt.size);
        buf->nFilledLen = pkt.size;
        //buf->nTimeStamp = (pkt.pts == AV_NOPTS_VALUE) ? pkt.dts : pkt.pts;
        current_stream = mAvFormatCtx->streams[mStreamIndex];
        buf->nTimeStamp = GetTimeStampInUs(pkt.pts, &(current_stream->time_base));
        OMX_LOGD(\"Push frame %d, pts %lld, size %lu\", mInputFrameNum,
            buf->nTimeStamp, buf->nFilledLen);
      }
      //dump_bytes( pkt.data, pkt.size);
      ret = OMX_EmptyThisBuffer(mCompHandle, buf);
      mInputFrameNum++;
      mInputBuffers.erase(it);
      feeded = OMX_TRUE;
    }
    av_free_packet(&pkt);
    OMX_LOGD(\"EXIT\");
    return feeded;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997708 "pushOneInputBuffer"
	cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    kdThreadMutexLock(mInBufferLock);
    if (mEOS == OMX_FALSE) {
      while (!mInputBuffers.empty() && !feedInputData()) {
      }
    }
    kdThreadMutexUnlock(mInBufferLock);
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997836 "pushInputBuffer"
	cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    kdThreadMutexLock(mInBufferLock);
    if (mEOS == OMX_FALSE) {
      while (!mInputBuffers.empty()) {
        feedInputData();
      }
    }
    kdThreadMutexUnlock(mInBufferLock);
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11997964 "pushOneOutputBuffer"
	cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    kdThreadMutexLock(mOutBufferLock);
    OMX_ERRORTYPE err;
    vector<OMX_BUFFERHEADERTYPE *>::iterator it;
    if (!mOutputBuffers.empty()) {
      it = mOutputBuffers.begin();
      err = OMX_FillThisBuffer(mCompHandle, *it);
      mOutputBuffers.erase(it);
    }
    kdThreadMutexUnlock(mOutBufferLock);
    OMX_LOGD(\"EXIT\");
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998092 "pushOutputBuffer"
	cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    kdThreadMutexLock(mOutBufferLock);
    vector<OMX_BUFFERHEADERTYPE *>::iterator it;
    while (!mOutputBuffers.empty()) {
      it = mOutputBuffers.begin();
      err = OMX_FillThisBuffer(mCompHandle, *it);
      mOutputBuffers.erase(it);
    }
    kdThreadMutexUnlock(mOutBufferLock);
    OMX_LOGD(\"EXIT\");
    return err;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998220 "renderOutputData"
	cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err = OMX_ErrorNone;
    OMX_LOGD(\"EXIT\");
    return err;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998348 "testLoadedToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateLoaded);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);
    allocateAllPortsBuffer(mCompHandle, OMX_PortDomainAudio);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to idle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to idle\");

    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998476 "testIdleToExec"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateExecuting,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Executing\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Executing\");

    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998604 "testExecToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateExecuting);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to OMX_StateIdle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to OMX_StateIdle\");

    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998732 "testIdleToLoaded"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateLoaded,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);
    freeAllPortsBuffer(mCompHandle, OMX_PortDomainAudio);
    freeAllPortsBuffer(mCompHandle, OMX_PortDomainVideo);
    freeAllPortsBuffer(mCompHandle, OMX_PortDomainImage);
    freeAllPortsBuffer(mCompHandle, OMX_PortDomainOther);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Loaded\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Loaded\");

    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998860 "getStreamStartTime"
	cpp_inline public return_type class_ref 2603788 // int64_t
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"mAvFormatCtx->start_time = %lld us\", mAvFormatCtx->start_time);
    return mAvFormatCtx->start_time;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11998988 "prepare"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    // Prepare
    err = OMX_GetHandle(&mCompHandle, mCompName, this, &decTestCallbacks);
    ASSERT_EQ(err, OMX_ErrorNone);
    mEOS = OMX_FALSE;
    mOutputEOS = OMX_FALSE;
    mInputFrameNum = 0;
    mOutputFrameNum = 0;
    //configOutputPort();
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11999116 "cleanUp"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER\");
    OMX_ERRORTYPE err;
    if (NULL != mCompHandle) {
      err = OMX_FreeHandle(mCompHandle);
      ASSERT_EQ(err, OMX_ErrorNone);
      mCompHandle = NULL;
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end
    end

    class 2960908 "OmxAudRendererClient"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 5451916 // mCompHandle (<directional composition>)
	relation 5451788 *-->
	  a role_name "mCompHandle" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5451916 // mCompHandle (<directional composition>)
	  b parent class_ref 2635404 // OMX_HANDLETYPE
      end

      classrelation 5452044 // mCompName (<directional composition>)
	relation 5451916 *-->
	  a role_name "mCompName" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452044 // mCompName (<directional composition>)
	  b parent class_ref 2633868 // OMX_STRING
      end

      classrelation 5452172 // aRenTestCallbacks (<directional composition>)
	relation 5452044 *-->
	  a role_name "aRenTestCallbacks" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452172 // aRenTestCallbacks (<directional composition>)
	  b parent class_ref 2633484 // OMX_CALLBACKTYPE
      end

      classrelation 5452300 // mStateSignal (<unidirectional association>)
	relation 5452172 --->
	  a role_name "mStateSignal" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452300 // mStateSignal (<unidirectional association>)
	  b parent class_ref 2960652 // kdCondSignal
      end

      operation 11999244 "OmxAudRendererClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} {
    aRenTestCallbacks.EventHandler = aRenTestEventHandler;
    mStateSignal = new kdCondSignal();
  };
"
	java_def "  ${comment}${@}${visibility}${final}${synchronized}${name}${(}${)}${throws} {
  ${body}}
"
	
	
	
      end

      operation 11999372 "~OmxAudRendererClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    delete mStateSignal;
  };
"
	
	
	
	
      end

      operation 11999500 "prepare"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    // Prepare
    err = OMX_GetHandle(&mCompHandle, mCompName, this, &aRenTestCallbacks);
    ASSERT_EQ(err, OMX_ErrorNone);
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11999628 "cleanUp"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    if (NULL != mCompHandle) {
      err = OMX_FreeHandle(mCompHandle);
      ASSERT_EQ(err, OMX_ErrorNone);
      mCompHandle = NULL;
    }
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11999756 "testLoadedToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateLoaded);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to idle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to idle\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 11999884 "testIdleToExec"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateExecuting,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Executing\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Executing\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12000012 "testExecToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateExecuting);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to OMX_StateIdle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to OMX_StateIdle\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12000140 "testIdleToLoaded"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateLoaded,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Loaded\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Loaded\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12000268 "aRenTestEventHandler"
	class_operation cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 6
	  param in name "hComponent" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "pAppData" type class_ref 2633612 // OMX_PTR
	  param in name "eEvent" type class_ref 2647308 // OMX_EVENTTYPE
	  param in name "Data1" type class_ref 2633996 // OMX_U32
	  param in name "Data2" type class_ref 2633996 // OMX_U32
	  param in name "pEventData" type class_ref 2633612 // OMX_PTR
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"pAppData %p, event %x data %lX-%lX\", pAppData,
        eEvent, Data1, Data2);
    OmxAudRendererClient *ctx = reinterpret_cast<OmxAudRendererClient *>(pAppData);
    switch (eEvent) {
      case OMX_EventCmdComplete:
        if (Data1 == OMX_CommandStateSet) {
          ctx->mStateSignal->setSignal();
          OMX_LOGI(\"Complete change to state %lX\", Data2);
        }
        break;
      default:
        break;
    }
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end
    end

    class 2961036 "OmxClockClient"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 5452428 // mCompHandle (<directional composition>)
	relation 5452300 *-->
	  a role_name "mCompHandle" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452428 // mCompHandle (<directional composition>)
	  b parent class_ref 2635404 // OMX_HANDLETYPE
      end

      classrelation 5452556 // mCompName (<directional composition>)
	relation 5452428 *-->
	  a role_name "mCompName" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452556 // mCompName (<directional composition>)
	  b parent class_ref 2633868 // OMX_STRING
      end

      classrelation 5452684 // clockTestCallbacks (<directional composition>)
	relation 5452556 *-->
	  a role_name "clockTestCallbacks" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452684 // clockTestCallbacks (<directional composition>)
	  b parent class_ref 2633484 // OMX_CALLBACKTYPE
      end

      classrelation 5452812 // mStateSignal (<unidirectional association>)
	relation 5452684 --->
	  a role_name "mStateSignal" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5452812 // mStateSignal (<unidirectional association>)
	  b parent class_ref 2960652 // kdCondSignal
      end

      operation 12000396 "OmxClockClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} {
    clockTestCallbacks.EventHandler = aClockTestEventHandler;
    mStateSignal = new kdCondSignal();
  };
"
	java_def "  ${comment}${@}${visibility}${final}${synchronized}${name}${(}${)}${throws} {
  ${body}}
"
	
	
	
      end

      operation 12000524 "~OmxClockClient"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    delete mStateSignal;
  };
"
	
	
	
	
      end

      operation 12000652 "prepare"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    // Prepare
    err = OMX_GetHandle(&mCompHandle, mCompName, this, &clockTestCallbacks);
    ASSERT_EQ(err, OMX_ErrorNone);
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12000780 "cleanUp"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    if (NULL != mCompHandle) {
      err = OMX_FreeHandle(mCompHandle);
      ASSERT_EQ(err, OMX_ErrorNone);
      mCompHandle = NULL;
    }
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12000908 "startClock"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "startTimeUs" type class_ref 2603788 // int64_t
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER, startTimeUs = %lld us\", startTimeUs);
    OMX_TIME_CONFIG_CLOCKSTATETYPE conf;
    InitOmxHeader(&conf);
    conf.eState = OMX_TIME_ClockStateRunning;
    conf.nStartTime = static_cast<OMX_TICKS>(startTimeUs);
    conf.nOffset = static_cast<OMX_TICKS>(0);
    OMX_ERRORTYPE err = OMX_SetConfig(mCompHandle, OMX_IndexConfigTimeClockState, &conf);
    if (err != OMX_ErrorNone) {
      // TODO: error handling
      OMX_LOGE(\"OMX_SetConfig(OMX_IndexConfigTimeClockState) failed with error %d\", err);
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001036 "setScale"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "scale" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"ENTER, scale = %f\", scale);
    OMX_TIME_CONFIG_SCALETYPE conf;
    InitOmxHeader(&conf);
    conf.xScale = static_cast<OMX_S32>(scale * 0x10000);
    if (conf.xScale != 0x0 && conf.xScale != 0x10000) {
      // TODO: Support trick play.
      OMX_LOGE(\"Trick play is not supported: scale = %lf\", scale);
      return;
    }
    OMX_ERRORTYPE err = OMX_SetConfig(mCompHandle, OMX_IndexConfigTimeScale, &conf);
    if (err != OMX_ErrorNone) {
      // TODO: error handling
      OMX_LOGE(\"OMX_SetConfig(OMX_IndexConfigTimeScale) failed with error %d\", err);
    }
    OMX_LOGD(\"EXIT\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001164 "testLoadedToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateLoaded);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to idle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to idle\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001292 "testIdleToExec"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateExecuting,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Executing\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Executing\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001420 "testExecToIdle"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateExecuting);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateIdle,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for state change to OMX_StateIdle\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to OMX_StateIdle\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001548 "testIdleToLoaded"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err;
    OMX_STATETYPE state = OMX_StateInvalid;
    err = OMX_GetState(mCompHandle, &state);
    ASSERT_EQ(err, OMX_ErrorNone);
    ASSERT_EQ(state, OMX_StateIdle);
    mStateSignal->resetSignal();
    err = OMX_SendCommand(mCompHandle, OMX_CommandStateSet, OMX_StateLoaded,
        NULL);
    ASSERT_EQ(err, OMX_ErrorNone);

    // Waiting for command complete
    OMX_LOGD(\"Waiting for change state to Loaded\");
    mStateSignal->waitSignal();
    OMX_LOGD(\"State changed to Loaded\");
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001676 "aClockTestEventHandler"
	class_operation cpp_inline public return_type class_ref 2633356 // OMX_ERRORTYPE
	nparams 6
	  param in name "hComponent" type class_ref 2635404 // OMX_HANDLETYPE
	  param in name "pAppData" type class_ref 2633612 // OMX_PTR
	  param in name "eEvent" type class_ref 2647308 // OMX_EVENTTYPE
	  param in name "Data1" type class_ref 2633996 // OMX_U32
	  param in name "Data2" type class_ref 2633996 // OMX_U32
	  param in name "pEventData" type class_ref 2633612 // OMX_PTR
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}${)}${const}${volatile}${throw}${abstract} {
    OMX_LOGD(\"pAppData %p, event %x data %lX-%lX\", pAppData,
        eEvent, Data1, Data2);
    OmxClockClient *ctx = reinterpret_cast<OmxClockClient *>(pAppData);
    switch (eEvent) {
      case OMX_EventCmdComplete:
        if (Data1 == OMX_CommandStateSet) {
          ctx->mStateSignal->setSignal();
          OMX_LOGI(\"Complete change to state %lX\", Data2);
        }
        break;
      default:
        break;
    }
    return OMX_ErrorNone;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end
    end

    class 2961164 "OmxAudTunnelTest"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 5452940 // <generalisation>
	relation 5452812 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 5452940 // <generalisation>
	  b parent class_ref 2961292 // typedef189
      end

      classrelation 5453068 // mAudDecClient (<unidirectional association>)
	relation 5452940 --->
	  a role_name "mAudDecClient" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5453068 // mAudDecClient (<unidirectional association>)
	  b parent class_ref 2960780 // OmxAudDecoderClient
      end

      classrelation 5453196 // mAudRenClient (<unidirectional association>)
	relation 5453068 --->
	  a role_name "mAudRenClient" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5453196 // mAudRenClient (<unidirectional association>)
	  b parent class_ref 2960908 // OmxAudRendererClient
      end

      classrelation 5453324 // mOmxClockClient (<unidirectional association>)
	relation 5453196 --->
	  a role_name "mOmxClockClient" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5453324 // mOmxClockClient (<unidirectional association>)
	  b parent class_ref 2961036 // OmxClockClient
      end

      classrelation 5453452 // mStreamName (<directional composition>)
	relation 5453324 *-->
	  a role_name "mStreamName" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 5453452 // mStreamName (<directional composition>)
	  b parent class_ref 2633868 // OMX_STRING
      end

      operation 12001804 "SetUp"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    OMX_ERRORTYPE err = OMX_Init();
    ASSERT_EQ(OMX_ErrorNone, err);
    mAudDecClient = new OmxAudDecoderClient;
    mAudRenClient = new OmxAudRendererClient;
    mOmxClockClient = new OmxClockClient;
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12001932 "TearDown"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    delete mAudDecClient;
    delete mAudRenClient;
    delete mOmxClockClient;
    OMX_ERRORTYPE err = OMX_Deinit();
    ASSERT_EQ(OMX_ErrorNone, err);
  };
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 12002060 "testAudTunnel"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end
    end

    class 2961292 "typedef189"
      visibility package stereotype "typedef" explicit_base_type "testing::Test"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end
  end

  deploymentview 273548 "berlin test"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 1121420 "kdCondSignal"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2960652 // kdCondSignal
      end
    end

    artifact 1121548 "OmxAudDecoderClient"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2960780 // OmxAudDecoderClient
      end
    end

    artifact 1121676 "OmxAudRendererClient"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2960908 // OmxAudRendererClient
      end
    end

    artifact 1121804 "OmxClockClient"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2961036 // OmxClockClient
      end
    end

    artifact 1121932 "typedef189"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2961292 // typedef189
      end
    end

    artifact 1122060 "OmxAudTunnelTest"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 2961164 // OmxAudTunnelTest
      end
    end
  end
end
