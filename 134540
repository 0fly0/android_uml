format 74
"nbaio" // framework::av::include::media::nbaio
  revision 1
  modified_by 12 "shchen"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_h_dir "/home/shchen/work/jellybean/framework/av/include/media/nbaio/"
  cpp_src_dir "/home/shchen/work/jellybean/framework/av/include/media/nbaio/"
  cpp_namespace "android"
  classview 131468 "nbaio"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 171020 "AudioBufferProviderSource"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 177804 // <generalisation>
	relation 177804 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 177804 // <generalisation>
	  b parent class_ref 171148 // NBAIO_Source
      end

      operation 329484 "AudioBufferProviderSource"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 2
	  param inout name "provider" type class_ref 146444 // AudioBufferProvider
	  param in name "format" type class_ref 171276 // NBAIO_Format
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)} :
    NBAIO_Source(format), mProvider(provider), mConsumed(0)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 329612 "~AudioBufferProviderSource"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 329740 "availableToRead"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format();
 NBAIO_Source interface
virtual size_t framesRead() const;
virtual size_t framesOverrun();
virtual size_t overruns();"
      end

      operation 329868 "read"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 3
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	  param in name "readPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 329996 "readVia"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 5
	  param in name "via" type class_ref 171404 // readVia_t
	  param in name "total" explicit_type "size_t"
	  param inout name "user" explicit_type "void"
	  param in name "readPTS" explicit_type "int64_t"
	  param in name "block" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} * ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      attribute 241036 "mProvider"
	private type class_ref 146444 // AudioBufferProvider
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 177932 // mBuffer (<directional composition>)
	relation 177932 *-->
	  a role_name "mBuffer" private
	    comment " current buffer"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 177932 // mBuffer (<directional composition>)
	  b parent class_ref 146572 // Buffer
      end

      attribute 241164 "mConsumed"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " number of frames consumed so far from current buffer"
      end
    end

    class 171148 "NBAIO_Source"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Abstract class (interface) representing a non-blocking data source, for use by a data consumer."
      classrelation 179468 // <generalisation>
	relation 179468 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 179468 // <generalisation>
	  b parent class_ref 172684 // NBAIO_Port
      end

      operation 336908 "framesRead"
	const cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mFramesRead; };
"
	
	
	
	
	comment " For the next two APIs:
 32 bits rolls over after 27 hours at 44.1 kHz; if that concerns you then poll periodically.
 Number of frames read successfully since construction."
      end

      operation 337036 "framesOverrun"
	cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
	comment " Number of frames lost due to overrun since construction.
 Not const because implementations may need to do I/O."
      end

      operation 337164 "overruns"
	cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
	comment " Number of overruns since construction, where a set of contiguous lost frames is one event.
 Not const because implementations may need to do I/O."
      end

      operation 337292 "availableToRead"
	cpp_virtual cpp_inline public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return SSIZE_MAX; };
"
	
	
	
	
	comment " Estimate of number of frames that could be read successfully now.
 When a read() is actually attempted, the implementation is permitted to return a smaller or
 larger transfer count, however it will make a good faith effort to give an accurate estimate.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  OVERRUN     One or more frames were lost due to overrun, try again to read more recent data.
  WOULD_BLOCK Determining how many frames can be read without blocking would itself block."
      end

      operation 337420 "read"
	abstract cpp_virtual public explicit_return_type "ssize_t"
	nparams 3
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	  param in name "readPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment " Transfer data from source into single destination buffer.  Implies a copy.
 Inputs:
  buffer  Non-NULL destination buffer owned by consumer.
  count   Maximum number of frames to transfer.
  readPTS The presentation time (on the LocalTime timeline) for which data
          is being requested, or kInvalidPTS if not known.
 Return value:
  > 0     Number of frames successfully transferred prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  WOULD_BLOCK No frames can be transferred without blocking.
  OVERRUN     read() has not been called frequently enough, or with enough frames to keep up.
              One or more frames were lost due to overrun, try again to read more recent data."
      end

      operation 337548 "readVia"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 5
	  param in name "via" type class_ref 171404 // readVia_t
	  param in name "total" explicit_type "size_t"
	  param inout name "user" explicit_type "void"
	  param in name "readPTS" explicit_type "int64_t"
	  param in name "block" explicit_type "size_t"
	    defaultvalue "0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "// This is a default implementation; it is expected that subclasses will optimize this.

${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} * ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " Transfer data from source using a series of callbacks.  More suitable for zero-fill,
 synthesis, and non-contiguous transfers (e.g. circular buffer or readv).
 Inputs:
  via     Callback function that the source will call as many times as needed to provide data.
  total   Estimate of the number of frames the consumer desires.  This is an estimate,
          and it can consume a different number of frames during the series of callbacks.
  user    Arbitrary void * reserved for data consumer.
  readPTS The presentation time (on the LocalTime timeline) for which data
          is being requested, or kInvalidPTS if not known.
  block   Number of frames per block, that is a suggested value for 'count' in each callback.
          Zero means no preference.  This parameter is a hint only, and may be ignored.
 Return value:
  > 0     Total number of frames successfully transferred prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  WOULD_BLOCK No frames can be transferred without blocking.
  OVERRUN     read() has not been called frequently enough, or with enough frames to keep up.
              One or more frames were lost due to overrun, try again to read more recent data.

 The 'via' callback is called by the data source as follows:
 Inputs:
  user    Arbitrary void * reserved for data consumer.
  dest    Non-NULL buffer owned by source that callback should consume data from,
          up to a maximum of 'count' frames.
  count   Maximum number of frames to transfer during this callback.
 Return value:
  > 0     Number of frames successfully transferred during this callback prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer during this callback."
      end

      operation 337676 "NBAIO_Source"
	cpp_inline protected explicit_return_type ""
	nparams 1
	  param in name "format" type class_ref 171276 // NBAIO_Format
	    defaultvalue "Format_Invalid"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw} : NBAIO_Port(format), mFramesRead(0) { };
"
	
	
	
	
      end

      operation 337804 "~NBAIO_Source"
	cpp_virtual cpp_inline protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      attribute 245772 "mFramesRead"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 171276 "NBAIO_Format"
      visibility package stereotype "enum"
      cpp_decl "${comment}enum ${name} {
${items}
};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Must (re-)negotiate format.  For negotiate() only, the offeree
 doesn't accept offers, and proposes counter-offers
 availableToRead(), read(), or readVia() detected lost input due
 to overrun; an event is counted and the caller should re-try
 availableToWrite(), write(), or writeVia() detected a gap in
 output due to underrun (not being called often enough, or with
 enough data); an event is counted and the caller should re-try
 Negotiation of format is based on the data provider and data sink, or the data consumer and
 data source, exchanging prioritized arrays of offers and counter-offers until a single offer is
 mutually agreed upon.  Each offer is an NBAIO_Format.  For simplicity and performance,
 NBAIO_Format is an enum that ties together the most important combinations of the various
 attributes, rather than a struct with separate fields for format, sample rate, channel count,
 interleave, packing, alignment, etc.  The reason is that NBAIO_Format tries to abstract out only
 the combinations that are actually needed within AudioFligner.  If the list of combinations grows
 too large, then this decision should be re-visited."
      attribute 244748 "Format_Invalid"
	public type class_ref 171276 // NBAIO_Format
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 244876 "Format_SR44_1_C2_I16"
	public type class_ref 171276 // NBAIO_Format
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 245004 "Format_SR48_C2_I16"
	public type class_ref 171276 // NBAIO_Format
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 245132 "Format_SR44_1_C1_I16"
	public type class_ref 171276 // NBAIO_Format
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 245260 "Format_SR48_C1_I16"
	public type class_ref 171276 // NBAIO_Format
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 171404 "readVia_t"
      visibility package stereotype "typedef" explicit_base_type "ssize_t"
      cpp_decl "${comment}typedef ${type}(* ${name})(void *user, const void *buffer,
                             size_t count, int64_t readPTS);
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 171532 "AudioStreamInSource"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " not multi-thread safe"
      classrelation 178060 // <generalisation>
	relation 178060 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178060 // <generalisation>
	  b parent class_ref 171148 // NBAIO_Source
      end

      operation 330124 "AudioStreamInSource"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "stream" explicit_type "audio_stream_in"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)} :
        NBAIO_Source(),
        mStream(stream),
        mStreamBufferSizeBytes(0),
        mFramesOverrun(0),
        mOverruns(0)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 330252 "~AudioStreamInSource"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 330380 "negotiate"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 4
	  param in name "offers" type class_ref 171276 // NBAIO_Format
	  param in name "numOffers" explicit_type "size_t"
	  param in name "counterOffers" type class_ref 171276 // NBAIO_Format
	  param inout name "numCounterOffers" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}[]${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}[]${v2}, ${t3} & ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} ${p0}[], ${t1} ${p1}, ${t2} ${p2}[], ${t3} & ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface"
      end

      operation 330508 "framesOverrun"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual NBAIO_Format format() const;
 NBAIO_Sink interface
virtual size_t framesRead() const;"
      end

      operation 330636 "overruns"
	cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { (void) framesOverrun(); return mOverruns; };
"
	
	
	
	
      end

      operation 330764 "availableToRead"
	cpp_virtual cpp_inline public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mStreamBufferSizeBytes >> mBitShift; };
"
	
	
	
	
	comment " This is an over-estimate, and could dupe the caller into making a blocking read()
 FIXME Use an audio HAL API to query the buffer filling status when it's available."
      end

      operation 330892 "read"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 331020 "stream"
	const cpp_inline public explicit_return_type "audio_stream_in"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mStream; };
"
	
	
	
	
      end

      attribute 241292 "mStream"
	private explicit_type "audio_stream_in"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 241420 "mStreamBufferSizeBytes"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " as reported by get_buffer_size()"
      end

      attribute 241548 "mFramesOverrun"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 241676 "mOverruns"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 171660 "AudioStreamOutSink"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " not multi-thread safe"
      classrelation 178188 // <generalisation>
	relation 178188 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178188 // <generalisation>
	  b parent class_ref 171788 // NBAIO_Sink
      end

      operation 331148 "AudioStreamOutSink"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "stream" explicit_type "audio_stream_out"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)} :
        NBAIO_Sink(),
        mStream(stream),
        mStreamBufferSizeBytes(0)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 331276 "~AudioStreamOutSink"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 331404 "negotiate"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 4
	  param in name "offers" type class_ref 171276 // NBAIO_Format
	  param in name "numOffers" explicit_type "size_t"
	  param in name "counterOffers" type class_ref 171276 // NBAIO_Format
	  param inout name "numCounterOffers" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}[]${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}[]${v2}, ${t3} & ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} ${p0}[], ${t1} ${p1}, ${t2} ${p2}[], ${t3} & ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface"
      end

      operation 331532 "availableToWrite"
	const cpp_virtual cpp_inline public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mStreamBufferSizeBytes >> mBitShift; };
"
	
	
	
	
	comment "virtual NBAIO_Format format();
 NBAIO_Sink interface
virtual size_t framesWritten() const;
virtual size_t framesUnderrun() const;
virtual size_t underruns() const;
 This is an over-estimate, and could dupe the caller into making a blocking write()
 FIXME Use an audio HAL API to query the buffer emptying status when it's available."
      end

      operation 331660 "write"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param in name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 331788 "getNextWriteTimestamp"
	preserve_cpp_body_indent cpp_virtual public return_type class_ref 128268 // status_t
	nparams 1
	  param inout name "timestamp" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " AudioStreamOutSink wraps a HAL's output stream.  Its
 getNextWriteTimestamp method is simply a passthru to the HAL's underlying
 implementation of GNWT (if any)"
      end

      operation 331916 "stream"
	const cpp_inline public explicit_return_type "audio_stream_out"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mStream; };
"
	
	
	
	
      end

      attribute 241804 "mStream"
	private explicit_type "audio_stream_out"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 241932 "mStreamBufferSizeBytes"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " as reported by get_buffer_size()"
      end
    end

    class 171788 "NBAIO_Sink"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Abstract class (interface) representing a non-blocking data sink, for use by a data provider."
      classrelation 179340 // <generalisation>
	relation 179340 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 179340 // <generalisation>
	  b parent class_ref 172684 // NBAIO_Port
      end

      operation 335756 "framesWritten"
	const cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mFramesWritten; };
"
	
	
	
	
	comment " For the next two APIs:
 32 bits rolls over after 27 hours at 44.1 kHz; if that concerns you then poll periodically.
 Return the number of frames written successfully since construction."
      end

      operation 335884 "framesUnderrun"
	const cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
	comment " Number of frames lost due to underrun since construction."
      end

      operation 336012 "underruns"
	const cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
	comment " Number of underruns since construction, where a set of contiguous lost frames is one event."
      end

      operation 336140 "availableToWrite"
	const cpp_virtual cpp_inline public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return SSIZE_MAX; };
"
	
	
	
	
	comment " Estimate of number of frames that could be written successfully now without blocking.
 When a write() is actually attempted, the implementation is permitted to return a smaller or
 larger transfer count, however it will make a good faith effort to give an accurate estimate.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  UNDERRUN    write() has not been called frequently enough, or with enough frames to keep up.
              An underrun event is counted, and the caller should re-try this operation.
  WOULD_BLOCK Determining how many frames can be written without blocking would itself block."
      end

      operation 336268 "write"
	abstract cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param in name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment " Transfer data to sink from single input buffer.  Implies a copy.
 Inputs:
  buffer  Non-NULL buffer owned by provider.
  count   Maximum number of frames to transfer.
 Return value:
  > 0     Number of frames successfully transferred prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  WOULD_BLOCK No frames can be transferred without blocking.
  UNDERRUN    write() has not been called frequently enough, or with enough frames to keep up.
              An underrun event is counted, and the caller should re-try this operation."
      end

      operation 336396 "writeVia"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 4
	  param in name "via" type class_ref 172556 // writeVia_t
	  param in name "total" explicit_type "size_t"
	  param inout name "user" explicit_type "void"
	  param in name "block" explicit_type "size_t"
	    defaultvalue "0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "// This is a default implementation; it is expected that subclasses will optimize this.

${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} * ${p2}, ${t3} ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " Transfer data to sink using a series of callbacks.  More suitable for zero-fill, synthesis,
 and non-contiguous transfers (e.g. circular buffer or writev).
 Inputs:
  via     Callback function that the sink will call as many times as needed to consume data.
  total   Estimate of the number of frames the provider has available.  This is an estimate,
          and it can provide a different number of frames during the series of callbacks.
  user    Arbitrary void * reserved for data provider.
  block   Number of frames per block, that is a suggested value for 'count' in each callback.
          Zero means no preference.  This parameter is a hint only, and may be ignored.
 Return value:
  > 0     Total number of frames successfully transferred prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer.
 Errors:
  NEGOTIATE   (Re-)negotiation is needed.
  WOULD_BLOCK No frames can be transferred without blocking.
  UNDERRUN    write() has not been called frequently enough, or with enough frames to keep up.
              An underrun event is counted, and the caller should re-try this operation.

 The 'via' callback is called by the data sink as follows:
 Inputs:
  user    Arbitrary void * reserved for data provider.
  buffer  Non-NULL buffer owned by sink that callback should fill in with data,
          up to a maximum of 'count' frames.
  count   Maximum number of frames to transfer during this callback.
 Return value:
  > 0     Number of frames successfully transferred during this callback prior to first error.
  = 0     Count was zero.
  < 0     status_t error occurred prior to the first frame transfer during this callback."
      end

      operation 336524 "getNextWriteTimestamp"
	cpp_virtual cpp_inline public return_type class_ref 128268 // status_t
	nparams 1
	  param inout name "ts" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return INVALID_OPERATION; };
"
	
	
	
	
	comment " Get the time (on the LocalTime timeline) at which the first frame of audio of the next write
 operation to this sink will be eventually rendered by the HAL.
 Inputs:
  ts      A pointer pointing to the int64_t which will hold the result.
 Return value:
  OK      Everything went well, *ts holds the time at which the first audio frame of the next
          write operation will be rendered, or AudioBufferProvider::kInvalidPTS if this sink
          does not know the answer for some reason.  Sinks which eventually lead to a HAL
          which implements get_next_write_timestamp may return Invalid temporarily if the DMA
          output of the audio driver has not started yet.  Sinks which lead to a HAL which
          does not implement get_next_write_timestamp, or which don't lead to a HAL at all,
          will always return kInvalidPTS.
  <other> Something unexpected happened internally.  Check the logs and start debugging."
      end

      operation 336652 "NBAIO_Sink"
	cpp_inline protected explicit_return_type ""
	nparams 1
	  param in name "format" type class_ref 171276 // NBAIO_Format
	    defaultvalue "Format_Invalid"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw} : NBAIO_Port(format), mFramesWritten(0) { };
"
	
	
	
	
      end

      operation 336780 "~NBAIO_Sink"
	cpp_virtual cpp_inline protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      attribute 245644 "mFramesWritten"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 171916 "LibsndfileSink"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Implementation of NBAIO_Sink that wraps a libsndfile opened in SFM_WRITE mode"
      classrelation 178316 // <generalisation>
	relation 178316 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178316 // <generalisation>
	  b parent class_ref 171788 // NBAIO_Sink
      end

      operation 332044 "LibsndfileSink"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 2
	  param inout name "sndfile" explicit_type "SNDFILE"
	  param in name "sfinfo" explicit_type "SF_INFO"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, const ${t1} & ${p1}${)} :
    NBAIO_Sink(Format_from_SR_C(sfinfo.samplerate, sfinfo.channels)),
    mSndfile(sndfile)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 332172 "~LibsndfileSink"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 332300 "write"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param in name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Sink interface
virtual size_t framesWritten() const;
virtual size_t framesUnderrun() const;
virtual size_t underruns() const;
virtual ssize_t availableToWrite() const;"
      end

      attribute 242060 "mSndfile"
	private explicit_type "SNDFILE"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 172044 "LibsndfileSource"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Implementation of NBAIO_Source that wraps a libsndfile opened in SFM_READ mode"
      classrelation 178444 // <generalisation>
	relation 178444 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178444 // <generalisation>
	  b parent class_ref 171148 // NBAIO_Source
      end

      operation 332428 "LibsndfileSource"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param inout name "sndfile" explicit_type "SNDFILE"
	  param in name "sfinfo" explicit_type "SF_INFO"
	  param in name "loop" explicit_type "bool"
	    defaultvalue "false"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, const ${t1} & ${p1}, ${t2} ${p2}${)} :
    NBAIO_Source(Format_from_SR_C(sfinfo.samplerate, sfinfo.channels)),
    mSndfile(sndfile),
    mEstimatedFramesUntilEOF(sfinfo.frames),
    mLooping(loop && sfinfo.seekable),
    mReadAnyFramesThisLoopCycle(false)
${throw}{
  ${body}}
"
	
	
	
	
	comment " If 'loop' is true and it permits seeking, then we'll act as an infinite source"
      end

      operation 332556 "~LibsndfileSource"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 332684 "availableToRead"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Source interface
virtual size_t framesRead() const;
virtual size_t framesOverrun();
virtual size_t overruns();"
      end

      operation 332812 "read"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      attribute 242188 "mSndfile"
	private explicit_type "SNDFILE"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 242316 "mEstimatedFramesUntilEOF"
	private explicit_type "sf_count_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 242444 "mLooping"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 242572 "mReadAnyFramesThisLoopCycle"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 172172 "MonoPipe"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " MonoPipe is similar to Pipe except:
  - supports only a single reader, called MonoPipeReader
  - write() cannot overrun; instead it will return a short actual count if insufficient space
  - write() can optionally block if the pipe is full
 Like Pipe, it is not multi-thread safe for either writer or reader
 but writer and reader can be different threads."
      classrelation 178572 // <generalisation>
	relation 178572 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178572 // <generalisation>
	  b parent class_ref 171788 // NBAIO_Sink
      end

      classrelation 178700 // <dependency>
	relation 178700 -_->
	  stereotype "friend"
	  a default
	    cpp default "Generated"
	    classrelation_ref 178700 // <dependency>
	  b parent class_ref 172300 // MonoPipeReader
      end

      operation 332940 "MonoPipe"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param in name "reqFrames" explicit_type "size_t"
	  param in name "format" type class_ref 171276 // NBAIO_Format
	  param in name "writeCanBlock" explicit_type "bool"
	    defaultvalue "false"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)} :
        NBAIO_Sink(format),
        mUpdateSeq(0),
        mReqFrames(reqFrames),
        mMaxFrames(roundup(reqFrames)),
        mBuffer(malloc(mMaxFrames * Format_frameSize(format))),
        mFront(0),
        mRear(0),
        mWriteTsValid(false),
        // mWriteTs
        mSetpoint((reqFrames * 11) / 16),
        mWriteCanBlock(writeCanBlock),
        mIsShutdown(false)
${throw}{
  ${body}}
"
	
	
	
	
	comment " reqFrames will be rounded up to a power of 2, and all slots are available. Must be >= 2.
 Note: whatever shares this object with another thread needs to do so in an SMP-safe way (like
 creating it the object before creating the other thread, or storing the object with a
 release_store). Otherwise the other thread could see a partially-constructed object."
      end

      operation 333068 "~MonoPipe"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 333196 "availableToWrite"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Sink interface
virtual size_t framesWritten() const;
virtual size_t framesUnderrun() const;
virtual size_t underruns() const;"
      end

      operation 333324 "write"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param in name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 333452 "getNextWriteTimestamp"
	preserve_cpp_body_indent cpp_virtual public return_type class_ref 128268 // status_t
	nparams 1
	  param inout name "timestamp" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual ssize_t writeVia(writeVia_t via, size_t total, void *user, size_t block);
 MonoPipe's implementation of getNextWriteTimestamp works in conjunction
 with MonoPipeReader.  Every time a MonoPipeReader reads from the pipe, it
 receives a \"readPTS\" indicating the point in time for which the reader
 would like to read data.  This \"last read PTS\" is offset by the amt of
 data the reader is currently mixing and then cached cached along with the
 updated read pointer.  This cached value is the local time for which the
 reader is going to request data next time it reads data (assuming we are
 in steady state and operating with no underflows).  Writers to the
 MonoPipe who would like to know when their next write operation will hit
 the speakers can call getNextWriteTimestamp which will return the value
 of the last read PTS plus the duration of the amt of data waiting to be
 read in the MonoPipe."
      end

      operation 333580 "getAvgFrames"
	const cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mSetpoint; };
"
	
	
	
	
	comment " average number of frames present in the pipe under normal conditions.
 See throttling mechanism in MonoPipe::write()"
      end

      operation 333708 "setAvgFrames"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "setpoint" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 333836 "maxFrames"
	const cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mMaxFrames; };
"
	
	
	
	
      end

      operation 333964 "shutdown"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "bool"
	    defaultvalue "true"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " Set the shutdown state for the write side of a pipe.
 This may be called by an unrelated thread.  When shutdown state is 'true',
 a write that would otherwise block instead returns a short transfer count.
 There is no guarantee how long it will take for the shutdown to be recognized,
 but it will not be an unbounded amount of time.
 The state can be restored to normal by calling shutdown(false)."
      end

      operation 334092 "isShutdown"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " Return true if the write side of a pipe is currently shutdown."
      end

      operation 334220 "updateFrontAndNRPTS"
	preserve_cpp_body_indent private explicit_return_type "void"
	nparams 2
	  param in name "newFront" explicit_type "int32_t"
	  param in name "newNextRdPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " A pair of methods and a helper variable which allows the reader and the
 writer to update and observe the values of mFront and mNextRdPTS in an
 atomic lock-less fashion.

 :: Important ::
 Two assumptions must be true in order for this lock-less approach to
 function properly on all systems.  First, there may only be one updater
 thread in the system.  Second, the updater thread must be running at a
 strictly higher priority than the observer threads.  Currently, both of
 these assumptions are true.  The only updater is always a single
 FastMixer thread (which runs with SCHED_FIFO/RT priority while the only
 observer is always an AudioFlinger::PlaybackThread running with
 traditional (non-RT) audio priority."
      end

      operation 334348 "observeFrontAndNRPTS"
	preserve_cpp_body_indent private explicit_return_type "void"
	nparams 2
	  param inout name "outFront" explicit_type "int32_t"
	  param inout name "outNextRdPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      attribute 242700 "mUpdateSeq"
	volatile private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 242828 "mReqFrames"
	const_attribute private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " as requested in constructor, unrounded"
      end

      attribute 242956 "mMaxFrames"
	const_attribute private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " always a power of 2"
      end

      attribute 243084 "mBuffer"
	private explicit_type "void"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 243212 "mFront"
	volatile private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " written by the reader with updateFrontAndNRPTS, observed by"
      end

      attribute 243340 "mRear"
	volatile private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " written by writer with android_atomic_release_store,"
      end

      attribute 243468 "mNextRdPTS"
	volatile private explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " written by the reader with updateFrontAndNRPTS, observed by"
      end

      attribute 243596 "mWriteTsValid"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " whether mWriteTs is valid"
      end

      attribute 243724 "mWriteTs"
	private explicit_type "timespec"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}struct ${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " time that the previous write() completed"
      end

      attribute 243852 "mSetpoint"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " target value for pipe fill depth"
      end

      attribute 243980 "mWriteCanBlock"
	const_attribute private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " whether write() should block if the pipe is full"
      end

      operation 334476 "offsetTimestampByAudioFrames"
	preserve_cpp_body_indent private explicit_return_type "int64_t"
	nparams 2
	  param in name "ts" explicit_type "int64_t"
	  param in name "audFrames" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      classrelation 178828 // mSamplesToLocalTime (<directional composition>)
	relation 178828 *-->
	  a role_name "mSamplesToLocalTime" private
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 178828 // mSamplesToLocalTime (<directional composition>)
	  b parent class_ref 151692 // LinearTransform
      end

      attribute 244108 "mIsShutdown"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " whether shutdown(true) was called, no barriers are needed"
      end
    end

    class 172300 "MonoPipeReader"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " MonoPipeReader is safe for only a single reader thread"
      classrelation 178956 // <generalisation>
	relation 178956 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 178956 // <generalisation>
	  b parent class_ref 171148 // NBAIO_Source
      end

      operation 334604 "MonoPipeReader"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "pipe" type class_ref 172172 // MonoPipe
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)} :
        NBAIO_Source(pipe->mFormat),
        mPipe(pipe)
${throw}{
  ${body}}
"
	
	
	
	
	comment " Construct a MonoPipeReader and associate it with a MonoPipe;
 any data already in the pipe is visible to this PipeReader.
 There can be only a single MonoPipeReader per MonoPipe.
 FIXME make this constructor a factory method of MonoPipe."
      end

      operation 334732 "~MonoPipeReader"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 334860 "availableToRead"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Source interface
virtual size_t framesRead() const;
virtual size_t framesOverrun();
virtual size_t overruns();"
      end

      operation 334988 "read"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 3
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	  param in name "readPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 335116 "pipe"
	const cpp_inline public return_type class_ref 172172 // MonoPipe
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mPipe; };
"
	
	
	
	
      end

      attribute 244236 "mPipe"
	private type class_ref 172172 // MonoPipe
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 172556 "writeVia_t"
      visibility package stereotype "typedef" explicit_base_type "ssize_t"
      cpp_decl "${comment}typedef ${type}(* ${name})(void *user, void *buffer, size_t count);
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Callbacks used by NBAIO_Sink::writeVia() and NBAIO_Source::readVia() below."
    end

    class 172684 "NBAIO_Port"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Abstract class (interface) representing a data port."
      classrelation 179084 // <generalisation>
	relation 179084 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 179084 // <generalisation>
	  b parent class_ref 140044 // RefBase
      end

      operation 335244 "negotiate"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 4
	  param in name "offers" type class_ref 171276 // NBAIO_Format
	  param in name "numOffers" explicit_type "size_t"
	  param in name "counterOffers" type class_ref 171276 // NBAIO_Format
	  param inout name "numCounterOffers" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}[]${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}[]${v2}, ${t3} & ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "// Default implementation that only accepts my mFormat

${inline}${type} ${class}::${name}${(}const ${t0} ${p0}[], ${t1} ${p1}, ${t2} ${p2}[], ${t3} & ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " negotiate() must called first.  The purpose of negotiate() is to check compatibility of
 formats, not to automatically adapt if they are incompatible.  It's the responsibility of
 whoever sets up the graph connections to make sure formats are compatible, and this method
 just verifies that.  The edges are \"dumb\" and don't attempt to adapt to bad connections.
 How it works: offerer proposes an array of formats, in descending order of preference from
 offers[0] to offers[numOffers - 1].  If offeree accepts one of these formats, it returns
 the index of that offer.  Otherwise, offeree sets numCounterOffers to the number of
 counter-offers (up to a maximumum of the entry value of numCounterOffers), fills in the
 provided array counterOffers[] with its counter-offers, in descending order of preference
 from counterOffers[0] to counterOffers[numCounterOffers - 1], and returns NEGOTIATE.
 Note that since the offerer allocates space for counter-offers, but only the offeree knows
 how many counter-offers it has, there may be insufficient space for all counter-offers.
 In that case, the offeree sets numCounterOffers to the requested number of counter-offers
 (which is greater than the entry value of numCounterOffers), fills in as many of the most
 important counterOffers as will fit, and returns NEGOTIATE.  As this implies a re-allocation,
 it should be used as a last resort.  It is preferable for the offerer to simply allocate a
 larger space to begin with, and/or for the offeree to tolerate a smaller space than desired.
 Alternatively, the offerer can pass NULL for offers and counterOffers, and zero for
 numOffers. This indicates that it has not allocated space for any counter-offers yet.
 In this case, the offerree should set numCounterOffers appropriately and return NEGOTIATE.
 Then the offerer will allocate the correct amount of memory and retry.
 Format_Invalid is not allowed as either an offer or counter-offer.
 Returns:
  >= 0        Offer accepted.
  NEGOTIATE   No offer accepted, and counter-offer(s) optionally made. See above for details."
      end

      operation 335372 "format"
	const cpp_virtual cpp_inline public return_type class_ref 171276 // NBAIO_Format
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mNegotiated ? mFormat : Format_Invalid; };
"
	
	
	
	
	comment " Return the current negotiated format, or Format_Invalid if negotiation has not been done,
 or if re-negotiation is required."
      end

      operation 335500 "NBAIO_Port"
	cpp_inline protected explicit_return_type ""
	nparams 1
	  param in name "format" type class_ref 171276 // NBAIO_Format
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw} : mNegotiated(false), mFormat(format),
                                      mBitShift(Format_frameBitShift(format)) { };
"
	
	
	
	
      end

      operation 335628 "~NBAIO_Port"
	cpp_virtual cpp_inline protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      attribute 245388 "mNegotiated"
	protected explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " mNegotiated implies (mFormat != Format_Invalid)"
      end

      classrelation 179212 // mFormat (<directional composition>)
	relation 179212 *-->
	  a role_name "mFormat" protected
	    comment " (mFormat != Format_Invalid) does not imply mNegotiated"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 179212 // mFormat (<directional composition>)
	  b parent class_ref 171276 // NBAIO_Format
      end

      attribute 245516 "mBitShift"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " assign in parallel with any assignment to mFormat"
      end
    end

    class 172812 "Pipe"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Pipe is multi-thread safe for readers (see PipeReader), but safe for only a single writer thread.
 It cannot UNDERRUN on write, unless we allow designation of a master reader that provides the
 time-base. Readers can be added and removed dynamically, and it's OK to have no readers."
      classrelation 179596 // <generalisation>
	relation 179596 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 179596 // <generalisation>
	  b parent class_ref 171788 // NBAIO_Sink
      end

      classrelation 179724 // <dependency>
	relation 179724 -_->
	  stereotype "friend"
	  a default
	    cpp default "Generated"
	    classrelation_ref 179724 // <dependency>
	  b parent class_ref 172940 // PipeReader
      end

      operation 337932 "Pipe"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 2
	  param in name "maxFrames" explicit_type "size_t"
	  param in name "format" type class_ref 171276 // NBAIO_Format
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)} :
        NBAIO_Sink(format),
        mMaxFrames(roundup(maxFrames)),
        mBuffer(malloc(mMaxFrames * Format_frameSize(format))),
        mRear(0),
        mReaders(0)
${throw}{
  ${body}}
"
	
	
	
	
	comment " maxFrames will be rounded up to a power of 2, and all slots are available. Must be >= 2."
      end

      operation 338060 "~Pipe"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 338188 "availableToWrite"
	const cpp_virtual cpp_inline public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mMaxFrames; };
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Sink interface
virtual size_t framesWritten() const;
virtual size_t framesUnderrun() const;
virtual size_t underruns() const;
 The write side of a pipe permits overruns; flow control is the caller's responsibility.
 It doesn't return +infinity because that would guarantee an overrun."
      end

      operation 338316 "write"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 2
	  param in name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      attribute 245900 "mMaxFrames"
	const_attribute private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " always a power of 2"
      end

      attribute 246028 "mBuffer"
	private explicit_type "void"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * const ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 246156 "mRear"
	volatile private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " written by android_atomic_release_store"
      end

      attribute 246284 "mReaders"
	volatile private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " number of PipeReader clients currently attached to this Pipe"
      end
    end

    class 172940 "PipeReader"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " PipeReader is safe for only a single thread"
      classrelation 179852 // <generalisation>
	relation 179852 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 179852 // <generalisation>
	  b parent class_ref 171148 // NBAIO_Source
      end

      operation 338444 "PipeReader"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "pipe" type class_ref 172812 // Pipe
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} & ${p0}${)} :
        NBAIO_Source(pipe.mFormat),
        mPipe(pipe),
        // any data already in the pipe is not visible to this PipeReader
        mFront(android_atomic_acquire_load(&pipe.mRear)),
        mFramesOverrun(0),
        mOverruns(0)
${throw}{
  ${body}}
"
	
	
	
	
	comment " Construct a PipeReader and associate it with a Pipe
 FIXME make this constructor a factory method of Pipe."
      end

      operation 338572 "~PipeReader"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 338700 "framesOverrun"
	cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mFramesOverrun; };
"
	
	
	
	
	comment " NBAIO_Port interface
virtual ssize_t negotiate(const NBAIO_Format offers[], size_t numOffers,
                          NBAIO_Format counterOffers[], size_t& numCounterOffers);
virtual NBAIO_Format format() const;
 NBAIO_Source interface
virtual size_t framesRead() const;"
      end

      operation 338828 "overruns"
	cpp_virtual cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mOverruns; };
"
	
	
	
	
      end

      operation 338956 "availableToRead"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 339084 "read"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "ssize_t"
	nparams 3
	  param inout name "buffer" explicit_type "void"
	  param in name "count" explicit_type "size_t"
	  param in name "readPTS" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 339212 "pipe"
	const cpp_inline public return_type class_ref 172812 // Pipe
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mPipe; };
"
	
	
	
	
      end

      classrelation 179980 // mPipe (<unidirectional association>)
	relation 179980 --->
	  a role_name "mPipe" private
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} & ${name}${value};
"
	    classrelation_ref 179980 // mPipe (<unidirectional association>)
	  b parent class_ref 172812 // Pipe
      end

      attribute 246412 "mFront"
	private explicit_type "int32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " follows behind mPipe.mRear"
      end

      attribute 246540 "mFramesOverrun"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 246668 "mOverruns"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 173068 "SourceAudioBufferProvider"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 180108 // <generalisation>
	relation 180108 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 180108 // <generalisation>
	  b parent class_ref 150540 // ExtendedAudioBufferProvider
      end

      operation 339340 "SourceAudioBufferProvider"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "source" explicit_type "sp<NBAIO_Source>"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)} :
    mSource(source),
    // mFrameBitShiftFormat below
    mAllocated(NULL), mSize(0), mOffset(0), mRemaining(0), mGetCount(0)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 339468 "~SourceAudioBufferProvider"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 339596 "getNextBuffer"
	preserve_cpp_body_indent cpp_virtual public return_type class_ref 128268 // status_t
	nparams 2
	  param inout name "buffer" type class_ref 173196 // Buffer
	  param in name "pts" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " AudioBufferProvider interface"
      end

      operation 339724 "releaseBuffer"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "buffer" type class_ref 173196 // Buffer
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 339852 "framesReady"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " ExtendedAudioBufferProvider interface"
      end

      classrelation 180236 // mSource (<directional composition>)
	relation 180236 *-->
	  stereotype "sp"
	  a role_name "mSource" const_relation private
	    comment " the wrapped source"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 180236 // mSource (<directional composition>)
	  b parent class_ref 171148 // NBAIO_Source
      end

      attribute 246796 "mFrameBitShift"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " log2(frame size in bytes)"
      end

      attribute 246924 "mAllocated"
	private explicit_type "void"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " pointer to base of allocated memory"
      end

      attribute 247052 "mSize"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " size of mAllocated in frames"
      end

      attribute 247180 "mOffset"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " frame offset within mAllocated of valid data"
      end

      attribute 247308 "mRemaining"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " frame count within mAllocated of valid data"
      end

      attribute 247436 "mGetCount"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " buffer.frameCount of the most recent getNextBuffer"
      end
    end
  end

  deploymentview 129804 "nbaio"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 138636 "AudioBufferProviderSource"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171020 // AudioBufferProviderSource
      end
    end

    artifact 138764 "AudioStreamInSource"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171532 // AudioStreamInSource
      end
    end

    artifact 138892 "AudioStreamOutSink"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171660 // AudioStreamOutSink
      end
    end

    artifact 139020 "LibsndfileSink"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171916 // LibsndfileSink
      end
    end

    artifact 139148 "LibsndfileSource"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172044 // LibsndfileSource
      end
    end

    artifact 139276 "MonoPipe"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172172 // MonoPipe
      end
    end

    artifact 139404 "MonoPipeReader"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172300 // MonoPipeReader
      end
    end

    artifact 139660 "NBAIO"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171276 // NBAIO_Format
	class_ref 172556 // writeVia_t
	class_ref 171404 // readVia_t
	class_ref 172684 // NBAIO_Port
	class_ref 171788 // NBAIO_Sink
	class_ref 171148 // NBAIO_Source
      end
    end

    artifact 139788 "Pipe"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172812 // Pipe
      end
    end

    artifact 139916 "PipeReader"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172940 // PipeReader
      end
    end

    artifact 140044 "SourceAudioBufferProvider"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 173068 // SourceAudioBufferProvider
      end
    end
  end

  package_ref 134668 // nbaio
end
