class CameraHardwareSec
!!!11078156.cpp!!!	setCallbacks(in notify_cb : camera_notify_callback, in data_cb : camera_data_callback, in data_cb_timestamp : camera_data_timestamp_callback, in get_memory : camera_request_memory, inout user : void) : void
    mNotifyCb = notify_cb;
    mDataCb = data_cb;
    mDataCbTimestamp = data_cb_timestamp;
    mGetMemoryCb = get_memory;
    mCallbackCookie = user;
!!!11078284.cpp!!!	enableMsgType(in msgType : int32_t) : void
    LOGV("%s : msgType = 0x%x, mMsgEnabled before = 0x%x",
         __func__, msgType, mMsgEnabled);
    mPreviewLock.lock();
    mMsgEnabled |= msgType;
    mPreviewLock.unlock();
    LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);
!!!11078412.cpp!!!	disableMsgType(in msgType : int32_t) : void
    LOGV("%s : msgType = 0x%x, mMsgEnabled before = 0x%x",
         __func__, msgType, mMsgEnabled);
    mPreviewLock.unlock();
    mMsgEnabled &= ~msgType;
    mPreviewLock.unlock();
    LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);
!!!11078540.cpp!!!	msgTypeEnabled(in msgType : int32_t) : bool
    return (mMsgEnabled & msgType);
!!!11078668.cpp!!!	startPreview() : status_t
    int ret = 0;        //s1 [Apply factory standard]

    LOGV("%s :", __func__);

    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }

    mPreviewLock.lock();

    if (mPreviewRunning) {
        // already running
        LOGE("%s : preview thread already running", __func__);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    mPreviewRunning = true;
    mPreviewStartDeferred = false;

    if (!mPreviewWindow) {
        LOGI("%s : deferring", __func__);
        mPreviewStartDeferred = true;
        mPreviewLock.unlock();
        return NO_ERROR;
    }

    ret = startPreviewInternal();

    if (ret == OK)
        mPreviewCondition.signal();

    mPreviewLock.unlock();
    return ret;
!!!11078796.cpp!!!	stopPreview() : void
    LOGV("%s :", __func__);

    /* request that the preview thread stop. */
    mPreviewLock.lock();
    stopPreviewInternal();
    mPreviewLock.unlock();
!!!11078924.cpp!!!	previewEnabled() : bool
    Mutex::Autolock lock(mPreviewLock);
    LOGV("%s : %d", __func__, mPreviewRunning);
    return mPreviewRunning;
!!!11079052.cpp!!!	startRecording() : status_t
    LOGV("%s :", __func__);

    Mutex::Autolock lock(mRecordLock);

    if (mRecordHeap) {
        mRecordHeap->release(mRecordHeap);
        mRecordHeap = 0;
    }

    if (mRecordRunning == false) {
        if (mSecCamera->startRecord() < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->startRecord()", __func__);
            return UNKNOWN_ERROR;
        }

        mRecordRunning = true;
    }

    int width, height, frame_size;
    mSecCamera->getRecordingSize(&width, &height);
    const char * video_format = mParameters.get(CameraParameters::KEY_VIDEO_FRAME_FORMAT);

    if(!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
        frame_size = (width * height * 3) >> 1;
    } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        frame_size = (width * height * 3) >> 1;
    } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
        frame_size = (width * height) << 1;
    } else {
        LOGE("Only Support NV21, YV12 YUV422I formats");
        return UNKNOWN_ERROR;
    }

    mRecordHeap = mGetMemoryCb(-1, frame_size + sizeof(struct addrs), MAX_VIDEO_BUFFERS, NULL);

    if (!mRecordHeap) {
        LOGE("ERR(%s): Record heap creation fail", __func__);
        return UNKNOWN_ERROR;
    }

    return NO_ERROR;
!!!11079180.cpp!!!	stopRecording() : void
    LOGV("%s :", __func__);

    Mutex::Autolock lock(mRecordLock);

    if (mRecordRunning == true) {
        if (mSecCamera->stopRecord() < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->stopRecord()", __func__);
            return;
        }

        mRecordRunning = false;
    }
!!!11079308.cpp!!!	recordingEnabled() : bool
    LOGV("%s :", __func__);

    return mRecordRunning;
!!!11079436.cpp!!!	releaseRecordingFrame(in opaque : void) : void
    int width, height, frame_size;
    mSecCamera->getRecordingSize(&width, &height);
    const char * video_format = mParameters.get(CameraParameters::KEY_VIDEO_FRAME_FORMAT);

    if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
        frame_size = (width * height * 3) >> 1;
    } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        frame_size = (width * height * 3) >> 1;
    } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
        frame_size = (width * height) << 1;
    } else {
        LOGE("Only Support NV21, YV12 YUV422I formats");
        return;
    }

    struct addrs *addrs = (struct addrs *)((char*)opaque + frame_size);

    mSecCamera->releaseRecordFrame(addrs->buf_index);
!!!11079564.cpp!!!	autoFocus() : status_t
    LOGV("%s :", __func__);
    /* signal autoFocusThread to run once */
    mFocusCondition.signal();
    return NO_ERROR;
!!!11079692.cpp!!!	cancelAutoFocus() : status_t
    LOGV("%s :", __func__);

    // cancelAutoFocus should be allowed after preview is started. But if
    // the preview is deferred, cancelAutoFocus will fail. Ignore it if that is
    // the case.
    if (mPreviewRunning && mPreviewStartDeferred) return NO_ERROR;

    if (mSecCamera->cancelAutofocus() < 0) {
        LOGE("ERR(%s):Fail on mSecCamera->cancelAutofocus()", __func__);
        return UNKNOWN_ERROR;
    }

    return NO_ERROR;
!!!11079820.cpp!!!	takePicture() : status_t
    LOGW("%s :", __func__);
    mCaptureLock.lock();

    if(mCaptureInProgress) {
        LOGE("####The previous take picture have not finished. Return Invalid operation");
        return INVALID_OPERATION;
    }

    mCaptureLock.unlock();

    int mPostViewWidth, mPostViewHeight, mPostViewSize;
    mSecCamera->getSnapshotSize(&mPostViewWidth, &mPostViewHeight, &mPostViewSize);
    stopPreview();

    if (!mRawHeap) {
        int rawHeapSize = mPostViewSize;
        LOGV("mRawHeap : MemoryHeapBase(previewHeapSize(%d))", rawHeapSize);
        mRawHeap = mGetMemoryCb(-1, rawHeapSize, 1, 0);

        if (!mRawHeap) {
            LOGE("ERR(%s): Raw heap creation fail", __func__);
        }
    }

    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }

    if (mPictureThread->run("CameraPictureThread", PRIORITY_DEFAULT) != NO_ERROR) {
        LOGE("%s : couldn't run picture thread", __func__);
        return INVALID_OPERATION;
    }

    mCaptureLock.lock();
    mCaptureInProgress = true;
    mCaptureLock.unlock();

    return NO_ERROR;
!!!11079948.cpp!!!	takePictureWrapper() : status_t
    if (mPictureWrapperThread->run("CameraPictureWrapperThread", PRIORITY_DEFAULT) != NO_ERROR) {
        LOGE("%s : couldn't run picture thread", __func__);
        return INVALID_OPERATION;
    }

    return NO_ERROR;
!!!11080076.cpp!!!	cancelPicture() : status_t
    LOGV("%s", __func__);

    if (mPictureThread.get()) {
        LOGV("%s: waiting for picture thread to exit", __func__);
        mPictureThread->requestExitAndWait();
        LOGV("%s: picture thread has exited", __func__);
    }

    return NO_ERROR;
!!!11080204.cpp!!!	dump(in fd : int) : status_t
    const size_t SIZE = 256;
    char buffer[SIZE];
    String8 result;
    const Vector<String16> args;

    if (mSecCamera != 0) {
        mSecCamera->dump(fd);
        mParameters.dump(fd, args);
        mInternalParameters.dump(fd, args);
        snprintf(buffer, 255, " preview running(%s)\n", mPreviewRunning ? "true" : "false");
        result.append(buffer);
    } else {
        result.append("No camera client yet.\n");
    }

    write(fd, result.string(), result.size());
    return NO_ERROR;
!!!11080332.cpp!!!	setParameters(in params : CameraParameters) : status_t
    LOGV("%s :", __func__);

    status_t ret = NO_ERROR;

    if(!mSecCamera->isCameraInit()) {
        return UNKNOWN_ERROR;
    }

    /* if someone calls us while picture thread is running, it could screw
     * up the sensor quite a bit so return error.
     */
    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }

    // preview size
    int new_preview_width  = 0;
    int new_preview_height = 0;
    int new_preview_format = V4L2_PIX_FMT_YUYV;
    params.getPreviewSize(&new_preview_width, &new_preview_height);
    const char *new_str_preview_format = params.getPreviewFormat();
    LOGI("%s : new_preview_width x new_preview_height = %dx%d, format = %s",
         __func__, new_preview_width, new_preview_height, new_str_preview_format);


    if (new_str_preview_format != NULL) {
        if (!strcmp(new_str_preview_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
            new_preview_format = V4L2_PIX_FMT_YUYV;
        } else if(!strcmp(new_str_preview_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
            new_preview_format = V4L2_PIX_FMT_NV21;
        } else if (!strcmp(new_str_preview_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
            new_preview_format = V4L2_PIX_FMT_YVU420;
        } else {
            LOGE("Unsupported preview color format: %s", new_str_preview_format);
            return BAD_VALUE;
        }
    } else {
        new_preview_format = V4L2_PIX_FMT_YUYV;
    }

    if (0 < new_preview_width && 0 < new_preview_height &&
        new_str_preview_format != NULL &&
        isSupportedPreviewSize(new_preview_width, new_preview_height)) {
        int current_preview_width, current_preview_height, current_frame_size;
        mSecCamera->getPreviewSize(&current_preview_width,
                                   &current_preview_height,
                                   &current_frame_size);
        int current_pixel_format = mSecCamera->getPreviewPixelFormat();

        if (current_preview_width != new_preview_width ||
            current_preview_height != new_preview_height ||
            current_pixel_format != new_preview_format) {
            int preview_state = mSecCamera->setPreviewSize(new_preview_width,
                                new_preview_height,
                                new_preview_format);

            if ( preview_state < 0) {
                LOGE("ERR(%s):Fail on setPreviewSize(width(%d), height(%d), format(%d))",
                     __func__, new_preview_width, new_preview_height, new_preview_format);
                ret = UNKNOWN_ERROR;
            } else {
                if (mPreviewWindow) {
                    if (mPreviewRunning && !mPreviewStartDeferred) {
                        LOGE("ERR(%s): preview is running, cannot change size and format!",
                             __func__);
                        ret = INVALID_OPERATION;
                    }

                    LOGV("%s: mPreviewWindow (%p) set_buffers_geometry",
                         __func__, mPreviewWindow);
                    LOGV("%s: mPreviewWindow->set_buffers_geometry (%p)",
                         __func__, mPreviewWindow->set_buffers_geometry);
                    mPreviewWindow->set_buffers_geometry(mPreviewWindow,
                                                         new_preview_width, new_preview_height,
                                                         HAL_PIXEL_FORMAT_YCbCr_422_I);
                    LOGV("%s: DONE mPreviewWindow (%p) set_buffers_geometry",
                         __func__, mPreviewWindow);
                }

                mParameters.setPreviewSize(new_preview_width, new_preview_height);
                mParameters.setPreviewFormat(new_str_preview_format);
            }
        } else LOGV("%s: preview size and format has not changed", __func__);
    } else {
        LOGE("%s: Invalid preview size(%dx%d)",
             __func__, new_preview_width, new_preview_height);

        ret = INVALID_OPERATION;
    }

    int new_picture_width  = 0;
    int new_picture_height = 0;

    params.getPictureSize(&new_picture_width, &new_picture_height);
    LOGI("%s : new_picture_width x new_picture_height = %dx%d",
         __func__, new_picture_width, new_picture_height);

    if (0 < new_picture_width && 0 < new_picture_height) {
        LOGV("%s: setSnapshotSize", __func__);

        if (mSecCamera->setSnapshotSize(new_picture_width, new_picture_height) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setSnapshotSize(width(%d), height(%d))",
                 __func__, new_picture_width, new_picture_height);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.setPictureSize(new_picture_width, new_picture_height);
        }
    }

    // picture format
    const char *new_str_picture_format = params.getPictureFormat();
    LOGV("%s : new_str_picture_format %s", __func__, new_str_picture_format);

    if (new_str_picture_format != NULL) {
        int new_picture_format = 0;

        if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_RGB565))
            new_picture_format = V4L2_PIX_FMT_RGB565;
        else if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_RGBA8888))
            new_picture_format = V4L2_PIX_FMT_RGB32;
        else if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_YUV420SP))
            new_picture_format = V4L2_PIX_FMT_NV21;
        else if (!strcmp(new_str_picture_format, "yuv420sp_custom"))
            new_picture_format = V4L2_PIX_FMT_NV12T;
        else if (!strcmp(new_str_picture_format, "yuv420p"))
            new_picture_format = V4L2_PIX_FMT_YUV420;
        else if (!strcmp(new_str_picture_format, "yuv422i"))
            new_picture_format = V4L2_PIX_FMT_YUYV;
        else if (!strcmp(new_str_picture_format, "uyv422i_custom")) //Zero copy UYVY format
            new_picture_format = V4L2_PIX_FMT_UYVY;
        else if (!strcmp(new_str_picture_format, "uyv422i")) //Non-zero copy UYVY format
            new_picture_format = V4L2_PIX_FMT_UYVY;
        else if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_JPEG))
            new_picture_format = V4L2_PIX_FMT_YUYV;
        else if (!strcmp(new_str_picture_format, "yuv422p"))
            new_picture_format = V4L2_PIX_FMT_YUV422P;
        else
            new_picture_format = V4L2_PIX_FMT_YUYV; //for 3rd party

        if (mSecCamera->setSnapshotPixelFormat(new_picture_format) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setSnapshotPixelFormat(format(%d))",
                 __func__, new_picture_format);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.setPictureFormat(new_str_picture_format);
        }
    }

    //JPEG image quality
    int new_jpeg_quality = params.getInt(CameraParameters::KEY_JPEG_QUALITY);
    LOGV("%s : new_jpeg_quality %d", __func__, new_jpeg_quality);

    /* we ignore bad values */
    if (new_jpeg_quality >= 1 && new_jpeg_quality <= 100) {
        if (mSecCamera->setJpegQuality(new_jpeg_quality) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setJpegQuality(quality(%d))",
                 __func__, new_jpeg_quality);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_JPEG_QUALITY, new_jpeg_quality);
        }
    }

    // JPEG thumbnail size
    int new_jpeg_thumbnail_width = params.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
    int new_jpeg_thumbnail_height = params.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);

    if (0 <= new_jpeg_thumbnail_width && 0 <= new_jpeg_thumbnail_height) {
        int state = mSecCamera->setJpegThumbnailSize(new_jpeg_thumbnail_width,
                    new_jpeg_thumbnail_height);

        if ( state < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setJpegThumbnailSize(width(%d), height(%d))",
                 __func__, new_jpeg_thumbnail_width, new_jpeg_thumbnail_height);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH,
                            new_jpeg_thumbnail_width);
            mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT,
                            new_jpeg_thumbnail_height);
        }
    }

    //check paremeter for zoom
    int zoomRate = params.getInt(CameraParameters::KEY_ZOOM);

    if(zoomRate > 0) {
        ret = UNKNOWN_ERROR;
    }

    // frame rate
    int new_frame_rate = params.getPreviewFrameRate();
    char support_frame_rate[4];
    sprintf(support_frame_rate, "%d", new_frame_rate);
    int cmp_state = !strstr(mParameters.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES),
                            support_frame_rate);

                    /* ignore any fps request, we're determine fps automatically based
                     * on scene mode.  don't return an error because it causes CTS failure.
                     */
    if ( cmp_state ) {
        LOGE("ERR(%s):Fail on set FPS. Support=%s, Set FPS = %d",
             __func__,
             mParameters.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES),
             new_frame_rate);
        ret = UNKNOWN_ERROR;
    } else {
        mParameters.setPreviewFrameRate(new_frame_rate);
    }

    // rotation
    int new_rotation = params.getInt(CameraParameters::KEY_ROTATION);
    LOGV("%s : new_rotation %d", __func__, new_rotation);

    if (0 <= new_rotation) {
        LOGV("%s : set orientation:%d\n", __func__, new_rotation);

        if (mSecCamera->setExifOrientationInfo(new_rotation) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setExifOrientationInfo(%d)",
                 __func__, new_rotation);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_ROTATION, new_rotation);
        }
    }

    // exposure
    int new_exposure_compensation = params.getInt(CameraParameters::KEY_EXPOSURE_COMPENSATION);
    int max_exposure_compensation = params.getInt(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION);
    int min_exposure_compensation = params.getInt(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION);
    LOGV("%s : new_exposure_compensation %d", __func__, new_exposure_compensation);

    if ((min_exposure_compensation <= new_exposure_compensation) &&
        (max_exposure_compensation >= new_exposure_compensation)) {
        if (mSecCamera->setBrightness(new_exposure_compensation) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setBrightness(brightness(%d))",
                 __func__, new_exposure_compensation);
            //ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, new_exposure_compensation);
        }
    }

    // whitebalance
    const char *new_white_str = params.get(CameraParameters::KEY_WHITE_BALANCE);
    LOGI("%s : new_white_str %s", __func__, new_white_str ? new_white_str : "NULL");

    if (new_white_str != NULL) {
        if (!strcmp(new_white_str, CameraParameters::WHITE_BALANCE_AUTO)) {
            if (mSecCamera->setWhiteBalance() < 0) {
                LOGE("ERR(%s):Fail on mSecCamera->setWhiteBalance(auto-balance)", __func__);
                ret = UNKNOWN_ERROR;
            } else {
                mParameters.set(CameraParameters::KEY_WHITE_BALANCE, new_white_str);
            }
        } else {
            //twilight, shade, warm_flourescent
            LOGE("ERR(%s):Invalid white balance(%s)", __func__, new_white_str);
            ret = UNKNOWN_ERROR;
        }
    }

    // scene mode
    const char *new_scene_mode_str = params.get(CameraParameters::KEY_SCENE_MODE);
    const char *current_scene_mode_str = mParameters.get(CameraParameters::KEY_SCENE_MODE);

    // fps range
    int new_min_fps = 0;
    int new_max_fps = 0;
    int current_min_fps, current_max_fps;
    params.getPreviewFpsRange(&new_min_fps, &new_max_fps);

    if ((new_min_fps < 0) ||
        (new_max_fps < 0) ||
        (new_min_fps > new_max_fps) ) {
        ret = UNKNOWN_ERROR;
    }

    const char *new_focus_mode_str = params.get(CameraParameters::KEY_FOCUS_MODE);

    if (mSecCamera->getCameraId() == SecCamera::CAMERA_ID_BACK) {
        int  new_scene_mode = -1;

        const char *new_flash_mode_str = params.get(CameraParameters::KEY_FLASH_MODE);

        // fps range is (10000,25000) by default.
        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(10000,25000)");
        mParameters.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "10000,25000");

        // focus mode
        if (new_focus_mode_str != NULL) {
            int  new_focus_mode = -1;

            if (!strcmp(new_focus_mode_str,
                        CameraParameters::FOCUS_MODE_AUTO)) {
                new_focus_mode = FOCUS_MODE_AUTO;
                mParameters.set(CameraParameters::KEY_FOCUS_DISTANCES,
                                BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR);
            } else if (!strcmp(new_focus_mode_str,
                               CameraParameters::FOCUS_MODE_MACRO)) {
                new_focus_mode = FOCUS_MODE_MACRO;
                mParameters.set(CameraParameters::KEY_FOCUS_DISTANCES,
                                BACK_CAMERA_MACRO_FOCUS_DISTANCES_STR);
            } else if (!strcmp(new_focus_mode_str,
                               CameraParameters::FOCUS_MODE_INFINITY)) {
                new_focus_mode = FOCUS_MODE_INFINITY;
                mParameters.set(CameraParameters::KEY_FOCUS_DISTANCES,
                                BACK_CAMERA_INFINITY_FOCUS_DISTANCES_STR);
            } else {
                LOGE("%s::unmatched focus_mode(%s)", __func__, new_focus_mode_str);
                ret = UNKNOWN_ERROR;
            }

            if (0 <= new_focus_mode) {
                if (mSecCamera->setFocusMode(new_focus_mode) < 0) {
                    LOGE("%s::mSecCamera->setFocusMode(%d) fail", __func__, new_focus_mode);
                    ret = UNKNOWN_ERROR;
                } else {
                    mParameters.set(CameraParameters::KEY_FOCUS_MODE, new_focus_mode_str);
                }
            }
        }

        // flash..
        if (new_flash_mode_str != NULL) {
            int  new_flash_mode = -1;

            if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_OFF))
                new_flash_mode = FLASH_MODE_OFF;
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_AUTO))
                new_flash_mode = FLASH_MODE_AUTO;
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_ON))
                new_flash_mode = FLASH_MODE_ON;
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_TORCH))
                new_flash_mode = FLASH_MODE_TORCH;
            else {
                LOGE("%s::unmatched flash_mode(%s)", __func__, new_flash_mode_str); //red-eye
                ret = UNKNOWN_ERROR;
            }

            if (0 <= new_flash_mode) {
                if (mSecCamera->setFlashMode(new_flash_mode) < 0) {
                    LOGE("%s::mSecCamera->setFlashMode(%d) fail", __func__, new_flash_mode);
                    ret = UNKNOWN_ERROR;
                } else {
                    mParameters.set(CameraParameters::KEY_FLASH_MODE, new_flash_mode_str);
                }
            }
        }

        //  scene..
        if (0 <= new_scene_mode) {
            if (mSecCamera->setSceneMode(new_scene_mode) < 0) {
                LOGE("%s::mSecCamera->setSceneMode(%d) fail", __func__, new_scene_mode);
                ret = UNKNOWN_ERROR;
            } else {
                mParameters.set(CameraParameters::KEY_SCENE_MODE, new_scene_mode_str);
            }
        }
    } else {
        if (!isSupportedParameter(new_focus_mode_str,
                                  mParameters.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES))) {
            LOGE("%s: Unsupported focus mode: %s", __func__, new_focus_mode_str);
            ret = UNKNOWN_ERROR;
        }
    }

    // ---------------------------------------------------------------------------

    // image effect
    const char *new_image_effect_str = params.get(CameraParameters::KEY_EFFECT);
    /* if (new_image_effect_str != NULL) {

         int  new_image_effect = -1;

         if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NONE))
             new_image_effect = IMAGE_EFFECT_NONE;
         else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_MONO))
             new_image_effect = IMAGE_EFFECT_BNW;
         else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_SEPIA))
             new_image_effect = IMAGE_EFFECT_SEPIA;
         else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_AQUA))
             new_image_effect = IMAGE_EFFECT_AQUA;
         else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NEGATIVE))
             new_image_effect = IMAGE_EFFECT_NEGATIVE;
         else {
             //posterize, whiteboard, blackboard, solarize
             LOGE("ERR(%s):Invalid effect(%s)", __func__, new_image_effect_str);
             ret = UNKNOWN_ERROR;
         }

         if (new_image_effect >= 0) {
             if (mSecCamera->setImageEffect(new_image_effect) < 0) {
                 LOGE("ERR(%s):Fail on mSecCamera->setImageEffect(effect(%d))",
                 __func__, new_image_effect);
                 ret = UNKNOWN_ERROR;
             } else {
                 const char *old_image_effect_str = mParameters.get(CameraParameters::KEY_EFFECT);

                 if (old_image_effect_str) {
                     if (strcmp(old_image_effect_str, new_image_effect_str)) {
                         setSkipFrame(EFFECT_SKIP_FRAME);
                     }
                 }

                 mParameters.set(CameraParameters::KEY_EFFECT, new_image_effect_str);
             }
         }
     }*/

    //vt mode
    int new_vtmode = mInternalParameters.getInt("vtmode");

    if (0 <= new_vtmode) {
        if (mSecCamera->setVTmode(new_vtmode) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setVTMode(%d)", __func__, new_vtmode);
            ret = UNKNOWN_ERROR;
        }
    }

    //contrast
    int new_contrast = mInternalParameters.getInt("contrast");

    if (0 <= new_contrast) {
        if (mSecCamera->setContrast(new_contrast) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setContrast(%d)", __func__, new_contrast);
            ret = UNKNOWN_ERROR;
        }
    }

    //WDR
    int new_wdr = mInternalParameters.getInt("wdr");

    if (0 <= new_wdr) {
        if (mSecCamera->setWDR(new_wdr) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setWDR(%d)", __func__, new_wdr);
            ret = UNKNOWN_ERROR;
        }
    }

    //anti shake
    int new_anti_shake = mInternalParameters.getInt("anti-shake");

    if (0 <= new_anti_shake) {
        if (mSecCamera->setAntiShake(new_anti_shake) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setWDR(%d)", __func__, new_anti_shake);
            ret = UNKNOWN_ERROR;
        }
    }

    // gps latitude
    const char *new_gps_latitude_str = params.get(CameraParameters::KEY_GPS_LATITUDE);

    if (mSecCamera->setGPSLatitude(new_gps_latitude_str) < 0) {
        LOGE("%s::mSecCamera->setGPSLatitude(%s) fail", __func__, new_gps_latitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_latitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_LATITUDE, new_gps_latitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_LATITUDE);
        }
    }

    // gps longitude
    const char *new_gps_longitude_str = params.get(CameraParameters::KEY_GPS_LONGITUDE);

    if (mSecCamera->setGPSLongitude(new_gps_longitude_str) < 0) {
        LOGE("%s::mSecCamera->setGPSLongitude(%s) fail", __func__, new_gps_longitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_longitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_LONGITUDE, new_gps_longitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_LONGITUDE);
        }
    }

    // gps altitude
    const char *new_gps_altitude_str = params.get(CameraParameters::KEY_GPS_ALTITUDE);

    if (mSecCamera->setGPSAltitude(new_gps_altitude_str) < 0) {
        LOGE("%s::mSecCamera->setGPSAltitude(%s) fail", __func__, new_gps_altitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_altitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_ALTITUDE, new_gps_altitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_ALTITUDE);
        }
    }

    // gps timestamp
    const char *new_gps_timestamp_str = params.get(CameraParameters::KEY_GPS_TIMESTAMP);

    if (mSecCamera->setGPSTimeStamp(new_gps_timestamp_str) < 0) {
        LOGE("%s::mSecCamera->setGPSTimeStamp(%s) fail", __func__, new_gps_timestamp_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_timestamp_str) {
            mParameters.set(CameraParameters::KEY_GPS_TIMESTAMP, new_gps_timestamp_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_TIMESTAMP);
        }
    }

    // gps processing method
    const char *new_gps_method_str = params.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);

    if (mSecCamera->setGPSProcessingMethod(new_gps_method_str) < 0) {
        LOGE("%s::mSecCamera->setGPSProcessingMethod(%s) fail", __func__, new_gps_method_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_method_str) {
            mParameters.set(CameraParameters::KEY_GPS_PROCESSING_METHOD, new_gps_method_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_PROCESSING_METHOD);
        }
    }

    // Recording size
    int new_recording_width = mInternalParameters.getInt("recording-size-width");
    int new_recording_height = mInternalParameters.getInt("recording-size-height");

    if (0 < new_recording_width && 0 < new_recording_height) {
        if (mSecCamera->setRecordingSize(new_recording_width, new_recording_height) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setRecordingSize(width(%d), height(%d))",
                 __func__, new_recording_width, new_recording_height);
            ret = UNKNOWN_ERROR;
        }
    } else {
        if (mSecCamera->setRecordingSize(new_preview_width, new_preview_height) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setRecordingSize(width(%d), height(%d))",
                 __func__, new_preview_width, new_preview_height);
            ret = UNKNOWN_ERROR;
        }
    }

    //gamma
    const char *new_gamma_str = mInternalParameters.get("video_recording_gamma");

    if (new_gamma_str != NULL) {
        int new_gamma = -1;

        if (!strcmp(new_gamma_str, "off"))
            new_gamma = GAMMA_OFF;
        else if (!strcmp(new_gamma_str, "on"))
            new_gamma = GAMMA_ON;
        else {
            LOGE("%s::unmatched gamma(%s)", __func__, new_gamma_str);
            ret = UNKNOWN_ERROR;
        }

        if (0 <= new_gamma) {
            if (mSecCamera->setGamma(new_gamma) < 0) {
                LOGE("%s::mSecCamera->setGamma(%d) fail", __func__, new_gamma);
                ret = UNKNOWN_ERROR;
            }
        }
    }

    //slow ae
    const char *new_slow_ae_str = mInternalParameters.get("slow_ae");

    if (new_slow_ae_str != NULL) {
        int new_slow_ae = -1;

        if (!strcmp(new_slow_ae_str, "off"))
            new_slow_ae = SLOW_AE_OFF;
        else if (!strcmp(new_slow_ae_str, "on"))
            new_slow_ae = SLOW_AE_ON;
        else {
            LOGE("%s::unmatched slow_ae(%s)", __func__, new_slow_ae_str);
            ret = UNKNOWN_ERROR;
        }

        if (0 <= new_slow_ae) {
            if (mSecCamera->setSlowAE(new_slow_ae) < 0) {
                LOGE("%s::mSecCamera->setSlowAE(%d) fail", __func__, new_slow_ae);
                ret = UNKNOWN_ERROR;
            }
        }
    }

    /*Camcorder fix fps*/
    int new_sensor_mode = mInternalParameters.getInt("cam_mode");

    if (0 <= new_sensor_mode) {
        if (mSecCamera->setSensorMode(new_sensor_mode) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setSensorMode(%d)", __func__, new_sensor_mode);
            ret = UNKNOWN_ERROR;
        }
    } else {
        new_sensor_mode = 0;
    }

    /*Shot mode*/
    int new_shot_mode = mInternalParameters.getInt("shot_mode");

    if (0 <= new_shot_mode) {
        if (mSecCamera->setShotMode(new_shot_mode) < 0) {
            LOGE("ERR(%s):Fail on mSecCamera->setShotMode(%d)", __func__, new_shot_mode);
            ret = UNKNOWN_ERROR;
        }
    } else {
        new_shot_mode = 0;
    }

    LOGV("%s return ret = %d", __func__, ret);

    return ret;
!!!11080460.cpp!!!	getParameters() : CameraParameters
    LOGV("%s :", __func__);
    mParameters.dump();
    return mParameters;
!!!11080588.cpp!!!	sendCommand(in command : int32_t, in arg1 : int32_t, in arg2 : int32_t) : status_t
    return BAD_VALUE;
!!!11080716.cpp!!!	setPreviewWindow(inout w : preview_stream_ops) : status_t
    int min_bufs;
    status_t ret = OK;

    mPreviewWindow = w;
    LOGI("%s: mPreviewWindow %p", __func__, mPreviewWindow);

    if (!w) {
        LOGE("preview window is NULL!");
        return OK;
    }

    mPreviewLock.lock();

    if (mPreviewRunning && !mPreviewStartDeferred) {
        LOGI("stop preview (window change)");
        stopPreviewInternal();
    }

    if (w->get_min_undequeued_buffer_count(w, &min_bufs)) {
        LOGE("%s: could not retrieve min undequeued buffer count", __func__);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    if (min_bufs >= mSecCamera->getPreviewBufferNumber()) {
        LOGE("%s: min undequeued buffer count %d is too high (expecting at most %d)", __func__,
             min_bufs, mSecCamera->getPreviewBufferNumber() - 1);
    }

    LOGV("%s: setting buffer count to %d", __func__, mSecCamera->getPreviewBufferNumber());

    if (w->set_buffer_count(w, 4/*mSecCamera->getPreviewBufferNumber()*/)) {
        LOGE("%s: could not set buffer count", __func__);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    int preview_width;
    int preview_height;
    mParameters.getPreviewSize(&preview_width, &preview_height);
    int hal_pixel_format = HAL_PIXEL_FORMAT_YCbCr_422_I;

    const char *str_preview_format = mParameters.getPreviewFormat();
    LOGV("%s: preview format %s", __func__, str_preview_format);

    if (w->set_usage(w, GRALLOC_USAGE_SW_WRITE_OFTEN)) {
        LOGE("%s: could not set usage on gralloc buffer", __func__);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    if (w->set_buffers_geometry(w,
                                preview_width, preview_height,
                                hal_pixel_format)) {
        LOGE("%s: could not set buffers geometry to %s",
             __func__, str_preview_format);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    if (mPreviewRunning && mPreviewStartDeferred) {
        LOGV("start/resume preview");
        ret = startPreviewInternal();

        if (ret == OK) {
            mPreviewStartDeferred = false;
            mPreviewCondition.signal();
        } else {
            LOGW("##########Have a error, can not start preview");
        }
    }

    mPreviewLock.unlock();

    return ret;
!!!11080844.cpp!!!	storeMetaDataInBuffers(in enable : bool) : status_t
    // FIXME:
    // metadata buffer mode can be turned on or off.
    // Samsung needs to fix this.
    if (!enable) {
        LOGE("Non-metadata buffer mode is not supported!");
        return INVALID_OPERATION;
    }

    // Marvell: we don't support it.
    return INVALID_OPERATION;
!!!11080972.cpp!!!	release() : void
    LOGW("%s", __func__);

    /* shut down any threads we have that might be running.  do it here
     * instead of the destructor.  we're guaranteed to be on another thread
     * than the ones below.  if we used the destructor, since the threads
     * have a reference to this object, we could wind up trying to wait
     * for ourself to exit, which is a deadlock.
     */
    if (mPreviewThread != NULL) {
        /* this thread is normally already in it's threadLoop but blocked
         * on the condition variable or running.  signal it so it wakes
         * up and can exit.
         */
        mPreviewThread->requestExit();
        mExitPreviewThread = true;
        mPreviewRunning = true; /* let it run so it can exit */
        mPreviewCondition.signal();
        mPreviewThread->requestExitAndWait();
        mPreviewThread.clear();
        mPreviewRunning = false;
    }

    if (mAutoFocusThread != NULL) {
        /* this thread is normally already in it's threadLoop but blocked
         * on the condition variable.  signal it so it wakes up and can exit.
         */
        mFocusLock.lock();
        mAutoFocusThread->requestExit();
        mExitAutoFocusThread = true;
        mFocusCondition.signal();
        mFocusLock.unlock();
        mAutoFocusThread->requestExitAndWait();
        mAutoFocusThread.clear();
    }

    if (mPictureThread != NULL) {
        mPictureThread->requestExitAndWait();
        mPictureThread.clear();
    }

    if (mRawHeap) {
        mRawHeap->release(mRawHeap);
        mRawHeap = 0;
    }

    if (mPreviewHeap) {
        mPreviewHeap->release(mPreviewHeap);
        mPreviewHeap = 0;
    }

    if (mRecordHeap) {
        mRecordHeap->release(mRecordHeap);
        mRecordHeap = 0;
    }

    /* close after all the heaps are cleared since those
    * could have dup'd our file descriptor.
    */
    mSecCamera->DeinitCamera();
!!!11081100.cpp!!!	getCameraId() : int
    return mSecCamera->getCameraId();
!!!11081228.cpp!!!	CameraHardwareSec(in cameraId : int, inout dev : camera_device_t)
    LOGV("%s :", __func__);
    int ret = 0;

    mPreviewWindow = NULL;
    mSecCamera = SecCamera::createInstance();

    mRawHeap = NULL;
    mPreviewHeap = NULL;
    mRecordHeap = NULL;

    if (!mGrallocHal) {
        ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&mGrallocHal);

        if (ret)
            LOGE("ERR(%s):Fail on loading gralloc HAL", __func__);
    }

    ret = mSecCamera->initCamera(cameraId);

    if (ret < 0) {
        LOGE("ERR(%s):Fail on mSecCamera init", __func__);
    }

    initDefaultParameters(cameraId);

    mExitAutoFocusThread = false;
    mExitPreviewThread = false;
    /* whether the PreviewThread is active in preview or stopped.  we
     * create the thread but it is initially in stopped state.
     */
    mPreviewRunning = false;
    mPreviewStartDeferred = false;
    mPreviewThread = new PreviewThread(this);
    mAutoFocusThread = new AutoFocusThread(this);
    mPictureThread = new PictureThread(this);
    mPictureWrapperThread = new PictureWrapperThread(this);
!!!11081356.cpp!!!	~CameraHardwareSec()
    LOGV("%s", __func__);
    mSecCamera->DeinitCamera();
!!!11081484.cpp!!!	startPreviewInternal() : status_t
    LOGV("%s", __func__);

    int ret  = mSecCamera->startPreview();
    LOGV("%s : mSecCamera->startPreview() returned %d", __func__, ret);

    if (ret < 0) {
        LOGE("ERR(%s):Fail on mSecCamera->startPreview()", __func__);
        return UNKNOWN_ERROR;
    }

    setSkipFrame(INITIAL_SKIP_FRAME);

    int width, height, frame_size;

    mSecCamera->getPreviewSize(&width, &height, &frame_size);

    LOGD("mPreviewHeap(fd(%d), size(%d), width(%d), height(%d))",
         mSecCamera->getCameraFd(), frame_size, width, height);

    if (mPreviewHeap) {
        mPreviewHeap->release(mPreviewHeap);
        mPreviewHeap = 0;
    }

    mPreviewHeap = mGetMemoryCb(-1,
                                frame_size,
                                mSecCamera->getPreviewBufferNumber(),
                                0); // no cookie

    return NO_ERROR;
!!!11081612.cpp!!!	stopPreviewInternal() : void
    LOGV("%s :", __func__);

    /* request that the preview thread stop. */
    if (mPreviewRunning) {
        mPreviewRunning = false;

        if (!mPreviewStartDeferred) {
            mPreviewCondition.signal();
            /* wait until preview thread is stopped */
            mPreviewStoppedCondition.wait(mPreviewLock);
        } else
            LOGV("%s : preview running but deferred, doing nothing", __func__);
    } else
        LOGI("%s : preview not running, doing nothing", __func__);
!!!11082764.cpp!!!	initDefaultParameters(in cameraId : int) : void
    if (mSecCamera == NULL) {
        LOGE("ERR(%s):mSecCamera object is NULL", __func__);
        return;
    }

    CameraParameters p;
    CameraParameters ip;
    String8 parameterString;

    int preview_max_width   = 0;
    int preview_max_height  = 0;
    int snapshot_max_width  = 0;
    int snapshot_max_height = 0;

    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
          mSecCamera->getSupportPreviewSize());
    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES,
          mSecCamera->getSupportPictureSize());
    p.getSupportedPreviewSizes(mSupportedPreviewSizes);

    // If these fail, then we are using an invalid cameraId and we'll leave the
    // sizes at zero to catch the error.
    if (mSecCamera->getPreviewMaxSize(&preview_max_width, &preview_max_height) < 0)
        LOGE("getPreviewMaxSize fail (%d / %d) \n", preview_max_width, preview_max_height);

    if (mSecCamera->getSnapshotMaxSize(&snapshot_max_width, &snapshot_max_height) < 0)
        LOGE("getSnapshotMaxSize fail (%d / %d) \n", snapshot_max_width, snapshot_max_height);

    p.setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);

    parameterString = CameraParameters::PIXEL_FORMAT_YUV420SP;
    parameterString.append(",");
    parameterString.append(CameraParameters::PIXEL_FORMAT_YUV420P);
    parameterString.append(",");
    parameterString.append(CameraParameters::PIXEL_FORMAT_YUV422I);
    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, parameterString.string());
    //By default, video format is YV12.
#ifdef MARVELL_SOFTWARE_ENCODER
    p.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420P);
#else
    p.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV422I);
#endif

    p.setPreviewSize(preview_max_width, preview_max_height);

    p.setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
    p.setPictureSize(snapshot_max_width, snapshot_max_height);
    p.set(CameraParameters::KEY_JPEG_QUALITY, "100"); // maximum quality
    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS,
          CameraParameters::PIXEL_FORMAT_JPEG);

    parameterString = CameraParameters::FOCUS_MODE_AUTO;
    parameterString.append(",");
    parameterString.append(CameraParameters::FOCUS_MODE_INFINITY);
    parameterString.append(",");
    parameterString.append(CameraParameters::FOCUS_MODE_MACRO);
    p.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, parameterString.string());
    p.set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
    p.set(CameraParameters::KEY_FOCUS_DISTANCES, BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR);
    p.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, "256x144,0x0");
    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "256");
    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "144");
    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, "15,20,30");
    p.setPreviewFrameRate(15);

    p.set(CameraParameters::KEY_ZOOM_SUPPORTED, "true");
    p.set(CameraParameters::KEY_ZOOM_RATIOS, "100");
    p.set(CameraParameters::KEY_MAX_ZOOM, "0");

    //Only support NONE for effect
    parameterString = CameraParameters::EFFECT_NONE;
    p.set(CameraParameters::KEY_SUPPORTED_EFFECTS, parameterString.string());

    //Only support OFF for flash
    parameterString = CameraParameters::FLASH_MODE_OFF;
    p.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, parameterString.string());
    p.set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);

    parameterString = CameraParameters::SCENE_MODE_AUTO;
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_PORTRAIT);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_LANDSCAPE);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_NIGHT);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_BEACH);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_SNOW);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_SUNSET);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_FIREWORKS);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_SPORTS);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_PARTY);
    parameterString.append(",");
    parameterString.append(CameraParameters::SCENE_MODE_CANDLELIGHT);
    p.set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, parameterString.string());
    p.set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);

    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(10000,25000)");
    p.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "10000,25000");

    p.set(CameraParameters::KEY_FOCAL_LENGTH, "1.5");

    parameterString = CameraParameters::WHITE_BALANCE_AUTO;
    p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, parameterString.string());

    ip.set("sharpness-min", 0);
    ip.set("sharpness-max", 4);
    ip.set("saturation-min", 0);
    ip.set("saturation-max", 4);
    ip.set("contrast-min", 0);
    ip.set("contrast-max", 4);

    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "100");

    p.set(CameraParameters::KEY_ROTATION, 0);
    p.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);

    p.set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);

    ip.set("sharpness", SHARPNESS_DEFAULT);
    ip.set("contrast", CONTRAST_DEFAULT);
    ip.set("saturation", SATURATION_DEFAULT);
    ip.set("iso", "auto");
    ip.set("metering", "center");

    ip.set("wdr", 0);
    ip.set("chk_dataline", 0);
    ip.set("vtmode", 0);
    ip.set("blur", 0);

    p.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "51.2");
    p.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "39.4");
    //Set default expposure to 0, min==max==0 mean can not set exposure
    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
    p.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
    p.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0");

    p.set(CameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED, "false");
    //Exposure
    int exposure_enable;
    int exposure_default, exposure_min, exposure_max, exposure_step;
    mSecCamera->getExposureState(&exposure_enable,
                                 &exposure_default,
                                 &exposure_min,
                                 &exposure_max,
                                 &exposure_step);

    if(exposure_enable) {
        char temp_str[30];
        snprintf(temp_str, 30, "%d", exposure_default);
        p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, temp_str);
        snprintf(temp_str, 30, "%d", exposure_min);
        p.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, temp_str);
        snprintf(temp_str, 30, "%d", exposure_max);
        p.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, temp_str);
        snprintf(temp_str, 30, "%d", exposure_step);
        p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, temp_str);
    }

    mParameters = p;
    mInternalParameters = ip;

    /* make sure mSecCamera has all the settings we do.  applications
     * aren't required to call setParameters themselves (only if they
     * want to change something.
     */
    setParameters(p);
    mSecCamera->setISO(ISO_AUTO);
    mSecCamera->setMetering(METERING_CENTER);
    mSecCamera->setContrast(CONTRAST_DEFAULT);
    mSecCamera->setSharpness(SHARPNESS_DEFAULT);
    mSecCamera->setSaturation(SATURATION_DEFAULT);
    mSecCamera->setSaturation(SATURATION_DEFAULT);
    mSecCamera->setExposure(V4L2_EXPOSURE_AUTO);
    mSecCamera->setFrameRate(15);
!!!11083020.cpp!!!	previewThread() : int
    int index;
    nsecs_t timestamp;
    unsigned int phyYAddr;
    unsigned int phyCAddr;
    struct addrs *addrs;
#ifdef CAMERA_DUMP_TIME
    char property[100];

    if (property_get("camera.dumptime", property, NULL) > 0) {
        bNeedDumpTime = atoi(property);
    } else {
        bNeedDumpTime = false;
    }

#endif

    if(bNeedDumpTime) {
        LOGI(">>>>>>>>>>>Start getPreview");
    }

    index = mSecCamera->getPreview();

    if(bNeedDumpTime) {
        LOGI(">>>>>>>>>>>End getPreview");
    }

    if (index < 0) {
        struct stat st;

        if (-1 == stat (CAMERA_DEV_NAME, &st) && bHaveError == false) {
            bHaveError = true;
            LOGW("Can not find the device anymore, report a Error to application");
            mNotifyCb(CAMERA_MSG_ERROR, CAMERA_ERROR_SERVER_DIED, 0, mCallbackCookie);
        }

        //LOGE("ERR(%s):Fail on SecCamera->getPreview()", __func__);
        return UNKNOWN_ERROR;
    }

//  LOGW("%s: index %d", __func__, index);

    mSkipFrameLock.lock();

    if (mSkipFrame > 0) {
        mSkipFrame--;
        mSkipFrameLock.unlock();
        LOGW("%s: index %d skipping frame", __func__, index);
        return NO_ERROR;
    }

    mSkipFrameLock.unlock();

    timestamp = systemTime(SYSTEM_TIME_MONOTONIC);

    int width, height, frame_size, offset;

    mSecCamera->getPreviewSize(&width, &height, &frame_size);

    offset = frame_size * index;

    if (mPreviewWindow && mGrallocHal) {
        buffer_handle_t *buf_handle;
        int stride;

        if(bNeedDumpTime) {
            LOGI(">>>>>>>>>>>Start dequeue_buffer from window");
        }

        if (0 != mPreviewWindow->dequeue_buffer(mPreviewWindow, &buf_handle, &stride)) {
            LOGE("Could not dequeue gralloc buffer!\n");
            goto callbacks;
        }

        if(bNeedDumpTime) {
            LOGI(">>>>>>>>>>>Start lock and copy for window");
        }

        void *vaddr;

        if (!mGrallocHal->lock(mGrallocHal,
                               *buf_handle,
                               GRALLOC_USAGE_SW_WRITE_OFTEN,
                               0, 0, width, height, &vaddr)) {
#ifdef CAMERA_DUMP_IMAGE
            char property[100];
            int  resolution = 0;

            if (property_get("camera.dump", property, NULL) > 0) {
                resolution = atoi(property);
            }

            if(resolution) {
                FILE *fb = NULL;
                char name[50];
                static int dum_camera_num = 0;
                sprintf(name, "/11/%d_%d_%d.yuyv", width, height, dum_camera_num++);
                fb = fopen(name, "wb");

                if(fb) {
                    fwrite(mSecCamera->m_preview_buf[index].start, width * height * 2, 1, fb);
                    fclose(fb);
                } else {
                    LOGW("###########can not open %s", name);
                }
            }

#endif
            memcpy(vaddr,  mSecCamera->m_preview_buf[index].start, width * height * 2);
            mGrallocHal->unlock(mGrallocHal, *buf_handle);
        } else
            LOGE("%s: could not obtain gralloc buffer", __func__);

        if(bNeedDumpTime) {
            LOGI(">>>>>>>>>>>Start queue for window");
        }

        if (0 != mPreviewWindow->enqueue_buffer(mPreviewWindow, buf_handle)) {
            LOGE("Could not enqueue gralloc buffer!\n");
            goto callbacks;
        }

        if(bNeedDumpTime) {
            LOGI(">>>>>>>>>>>End queue for window");
        }
    }

callbacks:

    // Notify the client of a new frame.
    if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
        const char * preview_format = mParameters.getPreviewFormat();

        if (!strcmp(preview_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
            // Just copy for YUV422
            LOGW("%s %d. Just use YUYV422 data", __FUNCTION__, __LINE__);
            char *vu = ((char *)mPreviewHeap->data) + offset;
            memcpy(vu, mSecCamera->m_preview_buf[index].start, width * height * 2);
        } else if(!strcmp(preview_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
            // Color conversion from YUV422 to NV21
            LOGW("%s %d. Will convert YUYV422 to NV21", __FUNCTION__, __LINE__);
            char *vu = ((char *)mPreviewHeap->data) + offset;
            yuyv422_to_yuv420sp((unsigned char*)mSecCamera->m_preview_buf[index].start,
                                (unsigned char*)vu,
                                width,
                                height);
        } else if (!strcmp(preview_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
            // Color conversion from YUV422 to YV12
            LOGW("%s %d. Will convert YUYV422 to YV12", __FUNCTION__, __LINE__);
            char *vu = ((char *)mPreviewHeap->data) + offset;
            yuyv422_to_yuv420((unsigned char*)mSecCamera->m_preview_buf[index].start,
                              (unsigned char*)vu,
                              width,
                              height);
        }

        mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewHeap, index, NULL, mCallbackCookie);
    }

    Mutex::Autolock lock(mRecordLock);

    if (mRecordRunning == true) {
        int video_index = mSecCamera->getRecordFrame();

        if (video_index < 0) {
            LOGE(" No enough buffer now, return directly");
            return NO_ERROR;
        }

        int frame_size = 0;
        mSecCamera->getRecordingSize(&width, &height);
        const char * video_format = mParameters.get(CameraParameters::KEY_VIDEO_FRAME_FORMAT);

        if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
            frame_size = (width * height * 3) >> 1;
        } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
            frame_size = (width * height * 3) >> 1;
        } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
            frame_size = (width * height) << 1;
        } else {
            LOGE("Only Support NV21, YV12 YUV422I formats");
            return NO_ERROR;
        }

        int offset = (frame_size + sizeof(struct addrs)) * video_index;
        addrs = (struct addrs *)((char *)mRecordHeap->data + offset + frame_size);
        addrs->type = kMetadataBufferTypeCameraSource;
        addrs->buf_index = video_index;

        if(!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
            // Color conversion from YUV422 to NV21
            char *vu = ((char *)mRecordHeap->data) + offset;
            yuyv422_to_yuv420sp((unsigned char*)mSecCamera->m_preview_buf[index].start,
                                (unsigned char*)vu,
                                width,
                                height);
            mRecordHeap->size = frame_size + sizeof(struct addrs);
        } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV420P)) {
            // Color conversion from YUV422 to YV12
            char *vu = ((char *)mRecordHeap->data) + offset;
            yuyv422_to_yuv420((unsigned char*)mSecCamera->m_preview_buf[index].start,
                              (unsigned char*)vu,
                              width,
                              height);
            mRecordHeap->size = frame_size + sizeof(struct addrs);
        } else if (!strcmp(video_format, CameraParameters::PIXEL_FORMAT_YUV422I)) {
            // Just copy for YUV422
            char *vu = ((char *)mRecordHeap->data) + offset;
            memcpy(vu, mSecCamera->m_preview_buf[index].start, frame_size);
        } else {
            LOGE("Only Support NV21, YV12 YUV422I formats");
            return NO_ERROR;
        }

        // Notify the client of a new frame.
        if (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
            mDataCbTimestamp(timestamp,
                             CAMERA_MSG_VIDEO_FRAME,
                             mRecordHeap,
                             video_index,
                             mCallbackCookie);
        } else {
            mSecCamera->releaseRecordFrame(video_index);
        }
    }

    if(bNeedDumpTime) {
        LOGI(">>>>>>>>>>>End previewThread");
    }

    return NO_ERROR;
!!!11083148.cpp!!!	previewThreadWrapper() : int
    LOGI("%s: starting", __func__);

    while (1) {
        mPreviewLock.lock();

        while (!mPreviewRunning) {
            LOGI("%s: calling mSecCamera->stopPreview() and waiting", __func__);
            mSecCamera->stopPreview();
            /* signal that we're stopping */
            mPreviewStoppedCondition.signal();
            mPreviewCondition.wait(mPreviewLock);
            LOGI("%s: return from wait", __func__);
        }

        mPreviewLock.unlock();

        if (mExitPreviewThread) {
            LOGI("%s: exiting", __func__);
            mSecCamera->stopPreview();
            return 0;
        }

        previewThread();
    }
!!!11083276.cpp!!!	autoFocusThread() : int
    int count = 0;
    int af_status = 0 ;

    LOGV("%s : starting", __func__);

    /* block until we're told to start.  we don't want to use
     * a restartable thread and requestExitAndWait() in cancelAutoFocus()
     * because it would cause deadlock between our callbacks and the
     * caller of cancelAutoFocus() which both want to grab the same lock
     * in CameraServices layer.
     */
    mFocusLock.lock();

    /* check early exit request */
    if (mExitAutoFocusThread) {
        mFocusLock.unlock();
        LOGV("%s : exiting on request0", __func__);
        return NO_ERROR;
    }

    mFocusCondition.wait(mFocusLock);

    /* check early exit request */
    if (mExitAutoFocusThread) {
        mFocusLock.unlock();
        LOGV("%s : exiting on request1", __func__);
        return NO_ERROR;
    }

    mFocusLock.unlock();

    LOGV("%s : calling setAutoFocus", __func__);

    if (mSecCamera->setAutofocus() < 0) {
        LOGE("ERR(%s):Fail on mSecCamera->setAutofocus()", __func__);
        return UNKNOWN_ERROR;
    }

    //af_status = mSecCamera->getAutoFocusResult();
    af_status = 0x01;//Hack

    if (af_status == 0x01) {
        LOGV("%s : AF Success!!", __func__);

        if (mMsgEnabled & CAMERA_MSG_FOCUS)
            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
    } else if (af_status == 0x02) {
        LOGV("%s : AF Cancelled !!", __func__);

        if (mMsgEnabled & CAMERA_MSG_FOCUS) {
            /* CAMERA_MSG_FOCUS only takes a bool.  true for
             * finished and false for failure.  cancel is still
             * considered a true result.
             */
            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
        }
    } else {
        LOGV("%s : AF Fail !!", __func__);
        LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);

        if (mMsgEnabled & CAMERA_MSG_FOCUS)
            mNotifyCb(CAMERA_MSG_FOCUS, false, 0, mCallbackCookie);
    }

    LOGV("%s : exiting with no error", __func__);
    return NO_ERROR;
!!!11083404.cpp!!!	pictureThread() : int
    LOGV("%s :", __func__);

    int jpeg_size = 0;
    int ret = NO_ERROR;
    unsigned char *jpeg_data = NULL;
    int postview_offset = 0;
    unsigned char *postview_data = NULL;

    unsigned char *addr = NULL;
    int mPictureViewWidth, mPictureViewHeight, mPictureViewSize;
    int mThumbWidth, mThumbHeight, mThumbSize;
    int cap_width, cap_height, cap_frame_size;
    int JpegImageSize, JpegExifSize;
    bool isLSISensor = false;
    int out_size;
    int tn_out_size;
    int exif_jpeg_out_size;
    ExifElementsTable * exif_data = new ExifElementsTable();
    Section_t* exif_section = NULL;

    unsigned int output_size = 0;

    mSecCamera->getSnapshotSize(&mPictureViewWidth, &mPictureViewHeight, &mPictureViewSize);
    int mJpegHeapSize;

    LOG_TIME_DEFINE(0)
    LOG_TIME_START(0)
//    sp<MemoryBase> buffer = new MemoryBase(mRawHeap, 0, mPostViewSize + 8);

    struct addrs_cap *addrs = (struct addrs_cap *)mRawHeap->data;

    addrs[0].width = mPictureViewWidth;
    addrs[0].height = mPictureViewHeight;
    LOGV("[5B] mPostViewWidth = %d mPostViewHeight = %d\n", mPostViewWidth, mPostViewHeight);

    camera_memory_t *JpegHeap = mGetMemoryCb(-1, mJpegHeapSize, 1, 0);
    sp<MemoryHeapBase> PostviewHeap = new MemoryHeapBase(mPictureViewSize);
    sp<MemoryHeapBase> ThumbnailHeap = new MemoryHeapBase(mThumbSize);

    LOG_TIME_DEFINE(1)
    LOG_TIME_START(1)

    unsigned int phyAddr;
    LOGW("%s %d", __FUNCTION__, __LINE__);

    // Modified the shutter sound timing for Jpeg capture
    mSecCamera->setSnapshotCmd();
    LOGW("%s %d", __FUNCTION__, __LINE__);

    if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
        LOGI(">>Will send SHUTTER message");
        //mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
        LOGI(">>After send SHUTTER message");
    }

    jpeg_data = mSecCamera->getJpeg(&jpeg_size, &phyAddr);
    /*if (jpeg_data == NULL) {
        LOGE("ERR(%s):Fail on SecCamera->getJpeg()", __func__);
        ret = UNKNOWN_ERROR;
        goto out;
    }*/

    //##############################//
    jpeg_encoder_params * main_jpeg = NULL, *tn_jpeg = NULL;
    main_jpeg = (jpeg_encoder_params*)malloc(sizeof(jpeg_encoder_params));

    if (main_jpeg) {
        main_jpeg->src = (uint8_t*) phyAddr;
        main_jpeg->src_size = jpeg_size;
        main_jpeg->dst = (uint8_t*)malloc(jpeg_size);
        main_jpeg->dst_size = jpeg_size;
        main_jpeg->quality = mSecCamera->getJpegQuality();
        main_jpeg->in_width = mPictureViewWidth;
        main_jpeg->in_height = mPictureViewHeight;
        main_jpeg->out_width = mPictureViewWidth;
        main_jpeg->out_height = mPictureViewHeight;
        main_jpeg->format = "yuv422i-yuyv";
    }

    if(mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH) > 0 &&
       mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT) > 0) {
        int thumbnailWidth = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
        int thumbnailHeight = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
        void * src = malloc(thumbnailWidth  * thumbnailHeight * 2);
        scaleDownYuv422((char*)phyAddr,
                        mPictureViewWidth,
                        mPictureViewHeight,
                        (char*)src,
                        thumbnailWidth,
                        thumbnailHeight);
        tn_jpeg = (jpeg_encoder_params*)malloc(sizeof(jpeg_encoder_params));

        if (tn_jpeg) {
            tn_jpeg->src = (uint8_t*) src;
            tn_jpeg->src_size = thumbnailWidth * thumbnailHeight * 2;
            tn_jpeg->dst = (uint8_t*)malloc(thumbnailWidth  * thumbnailHeight * 2);
            tn_jpeg->dst_size = thumbnailWidth * thumbnailHeight * 2;
            tn_jpeg->quality = mSecCamera->getJpegQuality();
            tn_jpeg->in_width = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
            tn_jpeg->in_height = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
            tn_jpeg->out_width = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
            tn_jpeg->out_height = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
            tn_jpeg->format = "yuv422i-yuyv";
        }

        tn_out_size = encode_jpeg(tn_jpeg);

        free(src);
    }

    out_size = encode_jpeg(main_jpeg);

    exif_data->insertElement("Make", "Marvell");
    exif_data->insertElement("Model", "Model");
    exif_data->insertElement("ImageWidth", "1280");
    exif_data->insertElement("ImageLength", "720");
    exif_data->insertElement("FocalLength", "3/2");

    //This 2 line use to insert the GPS information
    exif_data->setParametersEXIF(mParameters);
    exif_data->setupEXIF();

    if(mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD)) {
        LOGW("\n\n\n###############KEY_GPS_TIMESTAMP is =%s\n\n\n",
             mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD));
        char temp_value[100];
        memcpy(temp_value, ExifAsciiPrefix, sizeof(ExifAsciiPrefix));
        memcpy(temp_value + sizeof(ExifAsciiPrefix),
               mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD),
               (100 - sizeof(ExifAsciiPrefix)));
        exif_data->insertElement(TAG_GPS_PROCESSING_METHOD, temp_value);
    } else {
        LOGW("\n\n\n###############Do not have KEY_GPS_PROCESSING_METHOD \n\n\n");
    }

    exif_data->insertElement("Copyright", "Marvell Camera Hal");
    exif_data->insertElement("WhiteBalance", "auto");

    exif_data->insertExifToJpeg(main_jpeg->dst, out_size);

    if(mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH) > 0 &&
       mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT) > 0) {
        exif_data->insertExifThumbnailImage((const char*)tn_jpeg->dst, tn_jpeg->jpeg_size);
    }

    exif_section = FindSection(M_EXIF);

    //##############################//
    LOGW("%s %d. data=%x, phyAddr=%x, size =%d",
         __FUNCTION__, __LINE__, mRawHeap->data, phyAddr, jpeg_size);
    //memcpy(mRawHeap->data, (const void*)phyAddr, jpeg_size);
    LOGW("%s %d", __FUNCTION__, __LINE__);

    if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE) {
        mDataCb(CAMERA_MSG_RAW_IMAGE, mRawHeap, 0, NULL, mCallbackCookie);
    } else if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY) {
        mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
    }

    LOGW("%s %d", __FUNCTION__, __LINE__);

    if (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE) {
        /*camera_memory_t *ExifHeap = mGetMemoryCb(-1, EXIF_FILE_SIZE + JPG_STREAM_BUF_SIZE, 1, 0);

        JpegExifSize = mSecCamera->getExif((unsigned char *)ExifHeap->data,
                                           (unsigned char *)ThumbnailHeap->base());

        LOGW("JpegExifSize=%d", JpegExifSize);

        if (JpegExifSize < 0) {
            ret = UNKNOWN_ERROR;
            ExifHeap->release(ExifHeap);
            goto out;
        }*/

        LOGW("%s %d", __FUNCTION__, __LINE__);

        if(exif_section) {
            exif_jpeg_out_size =  out_size + exif_section->Size;
        } else {
            exif_jpeg_out_size = out_size;
        }

        camera_memory_t *mem = mGetMemoryCb(-1, exif_jpeg_out_size, 1, 0);
        uint8_t *ptr = (uint8_t *) mem->data;

        if (exif_section) {
            exif_data->saveJpeg((unsigned char*)ptr, out_size + exif_section->Size);
        } else {
            memcpy(ptr, main_jpeg->dst, out_size);
        }

        LOGW("%s %d", __FUNCTION__, __LINE__);

        mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, mem, 0, NULL, mCallbackCookie);
        mem->release(mem);
        LOGW("%s %d", __FUNCTION__, __LINE__);
        //ExifHeap->release(ExifHeap);
    }

    LOG_TIME_END(0)
    LOG_CAMERA("pictureThread interval: %lu us", LOG_TIME(0));

    LOGV("%s : pictureThread end", __func__);

out:
    free(main_jpeg->dst);
    free(main_jpeg);

    if( mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH) > 0 &&
        mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT) > 0 &&
        tn_jpeg) {
        free(tn_jpeg);
        free(tn_jpeg->dst);
    }

    JpegHeap->release(JpegHeap);
    mSecCamera->endSnapshot();
    mCaptureLock.lock();
    mCaptureInProgress = false;
    mCaptureCondition.broadcast();
    mCaptureLock.unlock();

    return ret;
!!!11083532.cpp!!!	decodeInterleaveData(inout pInterleaveData : byte, in interleaveDataSize : int, in yuvWidth : int, in yuvHeight : int, inout pJpegSize : int, inout pJpegData : void, inout pYuvData : void) : int
    if (pInterleaveData == NULL)
        return false;

    bool ret = true;
    unsigned int *interleave_ptr = (unsigned int *)pInterleaveData;
    unsigned char *jpeg_ptr = (unsigned char *)pJpegData;
    unsigned char *yuv_ptr = (unsigned char *)pYuvData;
    unsigned char *p;
    int jpeg_size = 0;
    int yuv_size = 0;

    int i = 0;

    LOGV("decodeInterleaveData Start~~~");

    while (i < interleaveDataSize) {
        if ((*interleave_ptr == 0xFFFFFFFF) || (*interleave_ptr == 0x02FFFFFF) ||
            (*interleave_ptr == 0xFF02FFFF)) {
            // Padding Data
//            LOGE("%d(%x) padding data\n", i, *interleave_ptr);
            interleave_ptr++;
            i += 4;
        } else if ((*interleave_ptr & 0xFFFF) == 0x05FF) {
            // Start-code of YUV Data
//            LOGE("%d(%x) yuv data\n", i, *interleave_ptr);
            p = (unsigned char *)interleave_ptr;
            p += 2;
            i += 2;

            // Extract YUV Data
            if (pYuvData != NULL) {
                memcpy(yuv_ptr, p, yuvWidth * 2);
                yuv_ptr += yuvWidth * 2;
                yuv_size += yuvWidth * 2;
            }

            p += yuvWidth * 2;
            i += yuvWidth * 2;

            // Check End-code of YUV Data
            if ((*p == 0xFF) && (*(p + 1) == 0x06)) {
                interleave_ptr = (unsigned int *)(p + 2);
                i += 2;
            } else {
                ret = false;
                break;
            }
        } else {
            // Extract JPEG Data
//            LOGE("%d(%x) jpg data, jpeg_size = %d bytes\n", i, *interleave_ptr, jpeg_size);
            if (pJpegData != NULL) {
                memcpy(jpeg_ptr, interleave_ptr, 4);
                jpeg_ptr += 4;
                jpeg_size += 4;
            }

            interleave_ptr++;
            i += 4;
        }
    }

    if (ret) {
        if (pJpegData != NULL) {
            // Remove Padding after EOI
            for (i = 0; i < 3; i++) {
                if (*(--jpeg_ptr) != 0xFF) {
                    break;
                }

                jpeg_size--;
            }

            *pJpegSize = jpeg_size;

        }

        // Check YUV Data Size
        if (pYuvData != NULL) {
            if (yuv_size != (yuvWidth * yuvHeight * 2)) {
                ret = false;
            }
        }
    }

    LOGV("decodeInterleaveData End~~~");
    return ret;
!!!11083660.cpp!!!	YUY2toNV21(inout srcBuf : void, inout dstBuf : void, in srcWidth : uint32_t, in srcHeight : uint32_t) : bool
    int32_t        x, y, src_y_start_pos, dst_cbcr_pos, dst_pos, src_pos;
    unsigned char *srcBufPointer = (unsigned char *)srcBuf;
    unsigned char *dstBufPointer = (unsigned char *)dstBuf;

    dst_pos = 0;
    dst_cbcr_pos = srcWidth * srcHeight;

    for (uint32_t y = 0; y < srcHeight; y++) {
        src_y_start_pos = (y * (srcWidth * 2));

        for (uint32_t x = 0; x < (srcWidth * 2); x += 2) {
            src_pos = src_y_start_pos + x;

            dstBufPointer[dst_pos++] = srcBufPointer[src_pos];
        }
    }

    for (uint32_t y = 0; y < srcHeight; y += 2) {
        src_y_start_pos = (y * (srcWidth * 2));

        for (uint32_t x = 0; x < (srcWidth * 2); x += 4) {
            src_pos = src_y_start_pos + x;

            dstBufPointer[dst_cbcr_pos++] = srcBufPointer[src_pos + 3];
            dstBufPointer[dst_cbcr_pos++] = srcBufPointer[src_pos + 1];
        }
    }

    return true;
!!!11083788.cpp!!!	scaleDownYuv422(inout srcBuf : char, in srcWidth : uint32_t, in srcHeight : uint32_t, inout dstBuf : char, in dstWidth : uint32_t, in dstHeight : uint32_t) : bool
    int32_t step_x, step_y;
    int32_t iXsrc, iXdst;
    int32_t x, y, src_y_start_pos, dst_pos, src_pos;

    if (dstWidth % 2 != 0 || dstHeight % 2 != 0) {
        LOGE("scale_down_yuv422: invalid width, height for scaling");
        return false;
    }

    step_x = srcWidth / dstWidth;
    step_y = srcHeight / dstHeight;

    dst_pos = 0;

    for (uint32_t y = 0; y < dstHeight; y++) {
        src_y_start_pos = (y * step_y * (srcWidth * 2));

        for (uint32_t x = 0; x < dstWidth; x += 2) {
            src_pos = src_y_start_pos + (x * (step_x * 2));

            dstBuf[dst_pos++] = srcBuf[src_pos    ];
            dstBuf[dst_pos++] = srcBuf[src_pos + 1];
            dstBuf[dst_pos++] = srcBuf[src_pos + 2];
            dstBuf[dst_pos++] = srcBuf[src_pos + 3];
        }
    }

    return true;
!!!11083916.cpp!!!	CheckVideoStartMarker(inout pBuf : byte) : bool
    if (!pBuf) {
        LOGE("CheckVideoStartMarker() => pBuf is NULL\n");
        return false;
    }

    if (HIBYTE(VIDEO_COMMENT_MARKER_H) == * pBuf
        && LOBYTE(VIDEO_COMMENT_MARKER_H) == *(pBuf + 1)
        && HIBYTE(VIDEO_COMMENT_MARKER_L) == *(pBuf + 2)
        && LOBYTE(VIDEO_COMMENT_MARKER_L) == *(pBuf + 3))
        return true;

    return false;
!!!11084044.cpp!!!	CheckEOIMarker(inout pBuf : byte) : bool
    if (!pBuf) {
        LOGE("CheckEOIMarker() => pBuf is NULL\n");
        return false;
    }

    // EOI marker [FF D9]
    if (HIBYTE(JPEG_EOI_MARKER) == *pBuf && LOBYTE(JPEG_EOI_MARKER) == *(pBuf + 1))
        return true;

    return false;
!!!11084172.cpp!!!	FindEOIMarkerInJPEG(inout pBuf : byte, in dwBufSize : int, inout pnJPEGsize : int) : bool
    if (NULL == pBuf || 0 >= dwBufSize) {
        LOGE("FindEOIMarkerInJPEG() => There is no contents.");
        return false;
    }

    unsigned char *pBufEnd = pBuf + dwBufSize;

    while (pBuf < pBufEnd) {
        if (CheckEOIMarker(pBuf++))
            return true;

        (*pnJPEGsize)++;
    }

    return false;
!!!11084300.cpp!!!	SplitFrame(inout pFrame : byte, in dwSize : int, in dwJPEGLineLength : int, in dwVideoLineLength : int, in dwVideoHeight : int, inout pJPEG : void, inout pdwJPEGSize : int, inout pVideo : void, inout pdwVideoSize : int) : bool
    LOGV("===========SplitFrame Start==============");

    if (NULL == pFrame || 0 >= dwSize) {
        LOGE("There is no contents (pFrame=%p, dwSize=%d", pFrame, dwSize);
        return false;
    }

    if (0 == dwJPEGLineLength || 0 == dwVideoLineLength) {
        LOGE("There in no input information for decoding interleaved jpeg");
        return false;
    }

    unsigned char *pSrc = pFrame;
    unsigned char *pSrcEnd = pFrame + dwSize;

    unsigned char *pJ = (unsigned char *)pJPEG;
    int dwJSize = 0;
    unsigned char *pV = (unsigned char *)pVideo;
    int dwVSize = 0;

    bool bRet = false;
    bool isFinishJpeg = false;

    while (pSrc < pSrcEnd) {
        // Check video start marker
        if (CheckVideoStartMarker(pSrc)) {
            int copyLength;

            if (pSrc + dwVideoLineLength <= pSrcEnd)
                copyLength = dwVideoLineLength;
            else
                copyLength = pSrcEnd - pSrc - VIDEO_COMMENT_MARKER_LENGTH;

            // Copy video data
            if (pV) {
                memcpy(pV, pSrc + VIDEO_COMMENT_MARKER_LENGTH, copyLength);
                pV += copyLength;
                dwVSize += copyLength;
            }

            pSrc += copyLength + VIDEO_COMMENT_MARKER_LENGTH;
        } else {
            // Copy pure JPEG data
            int size = 0;
            int dwCopyBufLen = dwJPEGLineLength <= pSrcEnd - pSrc ?
                               dwJPEGLineLength : pSrcEnd - pSrc;

            if (FindEOIMarkerInJPEG((unsigned char *)pSrc, dwCopyBufLen, &size)) {
                isFinishJpeg = true;
                size += 2;  // to count EOF marker size
            } else {
                if ((dwCopyBufLen == 1) && (pJPEG < pJ)) {
                    unsigned char checkBuf[2] = { *(pJ - 1), *pSrc };

                    if (CheckEOIMarker(checkBuf))
                        isFinishJpeg = true;
                }

                size = dwCopyBufLen;
            }

            memcpy(pJ, pSrc, size);

            dwJSize += size;

            pJ += dwCopyBufLen;
            pSrc += dwCopyBufLen;
        }

        if (isFinishJpeg)
            break;
    }

    if (isFinishJpeg) {
        bRet = true;

        if(pdwJPEGSize)
            *pdwJPEGSize = dwJSize;

        if(pdwVideoSize)
            *pdwVideoSize = dwVSize;
    } else {
        LOGE("DecodeInterleaveJPEG_WithOutDT() => Can not find EOI");
        bRet = false;

        if(pdwJPEGSize)
            *pdwJPEGSize = 0;

        if(pdwVideoSize)
            *pdwVideoSize = 0;
    }

    LOGV("===========SplitFrame end==============");

    return bRet;
!!!11084428.cpp!!!	setSkipFrame(in frame : int) : void
    Mutex::Autolock lock(mSkipFrameLock);

    if (frame < mSkipFrame)
        return;

    mSkipFrame = frame;
!!!11084556.cpp!!!	isSupportedPreviewSize(in width : int, in height : int) : bool
    unsigned int i;

    for (i = 0; i < mSupportedPreviewSizes.size(); i++) {
        if (mSupportedPreviewSizes[i].width == width &&
            mSupportedPreviewSizes[i].height == height)
            return true;
    }

    return false;
!!!11084684.cpp!!!	isSupportedParameter(in parm : char, in supported_parm : char) : bool
    const char *pStart;
    const char *pEnd;

    if (!parm || !supported_parm)
        return false;

    pStart = supported_parm;

    while (true) {
        pEnd = strchr(pStart, ',');

        if (!pEnd) {
            if (!strcmp(parm, pStart))
                return true;
            else
                return false;
        }

        if (!strncmp(parm, pStart, pEnd - pStart)) {
            return true;
        }

        pStart = pEnd + 1;
    }

    /* NOTREACHED */
!!!11084812.cpp!!!	waitCaptureCompletion() : status_t
    // 5 seconds timeout
    nsecs_t endTime = 5000000000LL + systemTime(SYSTEM_TIME_MONOTONIC);
    Mutex::Autolock lock(mCaptureLock);

    while (mCaptureInProgress) {
        nsecs_t remainingTime = endTime - systemTime(SYSTEM_TIME_MONOTONIC);

        if (remainingTime <= 0) {
            LOGE("Timed out waiting picture thread.");
            return TIMED_OUT;
        }

        LOGD("Waiting for picture thread to complete.");
        mCaptureCondition.waitRelative(mCaptureLock, remainingTime);
    }

    return NO_ERROR;
!!!11085196.cpp!!!	pictureWrapperThread() : int
    return takePicture();
