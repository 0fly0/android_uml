class CallbackProxy
!!!4821132.java!!!	CallbackProxy(inout context : Context, inout w : WebViewClassic)
        // Used to start a default activity.
        mContext = context;
        mWebView = w;
        mBackForwardList = new WebBackForwardListClassic(this);
!!!4821260.java!!!	blockMessages() : void
        mBlockMessages = true;
!!!4821388.java!!!	messagesBlocked() : boolean
        return mBlockMessages;
!!!4821516.java!!!	shutdown() : void
        removeCallbacksAndMessages(null);
        setWebViewClient(null);
        setWebChromeClient(null);
!!!4821644.java!!!	setWebViewClient(inout client : WebViewClient) : void
        mWebViewClient = client;
!!!4821772.java!!!	getWebViewClient() : WebViewClient
       return mWebViewClient;
!!!4821900.java!!!	setWebChromeClient(inout client : WebChromeClient) : void
        mWebChromeClient = client;
!!!4822028.java!!!	getWebChromeClient() : WebChromeClient
       return mWebChromeClient;
!!!4822156.java!!!	setDownloadListener(inout client : DownloadListener) : void
        mDownloadListener = client;
!!!4822284.java!!!	getBackForwardList() : WebBackForwardListClassic
        return mBackForwardList;
!!!4822412.java!!!	setWebBackForwardListClient(inout client : WebBackForwardListClient) : void
        mWebBackForwardListClient = client;
!!!4822540.java!!!	getWebBackForwardListClient() : WebBackForwardListClient
        return mWebBackForwardListClient;
!!!4822668.java!!!	uiOverrideUrlLoading(in overrideUrl : String) : boolean
        if (overrideUrl == null || overrideUrl.length() == 0) {
            return false;
        }
        boolean override = false;
        if (mWebViewClient != null) {
            override = mWebViewClient.shouldOverrideUrlLoading(mWebView.getWebView(),
                    overrideUrl);
        } else {
            Intent intent = new Intent(Intent.ACTION_VIEW,
                    Uri.parse(overrideUrl));
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            // If another application is running a WebView and launches the
            // Browser through this Intent, we want to reuse the same window if
            // possible.
            intent.putExtra(Browser.EXTRA_APPLICATION_ID,
                    mContext.getPackageName());
            try {
                mContext.startActivity(intent);
                override = true;
            } catch (ActivityNotFoundException ex) {
                // If no application can handle the URL, assume that the
                // browser can handle it.
            }
        }
        return override;
!!!4822796.java!!!	uiOverrideKeyEvent(inout event : KeyEvent) : boolean
        if (mWebViewClient != null) {
            return mWebViewClient.shouldOverrideKeyEvent(mWebView.getWebView(), event);
        }
        return false;
!!!4822924.java!!!	handleMessage(inout msg : Message) : void
        // We don't have to do synchronization because this function operates
        // in the UI thread. The WebViewClient and WebChromeClient functions
        // that check for a non-null callback are ok because java ensures atomic
        // 32-bit reads and writes.
        if (messagesBlocked()) return;
        switch (msg.what) {
            case PAGE_STARTED:
                String startedUrl = msg.getData().getString("url");
                mWebView.onPageStarted(startedUrl);
                if (mWebViewClient != null) {
                    mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl,
                            (Bitmap) msg.obj);
                }
                break;

            case PAGE_FINISHED:
                String finishedUrl = (String) msg.obj;
                mWebView.onPageFinished(finishedUrl);
                if (mWebViewClient != null) {
                    mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
                }
                break;

            case RECEIVED_ICON:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
                }
                break;

            case RECEIVED_TOUCH_ICON_URL:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),
                            (String) msg.obj, msg.arg1 == 1);
                }
                break;

            case RECEIVED_TITLE:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onReceivedTitle(mWebView.getWebView(),
                            (String) msg.obj);
                }
                break;

            case REPORT_ERROR:
                if (mWebViewClient != null) {
                    int reasonCode = msg.arg1;
                    final String description  = msg.getData().getString("description");
                    final String failUrl  = msg.getData().getString("failingUrl");
                    mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode,
                            description, failUrl);
                }
                break;

            case RESEND_POST_DATA:
                Message resend =
                        (Message) msg.getData().getParcelable("resend");
                Message dontResend =
                        (Message) msg.getData().getParcelable("dontResend");
                if (mWebViewClient != null) {
                    mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend,
                            resend);
                } else {
                    dontResend.sendToTarget();
                }
                break;

            case OVERRIDE_URL:
                String overrideUrl = msg.getData().getString("url");
                boolean override = uiOverrideUrlLoading(overrideUrl);
                ResultTransport<Boolean> result =
                        (ResultTransport<Boolean>) msg.obj;
                synchronized (this) {
                    result.setResult(override);
                    notify();
                }
                break;

            case AUTH_REQUEST:
                if (mWebViewClient != null) {
                    HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                    String host = msg.getData().getString("host");
                    String realm = msg.getData().getString("realm");
                    mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler,
                            host, realm);
                }
                break;

            case SSL_ERROR:
                if (mWebViewClient != null) {
                    HashMap<String, Object> map =
                        (HashMap<String, Object>) msg.obj;
                    mWebViewClient.onReceivedSslError(mWebView.getWebView(),
                            (SslErrorHandler) map.get("handler"),
                            (SslError) map.get("error"));
                }
                break;

            case PROCEEDED_AFTER_SSL_ERROR:
                if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                    ((WebViewClientClassicExt) mWebViewClient).onProceededAfterSslError(
                            mWebView.getWebView(),
                            (SslError) msg.obj);
                }
                break;

            case CLIENT_CERT_REQUEST:
                if (mWebViewClient != null  && mWebViewClient instanceof WebViewClientClassicExt) {
                    HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                    ((WebViewClientClassicExt) mWebViewClient).onReceivedClientCertRequest(
                            mWebView.getWebView(),
                            (ClientCertRequestHandler) map.get("handler"),
                            (String) map.get("host_and_port"));
                }
                break;

            case PROGRESS:
                // Synchronize to ensure mLatestProgress is not modified after
                // setProgress is called and before mProgressUpdatePending is
                // changed.
                synchronized (this) {
                    if (mWebChromeClient != null) {
                        mWebChromeClient.onProgressChanged(mWebView.getWebView(),
                                mLatestProgress);
                    }
                    mProgressUpdatePending = false;
                }
                break;

            case UPDATE_VISITED:
                if (mWebViewClient != null) {
                    mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),
                            (String) msg.obj, msg.arg1 != 0);
                }
                break;

            case LOAD_RESOURCE:
                if (mWebViewClient != null) {
                    mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
                }
                break;

            case DOWNLOAD_FILE:
                if (mDownloadListener != null) {
                    String url = msg.getData().getString("url");
                    String userAgent = msg.getData().getString("userAgent");
                    String contentDisposition =
                        msg.getData().getString("contentDisposition");
                    String mimetype = msg.getData().getString("mimetype");
                    String referer = msg.getData().getString("referer");
                    Long contentLength = msg.getData().getLong("contentLength");

                    if (mDownloadListener instanceof BrowserDownloadListener) {
                        ((BrowserDownloadListener) mDownloadListener).onDownloadStart(url,
                             userAgent, contentDisposition, mimetype, referer, contentLength);
                    } else {
                        mDownloadListener.onDownloadStart(url, userAgent,
                             contentDisposition, mimetype, contentLength);
                    }
                }
                break;

            case CREATE_WINDOW:
                if (mWebChromeClient != null) {
                    if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),
                                msg.arg1 == 1, msg.arg2 == 1,
                                (Message) msg.obj)) {
                        synchronized (this) {
                            notify();
                        }
                    }
                    mWebView.dismissZoomControl();
                }
                break;

            case REQUEST_FOCUS:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onRequestFocus(mWebView.getWebView());
                }
                break;

            case CLOSE_WINDOW:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
                }
                break;

            case SAVE_PASSWORD:
                Bundle bundle = msg.getData();
                String schemePlusHost = bundle.getString("host");
                String username = bundle.getString("username");
                String password = bundle.getString("password");
                // If the client returned false it means that the notify message
                // will not be sent and we should notify WebCore ourselves.
                if (!mWebView.onSavePassword(schemePlusHost, username, password,
                            (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                break;

            case ASYNC_KEYEVENTS:
                if (mWebViewClient != null) {
                    mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),
                            (KeyEvent) msg.obj);
                }
                break;

            case EXCEEDED_DATABASE_QUOTA:
                if (mWebChromeClient != null) {
                    HashMap<String, Object> map =
                            (HashMap<String, Object>) msg.obj;
                    String databaseIdentifier =
                            (String) map.get("databaseIdentifier");
                    String url = (String) map.get("url");
                    long quota =
                            ((Long) map.get("quota")).longValue();
                    long totalQuota =
                            ((Long) map.get("totalQuota")).longValue();
                    long estimatedDatabaseSize =
                            ((Long) map.get("estimatedDatabaseSize")).longValue();
                    WebStorage.QuotaUpdater quotaUpdater =
                        (WebStorage.QuotaUpdater) map.get("quotaUpdater");

                    mWebChromeClient.onExceededDatabaseQuota(url,
                            databaseIdentifier, quota, estimatedDatabaseSize,
                            totalQuota, quotaUpdater);
                }
                break;

            case REACHED_APPCACHE_MAXSIZE:
                if (mWebChromeClient != null) {
                    HashMap<String, Object> map =
                            (HashMap<String, Object>) msg.obj;
                    long requiredStorage =
                            ((Long) map.get("requiredStorage")).longValue();
                    long quota =
                        ((Long) map.get("quota")).longValue();
                    WebStorage.QuotaUpdater quotaUpdater =
                        (WebStorage.QuotaUpdater) map.get("quotaUpdater");

                    mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,
                            quota, quotaUpdater);
                }
                break;

            case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
                if (mWebChromeClient != null) {
                    HashMap<String, Object> map =
                            (HashMap<String, Object>) msg.obj;
                    String origin = (String) map.get("origin");
                    GeolocationPermissions.Callback callback =
                            (GeolocationPermissions.Callback)
                            map.get("callback");
                    mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,
                            callback);
                }
                break;

            case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
                if (mWebChromeClient != null) {
                    mWebChromeClient.onGeolocationPermissionsHidePrompt();
                }
                break;

            case JS_ALERT:
                if (mWebChromeClient != null) {
                    final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                    final JsResult res = receiver.mJsResult;
                    String message = msg.getData().getString("message");
                    String url = msg.getData().getString("url");
                    if (!mWebChromeClient.onJsAlert(mWebView.getWebView(), url, message,
                            res)) {
                        if (!canShowAlertDialog()) {
                            res.cancel();
                            receiver.setReady();
                            break;
                        }
                        new AlertDialog.Builder(mContext)
                                .setTitle(getJsDialogTitle(url))
                                .setMessage(message)
                                .setPositiveButton(R.string.ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int which) {
                                                res.confirm();
                                            }
                                        })
                                .setOnCancelListener(
                                        new DialogInterface.OnCancelListener() {
                                            public void onCancel(
                                                    DialogInterface dialog) {
                                                res.cancel();
                                            }
                                        })
                                .show();
                    }
                    receiver.setReady();
                }
                break;

            case JS_CONFIRM:
                if (mWebChromeClient != null) {
                    final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                    final JsResult res = receiver.mJsResult;
                    String message = msg.getData().getString("message");
                    String url = msg.getData().getString("url");
                    if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(), url, message,
                            res)) {
                        if (!canShowAlertDialog()) {
                            res.cancel();
                            receiver.setReady();
                            break;
                        }
                        new AlertDialog.Builder(mContext)
                                .setTitle(getJsDialogTitle(url))
                                .setMessage(message)
                                .setPositiveButton(R.string.ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int which) {
                                                res.confirm();
                                            }})
                                .setNegativeButton(R.string.cancel,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int which) {
                                                res.cancel();
                                            }})
                                .setOnCancelListener(
                                        new DialogInterface.OnCancelListener() {
                                            public void onCancel(
                                                    DialogInterface dialog) {
                                                res.cancel();
                                            }
                                        })
                                .show();
                    }
                    // Tell the JsResult that it is ready for client
                    // interaction.
                    receiver.setReady();
                }
                break;

            case JS_PROMPT:
                if (mWebChromeClient != null) {
                    final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                    final JsPromptResult res = receiver.mJsResult;
                    String message = msg.getData().getString("message");
                    String defaultVal = msg.getData().getString("default");
                    String url = msg.getData().getString("url");
                    if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(), url, message,
                                defaultVal, res)) {
                        if (!canShowAlertDialog()) {
                            res.cancel();
                            receiver.setReady();
                            break;
                        }
                        final LayoutInflater factory = LayoutInflater
                                .from(mContext);
                        final View view = factory.inflate(R.layout.js_prompt,
                                null);
                        final EditText v = (EditText) view
                                .findViewById(R.id.value);
                        v.setText(defaultVal);
                        ((TextView) view.findViewById(R.id.message))
                                .setText(message);
                        new AlertDialog.Builder(mContext)
                                .setTitle(getJsDialogTitle(url))
                                .setView(view)
                                .setPositiveButton(R.string.ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int whichButton) {
                                                res.confirm(v.getText()
                                                        .toString());
                                            }
                                        })
                                .setNegativeButton(R.string.cancel,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int whichButton) {
                                                res.cancel();
                                            }
                                        })
                                .setOnCancelListener(
                                        new DialogInterface.OnCancelListener() {
                                            public void onCancel(
                                                    DialogInterface dialog) {
                                                res.cancel();
                                            }
                                        })
                                .show();
                    }
                    // Tell the JsResult that it is ready for client
                    // interaction.
                    receiver.setReady();
                }
                break;

            case JS_UNLOAD:
                if (mWebChromeClient != null) {
                    final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                    final JsResult res = receiver.mJsResult;
                    String message = msg.getData().getString("message");
                    String url = msg.getData().getString("url");
                    if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(), url,
                            message, res)) {
                        if (!canShowAlertDialog()) {
                            res.cancel();
                            receiver.setReady();
                            break;
                        }
                        final String m = mContext.getString(
                                R.string.js_dialog_before_unload, message);
                        new AlertDialog.Builder(mContext)
                                .setMessage(m)
                                .setPositiveButton(R.string.ok,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int which) {
                                                res.confirm();
                                            }
                                        })
                                .setNegativeButton(R.string.cancel,
                                        new DialogInterface.OnClickListener() {
                                            public void onClick(
                                                    DialogInterface dialog,
                                                    int which) {
                                                res.cancel();
                                            }
                                        })
                                .setOnCancelListener(
                                        new DialogInterface.OnCancelListener() {
                                            @Override
                                            public void onCancel(
                                                    DialogInterface dialog) {
                                                res.cancel();
                                            }
                                        })
                                .show();
                    }
                    receiver.setReady();
                }
                break;

            case JS_TIMEOUT:
                if(mWebChromeClient != null) {
                    final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                    final JsResult res = receiver.mJsResult;
                    if(mWebChromeClient.onJsTimeout()) {
                        res.confirm();
                    } else {
                        res.cancel();
                    }
                    receiver.setReady();
                }
                break;

            case RECEIVED_CERTIFICATE:
                mWebView.setCertificate((SslCertificate) msg.obj);
                break;

            case NOTIFY:
                synchronized (this) {
                    notify();
                }
                break;

            case SCALE_CHANGED:
                if (mWebViewClient != null) {
                    mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData()
                            .getFloat("old"), msg.getData().getFloat("new"));
                }
                break;

            case SWITCH_OUT_HISTORY:
                mWebView.switchOutDrawHistory();
                break;

            case ADD_MESSAGE_TO_CONSOLE:
                if (mWebChromeClient == null) {
                    break;
                }
                String message = msg.getData().getString("message");
                String sourceID = msg.getData().getString("sourceID");
                int lineNumber = msg.getData().getInt("lineNumber");
                int msgLevel = msg.getData().getInt("msgLevel");
                int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
                // Sanity bounds check as we'll index an array with msgLevel
                if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                    msgLevel = 0;
                }

                ConsoleMessage.MessageLevel messageLevel =
                        ConsoleMessage.MessageLevel.values()[msgLevel];

                if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID,
                        lineNumber, messageLevel))) {
                    // If false was returned the user did not provide their own console function so
                    //  we should output some default messages to the system log.
                    String logTag = "Web Console";
                    String logMessage = message + " at " + sourceID + ":" + lineNumber;

                    switch (messageLevel) {
                        case TIP:
                            Log.v(logTag, logMessage);
                            break;
                        case LOG:
                            Log.i(logTag, logMessage);
                            break;
                        case WARNING:
                            Log.w(logTag, logMessage);
                            break;
                        case ERROR:
                            Log.e(logTag, logMessage);
                            break;
                        case DEBUG:
                            Log.d(logTag, logMessage);
                            break;
                    }
                }

                break;

            case GET_VISITED_HISTORY:
                if (mWebChromeClient != null) {
                    mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
                }
                break;

            case OPEN_FILE_CHOOSER:
                if (mWebChromeClient != null) {
                    UploadFileMessageData data = (UploadFileMessageData)msg.obj;
                    mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(),
                            data.getCapture());
                }
                break;

            case ADD_HISTORY_ITEM:
                if (mWebBackForwardListClient != null) {
                    mWebBackForwardListClient.onNewHistoryItem(
                            (WebHistoryItem) msg.obj);
                }
                break;

            case HISTORY_INDEX_CHANGED:
                if (mWebBackForwardListClient != null) {
                    mWebBackForwardListClient.onIndexChanged(
                            (WebHistoryItem) msg.obj, msg.arg1);
                }
                break;
            case AUTH_CREDENTIALS: {
                String host = msg.getData().getString("host");
                String realm = msg.getData().getString("realm");
                username = msg.getData().getString("username");
                password = msg.getData().getString("password");
                mWebView.setHttpAuthUsernamePassword(
                        host, realm, username, password);
                break;
            }
            case AUTO_LOGIN: {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString("realm");
                    String account = msg.getData().getString("account");
                    String args = msg.getData().getString("args");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm,
                            account, args);
                }
                break;
            }
        }
!!!4823052.java!!!	getProgress() : int
        return mLatestProgress;
!!!4823180.java!!!	switchOutDrawHistory() : void
        sendMessage(obtainMessage(SWITCH_OUT_HISTORY));
!!!4823308.java!!!	getJsDialogTitle(in url : String) : String
        String title = url;
        if (URLUtil.isDataUrl(url)) {
            // For data: urls, we just display 'JavaScript' similar to Safari.
            title = mContext.getString(R.string.js_dialog_title_default);
        } else {
            try {
                URL aUrl = new URL(url);
                // For example: "The page at 'http://www.mit.edu' says:"
                title = mContext.getString(R.string.js_dialog_title,
                        aUrl.getProtocol() + "://" + aUrl.getHost());
            } catch (MalformedURLException ex) {
                // do nothing. just use the url as the title
            }
        }
        return title;
!!!4823436.java!!!	onPageStarted(in url : String, inout favicon : Bitmap) : void
        // We need to send the message even if no WebViewClient is set, because we need to call
        // WebView.onPageStarted().

        // Performance probe
        if (PERF_PROBE) {
            mWebCoreThreadTime = SystemClock.currentThreadTimeMillis();
            mWebCoreIdleTime = 0;
            // un-comment this if PERF_PROBE is true
//            Looper.myQueue().setWaitCallback(mIdleCallback);
        }
        Message msg = obtainMessage(PAGE_STARTED);
        msg.obj = favicon;
        msg.getData().putString("url", url);
        sendMessage(msg);
!!!4823564.java!!!	onPageFinished(in url : String) : void
        // Performance probe
        if (PERF_PROBE) {
            // un-comment this if PERF_PROBE is true
//            Looper.myQueue().setWaitCallback(null);
            Log.d("WebCore", "WebCore thread used " +
                    (SystemClock.currentThreadTimeMillis() - mWebCoreThreadTime)
                    + " ms and idled " + mWebCoreIdleTime + " ms");
        }
        Message msg = obtainMessage(PAGE_FINISHED, url);
        sendMessage(msg);
!!!4823692.java!!!	onTooManyRedirects(inout cancelMsg : Message, inout continueMsg : Message) : void
        // deprecated.
!!!4823820.java!!!	onReceivedError(in errorCode : int, in description : String, in failingUrl : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            return;
        }

        Message msg = obtainMessage(REPORT_ERROR);
        msg.arg1 = errorCode;
        msg.getData().putString("description", description);
        msg.getData().putString("failingUrl", failingUrl);
        sendMessage(msg);
!!!4823948.java!!!	onFormResubmission(inout dontResend : Message, inout resend : Message) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            dontResend.sendToTarget();
            return;
        }

        Message msg = obtainMessage(RESEND_POST_DATA);
        Bundle bundle = msg.getData();
        bundle.putParcelable("resend", resend);
        bundle.putParcelable("dontResend", dontResend);
        sendMessage(msg);
!!!4824076.java!!!	shouldOverrideUrlLoading(in url : String) : boolean
        // We have a default behavior if no client exists so always send the
        // message.
        ResultTransport<Boolean> res = new ResultTransport<Boolean>(false);
        Message msg = obtainMessage(OVERRIDE_URL);
        msg.getData().putString("url", url);
        msg.obj = res;
        sendMessageToUiThreadSync(msg);
        return res.getResult().booleanValue();
!!!4824204.java!!!	onReceivedHttpAuthRequest(inout handler : HttpAuthHandler, in hostName : String, in realmName : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            handler.cancel();
            return;
        }
        Message msg = obtainMessage(AUTH_REQUEST, handler);
        msg.getData().putString("host", hostName);
        msg.getData().putString("realm", realmName);
        sendMessage(msg);
!!!4824332.java!!!	onReceivedSslError(inout handler : SslErrorHandler, inout error : SslError) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            handler.cancel();
            return;
        }
        Message msg = obtainMessage(SSL_ERROR);
        HashMap<String, Object> map = new HashMap();
        map.put("handler", handler);
        map.put("error", error);
        msg.obj = map;
        sendMessage(msg);
!!!4824460.java!!!	onProceededAfterSslError(inout error : SslError) : void
        if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
            return;
        }
        Message msg = obtainMessage(PROCEEDED_AFTER_SSL_ERROR);
        msg.obj = error;
        sendMessage(msg);
!!!4824588.java!!!	onReceivedClientCertRequest(inout handler : ClientCertRequestHandler, in host_and_port : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
            handler.cancel();
            return;
        }
        Message msg = obtainMessage(CLIENT_CERT_REQUEST);
        HashMap<String, Object> map = new HashMap();
        map.put("handler", handler);
        map.put("host_and_port", host_and_port);
        msg.obj = map;
        sendMessage(msg);
!!!4824716.java!!!	onReceivedCertificate(inout certificate : SslCertificate) : void
        // here, certificate can be null (if the site is not secure)
        sendMessage(obtainMessage(RECEIVED_CERTIFICATE, certificate));
!!!4824844.java!!!	doUpdateVisitedHistory(in url : String, inout isReload : boolean) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            return;
        }
        sendMessage(obtainMessage(UPDATE_VISITED, isReload ? 1 : 0, 0, url));
!!!4824972.java!!!	shouldInterceptRequest(in url : String) : WebResourceResponse
        if (mWebViewClient == null) {
            return null;
        }
        // Note: This method does _not_ send a message.
        WebResourceResponse r =
                mWebViewClient.shouldInterceptRequest(mWebView.getWebView(), url);
        if (r == null) {
            sendMessage(obtainMessage(LOAD_RESOURCE, url));
        }
        return r;
!!!4825100.java!!!	onUnhandledKeyEvent(inout event : KeyEvent) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            return;
        }
        sendMessage(obtainMessage(ASYNC_KEYEVENTS, event));
!!!4825228.java!!!	onScaleChanged(in oldScale : float, in newScale : float) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            return;
        }
        Message msg = obtainMessage(SCALE_CHANGED);
        Bundle bundle = msg.getData();
        bundle.putFloat("old", oldScale);
        bundle.putFloat("new", newScale);
        sendMessage(msg);
!!!4825356.java!!!	onReceivedLoginRequest(in realm : String, in account : String, in args : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebViewClient == null) {
            return;
        }
        Message msg = obtainMessage(AUTO_LOGIN);
        Bundle bundle = msg.getData();
        bundle.putString("realm", realm);
        bundle.putString("account", account);
        bundle.putString("args", args);
        sendMessage(msg);
!!!4825484.java!!!	onDownloadStart(in url : String, in userAgent : String, in contentDisposition : String, in mimetype : String, in referer : String, in contentLength : long) : boolean
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mDownloadListener == null) {
            // Cancel the download if there is no browser client.
            return false;
        }

        Message msg = obtainMessage(DOWNLOAD_FILE);
        Bundle bundle = msg.getData();
        bundle.putString("url", url);
        bundle.putString("userAgent", userAgent);
        bundle.putString("mimetype", mimetype);
        bundle.putString("referer", referer);
        bundle.putLong("contentLength", contentLength);
        bundle.putString("contentDisposition", contentDisposition);
        sendMessage(msg);
        return true;
!!!4825612.java!!!	onSavePassword(in schemePlusHost : String, in username : String, in password : String, inout resumeMsg : Message) : boolean
        // resumeMsg should be null at this point because we want to create it
        // within the CallbackProxy.
        if (DebugFlags.CALLBACK_PROXY) {
            junit.framework.Assert.assertNull(resumeMsg);
        }
        resumeMsg = obtainMessage(NOTIFY);

        Message msg = obtainMessage(SAVE_PASSWORD, resumeMsg);
        Bundle bundle = msg.getData();
        bundle.putString("host", schemePlusHost);
        bundle.putString("username", username);
        bundle.putString("password", password);
        sendMessageToUiThreadSync(msg);
        // Doesn't matter here
        return false;
!!!4825740.java!!!	onReceivedHttpAuthCredentials(in host : String, in realm : String, in username : String, in password : String) : void
        Message msg = obtainMessage(AUTH_CREDENTIALS);
        msg.getData().putString("host", host);
        msg.getData().putString("realm", realm);
        msg.getData().putString("username", username);
        msg.getData().putString("password", password);
        sendMessage(msg);
!!!4825868.java!!!	onProgressChanged(in newProgress : int) : void
        // Synchronize so that mLatestProgress is up-to-date.
        synchronized (this) {
            // update mLatestProgress even mWebChromeClient is null as
            // WebView.getProgress() needs it
            if (mLatestProgress == newProgress) {
                return;
            }
            mLatestProgress = newProgress;
            if (mWebChromeClient == null) {
                return;
            }
            if (!mProgressUpdatePending) {
                sendEmptyMessage(PROGRESS);
                mProgressUpdatePending = true;
            }
        }
!!!4825996.java!!!	createWindow(inout dialog : boolean, inout userGesture : boolean) : BrowserFrame
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return null;
        }

        WebView.WebViewTransport transport =
            mWebView.getWebView().new WebViewTransport();
        final Message msg = obtainMessage(NOTIFY);
        msg.obj = transport;
        sendMessageToUiThreadSync(obtainMessage(CREATE_WINDOW, dialog ? 1 : 0,
                userGesture ? 1 : 0, msg));
        WebViewClassic w = WebViewClassic.fromWebView(transport.getWebView());
        if (w != null) {
            WebViewCore core = w.getWebViewCore();
            // If WebView.destroy() has been called, core may be null.  Skip
            // initialization in that case and return null.
            if (core != null) {
                core.initializeSubwindow();
                return core.getBrowserFrame();
            }
        }
        return null;
!!!4826124.java!!!	onRequestFocus() : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }

        sendEmptyMessage(REQUEST_FOCUS);
!!!4826252.java!!!	onCloseWindow(inout window : WebViewClassic) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }
        sendMessage(obtainMessage(CLOSE_WINDOW, window));
!!!4826380.java!!!	onReceivedIcon(inout icon : Bitmap) : void
        // The current item might be null if the icon was already stored in the
        // database and this is a new WebView.
        WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
        if (i != null) {
            i.setFavicon(icon);
        }
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }
        sendMessage(obtainMessage(RECEIVED_ICON, icon));
!!!4826508.java!!!	onReceivedTouchIconUrl(in url : String, inout precomposed : boolean) : void
        // We should have a current item but we do not want to crash so check
        // for null.
        WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
        if (i != null) {
            i.setTouchIconUrl(url, precomposed);
        }
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }
        sendMessage(obtainMessage(RECEIVED_TOUCH_ICON_URL,
                precomposed ? 1 : 0, 0, url));
!!!4826636.java!!!	onReceivedTitle(in title : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }
        sendMessage(obtainMessage(RECEIVED_TITLE, title));
!!!4826764.java!!!	onJsAlert(in url : String, in message : String) : void
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return;
        }
        JsResultReceiver result = new JsResultReceiver();
        Message alert = obtainMessage(JS_ALERT, result);
        alert.getData().putString("message", message);
        alert.getData().putString("url", url);
        sendMessageToUiThreadSync(alert);
!!!4826892.java!!!	onJsConfirm(in url : String, in message : String) : boolean
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return false;
        }
        JsResultReceiver result = new JsResultReceiver();
        Message confirm = obtainMessage(JS_CONFIRM, result);
        confirm.getData().putString("message", message);
        confirm.getData().putString("url", url);
        sendMessageToUiThreadSync(confirm);
        return result.mJsResult.getResult();
!!!4827020.java!!!	onJsPrompt(in url : String, in message : String, in defaultValue : String) : String
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return null;
        }
        JsResultReceiver result = new JsResultReceiver();
        Message prompt = obtainMessage(JS_PROMPT, result);
        prompt.getData().putString("message", message);
        prompt.getData().putString("default", defaultValue);
        prompt.getData().putString("url", url);
        sendMessageToUiThreadSync(prompt);
        return result.mJsResult.getStringResult();
!!!4827148.java!!!	onJsBeforeUnload(in url : String, in message : String) : boolean
        // Do an unsynchronized quick check to avoid posting if no callback has
        // been set.
        if (mWebChromeClient == null) {
            return true;
        }
        JsResultReceiver result = new JsResultReceiver();
        Message confirm = obtainMessage(JS_UNLOAD, result);
        confirm.getData().putString("message", message);
        confirm.getData().putString("url", url);
        sendMessageToUiThreadSync(confirm);
        return result.mJsResult.getResult();
!!!4827276.java!!!	onExceededDatabaseQuota(in url : String, in databaseIdentifier : String, in quota : long, in estimatedDatabaseSize : long, in totalQuota : long, inout quotaUpdater : QuotaUpdater) : void
        if (mWebChromeClient == null) {
            // Native-side logic prevents the quota being updated to a smaller
            // value.
            quotaUpdater.updateQuota(quota);
            return;
        }

        Message exceededQuota = obtainMessage(EXCEEDED_DATABASE_QUOTA);
        HashMap<String, Object> map = new HashMap();
        map.put("databaseIdentifier", databaseIdentifier);
        map.put("url", url);
        map.put("quota", quota);
        map.put("estimatedDatabaseSize", estimatedDatabaseSize);
        map.put("totalQuota", totalQuota);
        map.put("quotaUpdater", quotaUpdater);
        exceededQuota.obj = map;
        sendMessage(exceededQuota);
!!!4827404.java!!!	onReachedMaxAppCacheSize(in requiredStorage : long, in quota : long, inout quotaUpdater : QuotaUpdater) : void
        if (mWebChromeClient == null) {
            // Native-side logic prevents the quota being updated to a smaller
            // value.
            quotaUpdater.updateQuota(quota);
            return;
        }

        Message msg = obtainMessage(REACHED_APPCACHE_MAXSIZE);
        HashMap<String, Object> map = new HashMap();
        map.put("requiredStorage", requiredStorage);
        map.put("quota", quota);
        map.put("quotaUpdater", quotaUpdater);
        msg.obj = map;
        sendMessage(msg);
!!!4827532.java!!!	onGeolocationPermissionsShowPrompt(in origin : String, inout callback : Callback) : void
        if (mWebChromeClient == null) {
            return;
        }

        Message showMessage =
                obtainMessage(GEOLOCATION_PERMISSIONS_SHOW_PROMPT);
        HashMap<String, Object> map = new HashMap();
        map.put("origin", origin);
        map.put("callback", callback);
        showMessage.obj = map;
        sendMessage(showMessage);
!!!4827660.java!!!	onGeolocationPermissionsHidePrompt() : void
        if (mWebChromeClient == null) {
            return;
        }

        Message hideMessage = obtainMessage(GEOLOCATION_PERMISSIONS_HIDE_PROMPT);
        sendMessage(hideMessage);
!!!4827788.java!!!	addMessageToConsole(in message : String, in lineNumber : int, in sourceID : String, in msgLevel : int) : void
        if (mWebChromeClient == null) {
            return;
        }

        Message msg = obtainMessage(ADD_MESSAGE_TO_CONSOLE);
        msg.getData().putString("message", message);
        msg.getData().putString("sourceID", sourceID);
        msg.getData().putInt("lineNumber", lineNumber);
        msg.getData().putInt("msgLevel", msgLevel);
        sendMessage(msg);
!!!4827916.java!!!	onJsTimeout() : boolean
        //always interrupt timedout JS by default
        if (mWebChromeClient == null) {
            return true;
        }
        JsResultReceiver result = new JsResultReceiver();
        Message timeout = obtainMessage(JS_TIMEOUT, result);
        sendMessageToUiThreadSync(timeout);
        return result.mJsResult.getResult();
!!!4828044.java!!!	getVisitedHistory(inout callback : ValueCallback) : void
        if (mWebChromeClient == null) {
            return;
        }
        Message msg = obtainMessage(GET_VISITED_HISTORY);
        msg.obj = callback;
        sendMessage(msg);
!!!4829068.java!!!	openFileChooser(in acceptType : String, in capture : String) : Uri
        if (mWebChromeClient == null) {
            return null;
        }
        Message myMessage = obtainMessage(OPEN_FILE_CHOOSER);
        UploadFile uploadFile = new UploadFile();
        UploadFileMessageData data = new UploadFileMessageData(uploadFile, acceptType, capture);
        myMessage.obj = data;
        sendMessageToUiThreadSync(myMessage);
        return uploadFile.getResult();
!!!4829196.java!!!	onNewHistoryItem(inout item : WebHistoryItem) : void
        if (mWebBackForwardListClient == null) {
            return;
        }
        Message msg = obtainMessage(ADD_HISTORY_ITEM, item);
        sendMessage(msg);
!!!4829324.java!!!	onIndexChanged(inout item : WebHistoryItem, in index : int) : void
        if (mWebBackForwardListClient == null) {
            return;
        }
        Message msg = obtainMessage(HISTORY_INDEX_CHANGED, index, 0, item);
        sendMessage(msg);
!!!4829452.java!!!	canShowAlertDialog() : boolean
        // We can only display the alert dialog if mContext is
        // an Activity context.
        // FIXME: Should we display dialogs if mContext does
        // not have the window focus (e.g. if the user is viewing
        // another Activity when the alert should be displayed?
        // See bug 3166409
        return mContext instanceof Activity;
!!!4829580.java!!!	sendMessageToUiThreadSync(inout msg : Message) : void
        sendMessage(msg);
        WebCoreThreadWatchdog.pause();
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, "Caught exception waiting for synchronous UI message to be processed");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
        WebCoreThreadWatchdog.resume();
