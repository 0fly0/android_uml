class OmxAmpAudioDecoder
!!!11090572.cpp!!!	OmxAmpAudioDecoder(in name : OMX_STRING)
  strncpy(mName, name, OMX_MAX_STRINGNAME_SIZE);
  mMark.hMarkTargetComponent = NULL;
  mMark.pMarkData = NULL;
  mCodecSpecficDataSent = OMX_FALSE;
  mShouldExit = OMX_FALSE;
  mInputFrameNum = 0;
  mOutputFrameNum = 0;
  mInBDBackNum = 0;
  mOutBDPushNum = 0;
  mStreamPosition = 0;
  mInited = OMX_FALSE;
  mOutputEOS = OMX_FALSE;
  mTimeStampUs = -1;
  mPaused = OMX_FALSE;
  mAudioDrm = OMX_FALSE;
  mDMXHandle = NULL;
  mAudioLength = 0;
  mDrm_type = 0;
  mSchemeIdSend = OMX_FALSE;
  mhInputBuf = NULL;
  mOutputConfigured = OMX_FALSE;
  mOutputConfigChanged = OMX_FALSE;
  mOutputConfigInit = OMX_FALSE;
  mPassthru = OMX_FALSE;
  mPassthru_wait = OMX_FALSE;
  mSourceControl = NULL;
  mListener = NULL,
  mSourceId = -1;
  mAudioChannel = -1;
  mPhyDRCMode = -1;
  mPhyChmap = -1;
  mStereoMode = -1;
  mDualMode = -1;
  mPool = NULL;
  mPushedBdNum = 0;
  mReturnedBdNum = 0;
  mCachedhead = NULL;
!!!11090700.cpp!!!	~OmxAmpAudioDecoder()
  OMX_LOGD("destroyed");
!!!11090828.cpp!!!	componentDeInit(in hComponent : OMX_HANDLETYPE) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OmxComponent *comp = reinterpret_cast<OmxComponent *>(
      reinterpret_cast<OMX_COMPONENTTYPE *>(hComponent)->pComponentPrivate);
  OmxAmpAudioDecoder *adec = static_cast<OmxAmpAudioDecoder *>(comp);
  delete adec;
  return OMX_ErrorNone;
!!!11091084.cpp!!!	setParameter(in index : OMX_INDEXTYPE, in params : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;
  switch (index) {
    case OMX_IndexParamAudioPortFormat: {
      OMX_AUDIO_PARAM_PORTFORMATTYPE* audio_param =
          reinterpret_cast<OMX_AUDIO_PARAM_PORTFORMATTYPE*>(params);
      err = CheckOmxHeader(audio_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(audio_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio) {
        if (isAudioParamSupport(audio_param)) {
          port->setAudioParam(audio_param);
          port->updateDomainDefinition();
        } else {
          // @todo find a proper error NO.
          err = OMX_ErrorNotImplemented;
        }
      }
      break;
    }
    case OMX_IndexParamAudioAac: {
      OMX_AUDIO_PARAM_AACPROFILETYPE* aacParams =
          reinterpret_cast<OMX_AUDIO_PARAM_AACPROFILETYPE*>(params);
      err = CheckOmxHeader(aacParams);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(aacParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingAAC) {
        static_cast<OmxAmpAacPort*>(port)->setCodecParam(aacParams);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            aacParams->nSampleRate, aacParams->nChannels);
      }
      break;
    }
#ifdef OMX_IndexExt_h
    case OMX_IndexParamAudioMp1: {
      OMX_AUDIO_PARAM_MP1TYPE* codec_param =
          reinterpret_cast<OMX_AUDIO_PARAM_MP1TYPE*>(params);
      err = CheckOmxHeader(codec_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(codec_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingMP1) {
        static_cast<OmxAmpMp1Port*>(port)->setCodecParam(codec_param);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            codec_param->nSampleRate, codec_param->nChannels);
      }
      break;
    }
    case OMX_IndexParamAudioMp2: {
      OMX_AUDIO_PARAM_MP2TYPE* codec_param =
          reinterpret_cast<OMX_AUDIO_PARAM_MP2TYPE*>(params);
      err = CheckOmxHeader(codec_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(codec_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingMP2) {
        static_cast<OmxAmpMp2Port*>(port)->setCodecParam(codec_param);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            codec_param->nSampleRate, codec_param->nChannels);
      }
      break;
    }
    case OMX_IndexParamAudioMp3: {
      OMX_AUDIO_PARAM_MP3TYPE* codec_param =
          reinterpret_cast<OMX_AUDIO_PARAM_MP3TYPE*>(params);
      err = CheckOmxHeader(codec_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(codec_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingMP3) {
        static_cast<OmxAmpMp3Port*>(port)->setCodecParam(codec_param);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            codec_param->nSampleRate, codec_param->nChannels);
      }
      break;
    }
    case OMX_IndexParamAudioAc3: {
      OMX_AUDIO_PARAM_AC3TYPE* ac3Params =
          reinterpret_cast<OMX_AUDIO_PARAM_AC3TYPE*>(params);
      err = CheckOmxHeader(ac3Params);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(ac3Params->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingAC3) {
        static_cast<OmxAmpAc3Port*>(port)->setCodecParam(ac3Params);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            ac3Params->nSampleRate, ac3Params->nChannels);
      }
      // it's ac3, need build passthru pipeline
      mPassthru = OMX_TRUE;
      // set aren passthru
      if (mOutputPort != NULL) {
        if (mOutputPort->isTunneled()) {
          OmxComponentImpl *aren = static_cast<OmxComponentImpl *>(
              static_cast<OMX_COMPONENTTYPE *>(
              mOutputPort->getTunnelComponent())->pComponentPrivate);
          if (NULL != aren && NULL != strstr(aren->mName, "audio_renderer")) {
            OMX_LOGD("set aren passthru mode");
            static_cast<OmxAmpAudioRenderer *>(aren)->setPassThruMode();
          } else {
            mPassthru_wait = OMX_TRUE;
            OMX_LOGD("delay to set aren passthru mode");
          }
        } else {
          mPassthru_wait = OMX_TRUE;
          OMX_LOGD("delay to set aren passthru mode line %d", __LINE__);
        }
      }
      break;
    }
    case OMX_IndexParamAudioDts: {
      OMX_AUDIO_PARAM_DTSTYPE* dtsParams =
          reinterpret_cast<OMX_AUDIO_PARAM_DTSTYPE*>(params);
      err = CheckOmxHeader(dtsParams);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(dtsParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingDTS) {
        static_cast<OmxAmpDtsPort*>(port)->setCodecParam(dtsParams);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            dtsParams->nSampleRate, dtsParams->nChannels);
      }
      break;
    }
#endif
    case OMX_IndexParamAudioVorbis: {
      OMX_AUDIO_PARAM_VORBISTYPE* vorbisParams =
          reinterpret_cast<OMX_AUDIO_PARAM_VORBISTYPE*>(params);
      err = CheckOmxHeader(vorbisParams);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(vorbisParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingVORBIS) {
        static_cast<OmxAmpVorbisPort*>(port)->setCodecParam(vorbisParams);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            vorbisParams->nSampleRate, vorbisParams->nChannels);
      }
      break;
    }
    case OMX_IndexParamAudioPcm: {
      OMX_AUDIO_PARAM_PCMMODETYPE* pcmParams =
          reinterpret_cast<OMX_AUDIO_PARAM_PCMMODETYPE*>(params);
      OMX_LOGD("port index %d", pcmParams->nPortIndex);
      /* As issue https://code.google.com/p/google-tv/issues/detail?id=6050#c8
           * OpenMax 1.1 and 1.2 difference, the ->nSize is differenct
           * OMX_AUDIO_MAXCHANNELS is not the same : 16 vs 36
           * so do not check header size here.
           */
      /* err = CheckOmxHeader(pcmParams);
          if (OMX_ErrorNone != err) {
            OMX_LOGD("line %d\n", __LINE__);
            break;
          }
          */
      OmxPortImpl* port = getPort(pcmParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingPCM) {
        if (pcmParams->nPortIndex == kAudioPortStartNumber) {
          static_cast<OmxAmpPcmPort*>(port)->setCodecParam(pcmParams);
          (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
              pcmParams->nSamplingRate);
        } else if (pcmParams->nPortIndex == (kAudioPortStartNumber + 1)) {
          static_cast<OmxAmpAudioPort*>(port)->setPcmOutParam(pcmParams);
        } else {
          OMX_LOGE("Error pcm port index %d", pcmParams->nPortIndex);
        }
      }
      break;
    }
    case OMX_IndexParamAudioWma: {
      OMX_AUDIO_PARAM_WMATYPE* wmaParams =
          reinterpret_cast<OMX_AUDIO_PARAM_WMATYPE*>(params);
      err = CheckOmxHeader(wmaParams);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(wmaParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingWMA) {
        static_cast<OmxAmpWmaPort*>(port)->setCodecParam(wmaParams);
        (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
            wmaParams->nSamplingRate, wmaParams->nChannels);
      }
      break;
    }
    case OMX_IndexParamAudioAmr: {
      OMX_AUDIO_PARAM_AMRTYPE* amrParams =
          reinterpret_cast<OMX_AUDIO_PARAM_AMRTYPE*>(params);
      err = CheckOmxHeader(amrParams);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(amrParams->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingAMR) {
        static_cast<OmxAmpAmrPort*>(port)->setCodecParam(amrParams);
        // TODO:: Amr has no sample rate property now
        // (static_cast<OmxAmpAudioPort *>(mOutputPort))->SetOutputParameter(
        //    amrParams->nSamplingRate);
      }
      break;
    }
    default:
      return OmxComponentImpl::setParameter(index, params);
  }
  return err;
!!!11091212.cpp!!!	initPort() : OMX_ERRORTYPE
  OMX_LOGD("initPort");
  OMX_ERRORTYPE err = OMX_ErrorNone;
  if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_AAC_SECURE,
      OMX_ROLE_AUDIO_DECODER_AAC_SECURE_LEN)) {
    mInputPort = new OmxAmpAacPort(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_AAC,
      OMX_ROLE_AUDIO_DECODER_AAC_LEN)) {
    mInputPort = new OmxAmpAacPort(kAudioPortStartNumber, OMX_DirInput);
  }
#ifdef OMX_AudioExt_h
  else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_MP1,
      OMX_ROLE_AUDIO_DECODER_MP1_LEN)) {
    mInputPort = new OmxAmpMp1Port(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_MP2,
      OMX_ROLE_AUDIO_DECODER_MP2_LEN)) {
    mInputPort = new OmxAmpMp2Port(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_AC3_SECURE,
      OMX_ROLE_AUDIO_DECODER_AC3_SECURE_LEN)) {
    mInputPort = new OmxAmpAc3Port(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_AC3,
      OMX_ROLE_AUDIO_DECODER_AC3_LEN)) {
    mInputPort = new OmxAmpAc3Port(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_DTS,
      OMX_ROLE_AUDIO_DECODER_DTS_LEN)) {
    mInputPort = new OmxAmpDtsPort(kAudioPortStartNumber, OMX_DirInput);
  }
#endif
    else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_MP3,
      OMX_ROLE_AUDIO_DECODER_MP3_LEN)) {
    mInputPort = new OmxAmpMp3Port(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_VORBIS,
      OMX_ROLE_AUDIO_DECODER_VORBIS_LEN)) {
    mInputPort = new OmxAmpVorbisPort(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_G711,
      OMX_ROLE_AUDIO_DECODER_G711_LEN)) {
    mInputPort = new OmxAmpPcmPort(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_WMA,
      OMX_ROLE_AUDIO_DECODER_WMA_LEN)) {
    mInputPort = new OmxAmpWmaPort(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_AMR,
      OMX_ROLE_AUDIO_DECODER_AMR_LEN)) {
    mInputPort = new OmxAmpAmrPort(kAudioPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_DECODER_RAW,
      OMX_ROLE_AUDIO_DECODER_RAW_LEN)) {
    mInputPort = new OmxAmpPcmPort(kAudioPortStartNumber, OMX_DirInput);
  } else {
    mInputPort = new OmxAmpAudioPort(kAudioPortStartNumber, OMX_DirInput);
  }
  addPort(mInputPort);
  mOutputPort = new OmxAmpAudioPort(kAudioPortStartNumber + 1, OMX_DirOutput);
  addPort(mOutputPort);
  OMX_PARAM_PORTDEFINITIONTYPE def;
  mInputPort->getDefinition(&def);
  def.nBufferCountActual = 4;
  mInputPort->setDefinition(&def);
  return err;
!!!11091340.cpp!!!	initRole() : OMX_ERRORTYPE
  if (strncmp(mName, kCompNamePrefix, kCompNamePrefixLength)) {
    return OMX_ErrorInvalidComponentName;
  }
  char *role_name = mName + kCompNamePrefixLength;
  if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AAC_SECURE,
      OMX_ROLE_AUDIO_DECODER_AAC_SECURE_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AAC_SECURE);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AAC,
      OMX_ROLE_AUDIO_DECODER_AAC_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AAC);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AMRNB,
      OMX_ROLE_AUDIO_DECODER_AMRNB_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AMRNB);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AMRWB,
      OMX_ROLE_AUDIO_DECODER_AMRWB_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AMRWB);
  }
#ifdef OMX_AudioExt_h
  else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_MP1,
      OMX_ROLE_AUDIO_DECODER_MP1_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_MP1);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_MP2,
      OMX_ROLE_AUDIO_DECODER_MP2_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_MP2);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AC3_SECURE,
      OMX_ROLE_AUDIO_DECODER_AC3_SECURE_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AC3_SECURE);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AC3,
      OMX_ROLE_AUDIO_DECODER_AC3_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AC3);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_DTS,
      OMX_ROLE_AUDIO_DECODER_DTS_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_DTS);
  }
#endif
  else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_MP3,
      OMX_ROLE_AUDIO_DECODER_MP3_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_MP3);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_VORBIS,
      OMX_ROLE_AUDIO_DECODER_VORBIS_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_VORBIS);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_G711,
      OMX_ROLE_AUDIO_DECODER_G711_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_G711);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_WMA,
      OMX_ROLE_AUDIO_DECODER_WMA_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_WMA);
  } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_RAW,
      OMX_ROLE_AUDIO_DECODER_RAW_LEN)) {
    addRole(OMX_ROLE_AUDIO_DECODER_RAW);
  } else if (!strncmp(role_name, "audio_decoder", 13)) {
    addRole(OMX_ROLE_AUDIO_DECODER_AAC_SECURE);
    addRole(OMX_ROLE_AUDIO_DECODER_AAC);
    addRole(OMX_ROLE_AUDIO_DECODER_VORBIS);
    addRole(OMX_ROLE_AUDIO_DECODER_G711);
#ifdef OMX_AudioExt_h
    addRole(OMX_ROLE_AUDIO_DECODER_MP1);
    addRole(OMX_ROLE_AUDIO_DECODER_MP2);
    addRole(OMX_ROLE_AUDIO_DECODER_AC3_SECURE);
    addRole(OMX_ROLE_AUDIO_DECODER_AC3);
    addRole(OMX_ROLE_AUDIO_DECODER_DTS);
#endif
    addRole(OMX_ROLE_AUDIO_DECODER_WMA);
    addRole(OMX_ROLE_AUDIO_DECODER_MP3);
    addRole(OMX_ROLE_AUDIO_DECODER_RAW);
    addRole(OMX_ROLE_AUDIO_DECODER_AMRNB);
    addRole(OMX_ROLE_AUDIO_DECODER_AMRWB);
  } else {
    return OMX_ErrorInvalidComponentName;
  }
  return OMX_ErrorNone;
!!!11091468.cpp!!!	prepare() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  // mediahelper init
  if (mediainfo_buildup()) {
    OMX_LOGD("Media helper build success");
  } else {
    OMX_LOGE("Media helper build fail");
  }
  // remove the dumped data
  mediainfo_remove_dumped_data(MEDIA_AUDIO);

  initAQ();

  // set aren passthru
  if (mPassthru_wait == OMX_TRUE) {
    if (mOutputPort->isTunneled()) {
      OmxComponentImpl *aren = static_cast<OmxComponentImpl *>(
          static_cast<OMX_COMPONENTTYPE *>(mOutputPort->getTunnelComponent())->pComponentPrivate);
      if (NULL != aren && NULL != strstr(aren->mName, "audio_renderer")) {
        OMX_LOGD("set aren passthru mode");
        static_cast<OmxAmpAudioRenderer *>(aren)->setPassThruMode();
        mPassthru_wait = OMX_FALSE;
      } else {
        mPassthru_wait = OMX_TRUE;
        OMX_LOGD("delay to set aren passthru mode");
      }
    } else {
      mPassthru_wait = OMX_TRUE;
      OMX_LOGD("delay to set aren passthru mode line %d", __LINE__);
    }
  }
  HRESULT err = SUCCESS;
  AMP_COMPONENT_CONFIG mConfig;
  // Get audio decoder handle mAmpHandle
  err = getAmpAudioDecoder();
  CHECKAMPERRLOG(err, "Failed to get AMP audio decoder");
  OMX_S32 acodec_type = getAmpDecType(
      mInputPort->getAudioDefinition().eEncoding);
  if (acodec_type < 0) {
    OMX_LOGE("can not find the AMP adec type.");
    return OMX_ErrorUndefined;
  }
  setADECParameter(acodec_type);
  mConfig._d = AMP_COMPONENT_ADEC;
  if (mOutputPort->isTunneled()) {
    mConfig._u.pADEC.mode = AMP_TUNNEL;
  } else {
    mConfig._u.pADEC.mode = AMP_NON_TUNNEL;
  }
  mConfig._u.pADEC.eAdecFmt = acodec_type;
  mConfig._u.pADEC.uiInPortNum = 1;
  if (mPassthru == OMX_TRUE && mOutputPort->isTunneled()) {
    // set adec output port num to 3: hdmi, pcm, spdif
    mConfig._u.pADEC.uiOutPortNum = 3;
  } else {
    mConfig._u.pADEC.uiOutPortNum = 1;
  }
  mConfig._u.pADEC.ucFrameIn = AMP_ADEC_FRAME;

  configDmxPort();
  CHECKAMPERRLOG(err, "");

  if (mOutputPort->isTunneled()) {
#if 1
    if (mAudioDrm != OMX_TRUE) {
      OMX_U32 ret = AMP_CBUFCreate(stream_in_buf_size, 0, stream_in_bd_num,
          stream_in_align_size, true, &mPool, true, 64 * 1024);
      if (AMPCBUF_SUCCESS != ret) {
        OMX_LOGW("ADEC Cbuf Create Error %u.", ret);
        // create cbuf fail, use omx bd
        OMX_PARAM_PORTDEFINITIONTYPE def;
        mInputPort->getDefinition(&def);
        def.nBufferCountActual = 128;
        mInputPort->setDefinition(&def);
      }
    } else {
      OMX_PARAM_PORTDEFINITIONTYPE def;
      mInputPort->getDefinition(&def);
      def.nBufferCountActual = 64;
      mInputPort->setDefinition(&def);
    }
#else
    OMX_PARAM_PORTDEFINITIONTYPE def;
    mInputPort->getDefinition(&def);
    def.nBufferCountActual = 128;
    mInputPort->setDefinition(&def);
#endif
  }
  AMP_RPC(err, AMP_ADEC_Open, mAmpHandle, &mConfig);
  CHECKAMPERRLOG(err, "Failed to open AMP audio decoder handler");

  if (mAudioDrm == OMX_TRUE) {
    err = AMP_ConnectApp(mDMXHandle, AMP_PORT_INPUT,
        0, pushBufferDone, static_cast<void *>(this));
    CHECKAMPERRLOG(err, "Failed to connect AudioDecoder input port with DMX");
    // connect DMX and ADEC
    err = AMP_ConnectComp(mDMXHandle, mChnlObj.uiPortIdx,
        mAmpHandle, kAMPADECPortStartNumber);
    CHECKAMPERRLOG(err, "Failed to connect DMX with ADEC");
  } else {
    err = AMP_ConnectApp(mAmpHandle, AMP_PORT_INPUT,
        0, pushBufferDone, static_cast<void *>(this));
    CHECKAMPERRLOG(err, "Failed to connect AudioDecoder input port with ADEC");
  }

  if (!mOutputPort->isTunneled()) {
    OMX_LOGD("non-tunnel mode, connect output port");
    err = AMP_ConnectApp(mAmpHandle, AMP_PORT_OUTPUT,
        0, pushBufferDone, static_cast<void *>(this));
    CHECKAMPERRLOG(err, "Failed to connect AudioDecoder output port with ADEC");
  }

  // Register a callback so that it can receive event - from ADEC.
  mListener = AMP_Event_CreateListener(AMP_EVENT_TYPE_MAX, 0);
  if (mListener) {
    err = registerEvent(AMP_EVENT_ADEC_CALLBACK_STRMINFO);
    CHECKAMPERRLOG(err, "Failed to RegisterEvent with ADEC");
  }

  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(SUCCESS);
!!!11091596.cpp!!!	preroll() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11091724.cpp!!!	start() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  err = registerBds(static_cast<OmxAmpAudioPort *>(mInputPort));
  CHECKAMPERRLOG(err, "Failed to register BD in input port");

  if (!mOutputPort->isTunneled()) {
    err = registerBds(static_cast<OmxAmpAudioPort *>(mOutputPort));
    CHECKAMPERRLOG(err, "Failed to register BD in output port");
  }

  err = setAmpState(AMP_EXECUTING);
  CHECKAMPERRLOG(err, "Failed to set audio decoder intput executing state");

  OMX_LOGD("Create decoding thread");
  mPauseLock = kdThreadMutexCreate(KD_NULL);
  mPauseCond = kdThreadCondCreate(KD_NULL);
  mThread = kdThreadCreate(mThreadAttr, threadEntry,
      reinterpret_cast<void *>(this));
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11091852.cpp!!!	pause() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  mPaused = OMX_TRUE;
  mShouldExit = OMX_TRUE;
  err = setAmpState(AMP_PAUSED);
  CHECKAMPERRLOG(err, "Failed to set audio decoder to pause state");
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11091980.cpp!!!	resume() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  err = setAmpState(AMP_EXECUTING);
  CHECKAMPERRLOG(err, "Failed to set audio decoder to executing state");

  if (mAudioDrm == OMX_TRUE) {
    AMP_RPC(err, AMP_DMX_ChannelControl, mDMXHandle, &mChnlObj, AMP_DMX_CH_CTRL_ON, 0);
    CHECKAMPERRLOG(err, "Failed to enable DMX channel");
  }
  if (mInputPort->getCachedBuffer() != NULL) {
    returnBuffer(mInputPort, mInputPort->getCachedBuffer());
  }
  if (mOutputPort->getCachedBuffer() != NULL) {
    returnBuffer(mOutputPort, mOutputPort->getCachedBuffer());
  }
  mShouldExit = OMX_FALSE;
  mPaused = OMX_FALSE;
  kdThreadMutexLock(mPauseLock);
  kdThreadCondSignal(mPauseCond);
  kdThreadMutexUnlock(mPauseLock);
  return static_cast<OMX_ERRORTYPE>(err);
!!!11092108.cpp!!!	stop() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  mPaused = OMX_FALSE;
  mShouldExit = OMX_TRUE;
  if (mPauseLock) {
    kdThreadMutexLock(mPauseLock);
    kdThreadCondSignal(mPauseCond);
    kdThreadMutexUnlock(mPauseLock);
  }
  if (mThread) {
    // post buffer may cause the sem value not correct
    // @todo need correct the value
    if (mInputPort->isEmpty())
      mInputPort->postBuffer();
    if (mOutputPort->isEmpty())
      mOutputPort->postBuffer();
    void *retval;
    KDint ret;
    ret = kdThreadJoin(mThread, &retval);
    OMX_LOGD("Stop decoding thread");
    mThread = NULL;
  }
  if (mPauseLock) {
    kdThreadMutexFree(mPauseLock);
    mPauseLock = NULL;
  }
  if (mPauseCond) {
    kdThreadCondFree(mPauseCond);
    mPauseCond = NULL;
  }
  if (mCachedhead) {
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  err = setAmpState(AMP_IDLE);
  CHECKAMPERRLOG(err, "Failed to set audio decoder intpu IDEL state");

  err = clearAmpPort();
  CHECKAMPERRLOG(err, "Failed to clear AMP port");

  // Waiting for input/output buffers back
  OMX_U32 wait_count = 100;
  while ((mInputFrameNum > mInBDBackNum || mOutBDPushNum > mOutputFrameNum)
      && wait_count > 0) {
    usleep(5000);
    wait_count--;
  }
  OMX_LOGD("inputframe %d inbackbd %d outframe %d outpushbd %d wait %d\n",
      mInputFrameNum, mInBDBackNum, mOutputFrameNum, mOutBDPushNum, wait_count);
  if (mPool) {
    wait_count = 150;
    while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
      usleep(5000);
      wait_count --;
    }
    if (!wait_count) {
      OMX_LOGE("There are %d pushed BD not returned.",
          mPushedBdNum - mReturnedBdNum);
    }
    if (AMPCBUF_SUCCESS != AMP_CBUFDestroy(mPool)) {
      OMX_LOGE("Cbuf destroy pool error.");
    }
  }
  returnCachedBuffers(mInputPort);
  returnCachedBuffers(mOutputPort);
  err = unregisterBds(static_cast<OmxAmpAudioPort *>(mInputPort));
  CHECKAMPERRLOG(err, "Failed to unregister BDs at input port");

  if (!mOutputPort->isTunneled()) {
    err = unregisterBds(static_cast<OmxAmpAudioPort *>(mOutputPort));
    CHECKAMPERRLOG(err, "Faild to unregister BDs at output port");
  }
  mShouldExit = OMX_FALSE;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11092236.cpp!!!	release() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  // deinit mediahelper
  mediainfo_teardown();
  HRESULT err = SUCCESS;

  if (mListener) {
    err = unRegisterEvent(AMP_EVENT_ADEC_CALLBACK_STRMINFO);
    CHECKAMPERRLOG(err, "Failed to unRegisterEvent with ADEC");
    CHECKAMPERR(AMP_Event_DestroyListener(mListener));
    mListener = NULL;
  }

  if (mAudioDrm == OMX_TRUE) {
    err = AMP_DisconnectApp(mDMXHandle, AMP_PORT_INPUT,
        0, pushBufferDone);
    CHECKAMPERRLOG(err, "Failed to disceonnect AudioDecoder input port with DMX");
  } else {
    err = AMP_DisconnectApp(mAmpHandle, AMP_PORT_INPUT,
        0, pushBufferDone);
    CHECKAMPERRLOG(err, "Failed to disceonnect AudioDecoder input port with ADEC");
  }
  if (!mOutputPort->isTunneled()) {
    err = AMP_DisconnectApp(mAmpHandle, AMP_PORT_OUTPUT,
        0, pushBufferDone);
    CHECKAMPERRLOG(err, "Failed to disceonnect AudioDecoder output port with ADEC");
  }
  if (mAudioDrm == OMX_TRUE) {
     //Clear channel
    AMP_RPC(err, AMP_DMX_ChannelControl, mDMXHandle, &mChnlObj, AMP_DMX_CH_CTRL_OFF, 0);
    CHECKAMPERRLOG(err, "Failed to clear DMX channel");

    AMP_RPC(err, AMP_DMX_RmChannel, mDMXHandle, &mChnlObj);
    CHECKAMPERRLOG(err, "Failed to delete DMX channel");

    AMP_RPC(err, AMP_DMX_RmInput, mDMXHandle, &mInputObj);
    CHECKAMPERRLOG(err, "Failed to delete DMX input");

    AMP_RPC(err, AMP_DMX_Close, mDMXHandle);
    CHECKAMPERRLOG(err, "Failed to close DMX handler");

    AMP_SHM_Release(mhInputBuf);
  }
  AMP_RPC(err, AMP_ADEC_Close, mAmpHandle);
  CHECKAMPERRLOG(err, "Failed to close ADEC");

  err = destroyAmpAudioDecoder();
  CHECKAMPERRLOG(err, "Failed to destroy ADEC");

  while (!mCodecSpeficData.empty()) {
    vector<CodecSpeficDataType>::iterator it = mCodecSpeficData.begin();
    if (it->data != NULL) {
      kdFree(it->data);
    }
    mCodecSpeficData.erase(it);
  }

  if (NULL != mSourceControl) {
    if (-1 != mSourceId) {
      mSourceControl->exitSource(mSourceId);
      mSourceId = -1;
    }
    delete mSourceControl;
    mSourceControl = NULL;
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11092364.cpp!!!	flush() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OMX_U32 wait_count = 150;
  // TODO: Waiting for clear the input/output buffer queue
  if (!mOutputPort->isTunneled()) {
    while ((!mInputPort->isEmpty() || !mOutputPort->isEmpty())
        && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("The buffer queue have not been cleared.");
    }
  }
  if (NULL != mCachedhead) {
    OMX_LOGD("return the cached buffer header.");
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  err = setAmpState(AMP_IDLE);
  CHECKOMXERR(err);
  err = clearAmpPort();
  CHECKAMPERR(err);
  // clear dumped es data and pcm data
  MEDIA_S8 value[MEDIA_VALUE_LENGTH];
  if (mediainfo_get_property(
      reinterpret_cast<const MEDIA_S8 *>("mediainfo_clear_dump"), value) &&
      kdMemcmp(value, "1", 1) == 0) {
    mediainfo_remove_dumped_data(MEDIA_AUDIO);
  }
  wait_count = 150;
  while ((mInputFrameNum > mInBDBackNum || mOutBDPushNum > mOutputFrameNum)
      && wait_count > 0) {
    usleep(5000);
    wait_count--;
  }
  OMX_LOGD("inputframe %d inbackbd %d outframe %d outpushbd %d wait %d\n",
      mInputFrameNum, mInBDBackNum, mOutputFrameNum, mOutBDPushNum, wait_count);
  if (NULL != mPool) {
    wait_count = 200;
    while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("There are %d pushed Bd not returned.", mPushedBdNum - mReturnedBdNum);
    }
    if (AMPCBUF_SUCCESS != AMP_CBUFReset(mPool)) {
      OMX_LOGE("Cbuf AMP_CBUFReSet error.");
    }
    mPushedBdNum = 0;
    mReturnedBdNum = 0;
  }
  returnCachedBuffers(mInputPort);
  returnCachedBuffers(mOutputPort);
  // set pts to -1 for update later
  mTimeStampUs = -1;
  if (getState() == OMX_StateExecuting) {
    err = setAmpState(AMP_EXECUTING);
  } else if (getState() == OMX_StatePause) {
    err = setAmpState(AMP_PAUSED);
  }
  CHECKOMXERR(err);
  mStreamPosition = 0;
  mInited = OMX_FALSE;
  mEOS = OMX_FALSE;
  mOutputEOS = OMX_FALSE;
  mAudioLength = 0;
  mInputFrameNum = 0;
  mOutputFrameNum = 0;
  mInBDBackNum = 0;
  mOutBDPushNum = 0;
  static_cast<OmxAmpAudioPort *>(mInputPort)->mPushedOffset = 0;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11092492.cpp!!!	pushBufferLoop() : void
  AMP_BD_ST *in_buf = NULL, *out_buf = NULL;
  OMX_BUFFERHEADERTYPE *in_head = NULL, *out_head = NULL;
  OMX_BOOL isCaching = OMX_FALSE;
 Loop_start:
  while (!mShouldExit) {
    // Get input Buffer
    while (!mInputPort->isEmpty() || NULL != mCachedhead) {
      if (NULL != mCachedhead) {
        OMX_LOGV("Got input buffer %p", in_head);
        in_head = mCachedhead;
        isCaching = OMX_TRUE;
        OMX_LOGV("Use the cached input buffer %p", in_head);
      } else {
        in_head = mInputPort->popBuffer();
        if (mPool != NULL) {
          mCachedhead = in_head;
          isCaching = OMX_FALSE;
        }
        OMX_LOGV("Got input buffer %p", in_head);
      }
      if (NULL != in_head) {
        if (mInputPort->isFlushing()) {
          OMX_LOGD("Return input buffer when flushing");
          returnBuffer(mInputPort, in_head);
          in_head = NULL;
          mCachedhead = NULL;
          continue;
        }
        // Process start frame
        if (in_head->nFlags & OMX_BUFFERFLAG_STARTTIME) {
        }
        if (in_head->nFlags & OMX_BUFFERFLAG_EOS) {
          OMX_LOGD("Meet EOS Frame, wait for stop");
          mEOS = OMX_TRUE;
        }
        if (in_head->hMarkTargetComponent != NULL) {
          mMark.hMarkTargetComponent = in_head->hMarkTargetComponent;
          mMark.pMarkData = in_head->pMarkData;
        }
        // Process codec config data
        if (in_head->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
          if (mCodecSpecficDataSent) {
            vector<CodecSpeficDataType>::iterator it;
            while (!mCodecSpeficData.empty()) {
              it = mCodecSpeficData.begin();
              if (it->data != NULL) {
                kdFree(it->data);
              }
              mCodecSpeficData.erase(it);
            }
          }
          CodecSpeficDataType extra_data;
          extra_data.data = kdMalloc(in_head->nFilledLen);
          extra_data.size = in_head->nFilledLen;
          char *pData = reinterpret_cast<char *>(in_head->pBuffer)
              + in_head->nOffset;
          kdMemcpy(extra_data.data, in_head->pBuffer + in_head->nOffset,
              in_head->nFilledLen);
          mCodecSpeficData.push_back(extra_data);
          in_head->nFilledLen = 0;
          in_head->nOffset = 0;
          returnBuffer(mInputPort, in_head);
          mCachedhead = NULL;
          // use esds data to generate adts header
          OmxPortImpl* port = getPort(kAudioPortStartNumber);
          if (port != NULL &&
              port->getDomain() == OMX_PortDomainAudio &&
              port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingAAC) {
            static_cast<OmxAmpAacPort*>(port)->setCodecParam(NULL,
                reinterpret_cast<OMX_U8 *>(extra_data.data));
          }
          continue;
        }
        CryptoInfo *cryptoInfo = NULL;
        if (in_head->nFlags & OMX_BUFFERFLAG_EXTRADATA) {
          OMX_U32 offset = (in_head->nOffset +in_head->nFilledLen + 3) / 4 * 4;
          OMX_OTHER_EXTRADATATYPE *extraData =
              reinterpret_cast<OMX_OTHER_EXTRADATATYPE *>(in_head->pBuffer + offset);
          while (OMX_ExtraDataNone != extraData->eType) {
            if (static_cast<OMX_EXTRADATATYPE>(OMX_ExtraDataCryptoInfo) ==
                extraData->eType) {
              cryptoInfo = reinterpret_cast<CryptoInfo *>(extraData->data);
            }
            offset += extraData->nSize;
            extraData = reinterpret_cast<OMX_OTHER_EXTRADATATYPE *>(
                in_head->pBuffer + offset);
          }
        }
        if (mInited == OMX_FALSE) {
          if (mInputPort->getAudioDefinition().eEncoding == OMX_AUDIO_CodingVORBIS) {
            OMX_U32 codec_data_size = 0;
            vector<CodecSpeficDataType>::iterator it;
            for (it = mCodecSpeficData.begin();
                it != mCodecSpeficData.end(); it++) {
              codec_data_size += it->size;
            }
            OMX_U8 *data = in_head->pBuffer + in_head->nOffset;
            kdMemmove(data + codec_data_size, data, in_head->nFilledLen);
            OMX_U32 offset = 0;
            for (it = mCodecSpeficData.begin();
                it != mCodecSpeficData.end(); it++) {
              OMX_LOGD("Merge extra data %p, size %d", it->data, it->size);
              kdMemcpy(data + offset, it->data, it->size);
              offset += it->size;
            }
            in_head->nFilledLen += codec_data_size;
          }
          mCodecSpecficDataSent = OMX_TRUE;
          mInited = OMX_TRUE;
        }
        if (isCaching != OMX_TRUE) {
          mInputFrameNum++;
        }
        if (in_head->nTimeStamp < 0 && mStreamPosition == 0) {
            OMX_LOGD("<In> timestamp "TIME_FORMAT "invalid",
                TIME_ARGS(in_head->nTimeStamp));
            resetPtsForFirstFrame(in_head);
        }
        AmpBuffer *amp_buffer = static_cast<AmpBuffer *>(
            in_head->pPlatformPrivate);
        // update pts when initial or after seek
        if (mTimeStampUs == -1) {
          mTimeStampUs = in_head->nTimeStamp;
        }
        OMX_U8 header_size = 0;
        if (mAudioDrm == OMX_TRUE) {
          amp_buffer->clearBdTag();
          amp_buffer->addDmxUnitStartTag(in_head, mStreamPosition);
          amp_buffer->addMemInfoTag(in_head,
              static_cast<OmxAmpAudioPort *>(mInputPort)->mPushedOffset);
          static_cast<OmxAmpAudioPort *>(mInputPort)->updateMemInfo(in_head);
          if (NULL != cryptoInfo) {
            OMX_U64 encryptionOffset = 0;
            OMX_U64 iv;
            if (mSchemeIdSend == OMX_FALSE) {
              amp_buffer->addCryptoCtrlInfoTag(mDrm_type);
              mSchemeIdSend = OMX_TRUE;
            }
            kdMemcpy(&iv, cryptoInfo->mIv, sizeof(OMX_U64));
            for (OMX_U32 i = 0; i < cryptoInfo->mNumSubSamples; i++) {
              OMX_U32 numBytesOfClearData =
                  cryptoInfo->mSubSamples[i].mNumBytesOfClearData;
              OMX_U32 numBytesOfEncryptedData =
                  cryptoInfo->mSubSamples[i].mNumBytesOfEncryptedData;
              OMX_LOGD("mMode is %d crypto info num %d clear size %d encrypted size %d\n",
                  cryptoInfo->mMode, cryptoInfo->mNumSubSamples, numBytesOfClearData,
                  numBytesOfEncryptedData);
              if (0u < numBytesOfClearData) {
                amp_buffer->addDmxCtrlInfoTag(mAudioLength, numBytesOfClearData,
                    OMX_FALSE, 0, 0, mDrm_type);
                mAudioLength += numBytesOfClearData;
              }
              if (0u < numBytesOfEncryptedData) {
                amp_buffer->addDmxCtrlInfoTag(mAudioLength, numBytesOfEncryptedData,
                    OMX_TRUE, iv, encryptionOffset, mDrm_type);
                encryptionOffset += numBytesOfEncryptedData;
                mAudioLength += numBytesOfEncryptedData;
              }
            }
          } else {
            amp_buffer->addDmxCtrlInfoTag(mAudioLength, in_head->nFilledLen,
                OMX_FALSE, 0, 0, mDrm_type);
            mAudioLength += in_head->nFilledLen;
          }
          mStreamPosition += in_head->nFilledLen;
        } else {
          if (NULL != mPool) {
            if (!isCaching) {
              header_size = (static_cast<OmxAmpAudioPort *>(
                  mInputPort))->formatAudEsData(in_head);
            }

            UINT32 ret;
            ret = requestCbufBd();
            if (AMPCBUF_LACKBD == ret) {
              OMX_LOGV("Cbuf Lack of Bd, waitting.");
              usleep(kDefaultSleepTime);
              continue;
            }

            pushCbufBd(in_head);
            // request the EOS bd and push to ADEC
            if (mEOS == OMX_TRUE) {
              requestCbufBd();
            }
          } else {
            amp_buffer->updatePts(in_head, mStreamPosition);
            header_size = (static_cast<OmxAmpAudioPort *>(
                mInputPort))->formatAudEsData(in_head);
            amp_buffer->updateMemInfo(in_head);
          }
          if (isCaching != OMX_TRUE) {
            mStreamPosition += in_head->nFilledLen;
          }
        }
        if (mPool == NULL) {
          // dump es data
          MEDIA_S8 value[MEDIA_VALUE_LENGTH];
          if (mediainfo_get_property(
              reinterpret_cast<const MEDIA_S8 *>(
              "mediainfo_dump_audio_es_data"), value) &&
              kdMemcmp(value, "1", 1) == 0) {
            mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_ES,
                in_head->pBuffer + in_head->nOffset, in_head->nFilledLen);
          }
          // Current in phase one, we always enable this log.
          if (1 || (mediainfo_get_property(
              reinterpret_cast<const MEDIA_S8 *>(
              "mediainfo_print_bd_in"), value) &&
              kdMemcmp(value, "1", 1) == 0)) {
            OMX_LOGD("<In> %u/%u, size %d\tpts "TIME_FORMAT "\tflag %s ",
                mInBDBackNum, mInputFrameNum, in_head->nFilledLen,
                TIME_ARGS(in_head->nTimeStamp),
                GetOMXBufferFlagDescription(in_head->nFlags));
          }
          pushAmpBd(AMP_PORT_INPUT, 0, amp_buffer->getBD());
        }
      } else {
        OMX_LOGE("get input buffer %p error", in_head);
      }
    }
    // Push output buffer to ADEC
    /* Make sure push only one output buffer to ADEC then wait for check the output port
      setting correct or not in pushBufferDone();
    */
    while (!mOutputPort->isEmpty() && mOutputEOS == OMX_FALSE &&
      (mOutputPort->isEnabled() == OMX_TRUE) &&
      ((mOutputConfigInit == OMX_FALSE && mOutputConfigured == OMX_FALSE) ||
      (mOutputConfigInit == OMX_TRUE && mOutputConfigured == OMX_TRUE))) {
      // set mOutputConfigInit that means have pushed one output BD to ADEC
      mOutputConfigInit = OMX_TRUE;
      // Output port have changed and unregisterBds before, need registerBds again.
      if (mOutputConfigChanged == OMX_TRUE) {
        registerBds(static_cast<OmxAmpAudioPort *>(mOutputPort));
        mOutputConfigChanged = OMX_FALSE;
      }
      out_head = mOutputPort->popBuffer();
      OMX_LOGV("Got output buffer %p", out_head);
      if (NULL != out_head) {
        if (mOutputPort->isFlushing()) {
          OMX_LOGD("Return output buffer when flushing");
          returnBuffer(mOutputPort, out_head);
        }
        AmpBuffer *amp_buffer = static_cast<AmpBuffer *>(
            out_head->pPlatformPrivate);
        mOutBDPushNum++;
        MEDIA_S8 value[MEDIA_VALUE_LENGTH];
        if (mediainfo_get_property(
            reinterpret_cast<const MEDIA_S8 *>(
            "mediainfo_print_bd_out"), value) &&
            kdMemcmp(value, "1", 1) == 0) {
          OMX_LOGD("<Out> %d/%d,", mOutputFrameNum, mOutBDPushNum);
        }
        pushAmpBd(AMP_PORT_OUTPUT, 0, amp_buffer->getBD());
      } else {
        OMX_LOGE("get output buffer %p error", out_head);
      }
    }
    usleep(kDefaultSleepTime);
  }
  if (mPaused) {
    kdThreadMutexLock(mPauseLock);
    kdThreadCondWait(mPauseCond, mPauseLock);
    kdThreadMutexUnlock(mPauseLock);
    goto Loop_start;
  }
!!!11092620.cpp!!!	pushCbufBd(inout in_head : OMX_BUFFERHEADERTYPE) : void
  UINT32 ret, offset;
  OMX_U32 flag = (mEOS == OMX_TRUE) ? AMP_MEMINFO_FLAG_EOS_MASK : 0;
  ret = AMP_CBUFWriteData(mPool, in_head->pBuffer + in_head->nOffset,
      in_head->nFilledLen, flag, &offset);
  if (AMPCBUF_SUCCESS == ret) {
    if (mEOS == OMX_TRUE) {
      OMX_LOGD("Cbuf push EOS %d\n", flag);
    }
    // dump cbuf es data
    MEDIA_S8 value[MEDIA_VALUE_LENGTH];
    if (mediainfo_get_property(
        reinterpret_cast<const MEDIA_S8 *>(
        "mediainfo_dump_audio_es_data"), value) &&
        kdMemcmp(value, "1", 1) == 0) {
      mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_ES,
          in_head->pBuffer + in_head->nOffset, in_head->nFilledLen);
    }
    // Current in phase one, we always enable this log.
    if (1 || (mediainfo_get_property(
        reinterpret_cast<const MEDIA_S8 *>(
        "mediainfo_print_bd_in"), value) &&
        kdMemcmp(value, "1", 1) == 0)) {
      OMX_LOGD("<In> %u/%u, size %d\tpts "TIME_FORMAT "\tflag %s ",
          mInBDBackNum, mInputFrameNum, in_head->nFilledLen,
          TIME_ARGS(in_head->nTimeStamp),
          GetOMXBufferFlagDescription(in_head->nFlags));
    }
    AMP_BDTAG_UNITSTART pts_tag;
    kdMemset(&pts_tag, 0, sizeof(AMP_BDTAG_UNITSTART));
    pts_tag.Header = {AMP_BDTAG_BS_UNITSTART_CTRL,
        sizeof(AMP_BDTAG_UNITSTART)};
    convertUsto90K(in_head->nTimeStamp, &pts_tag.uPtsHigh,
        &pts_tag.uPtsLow);
    pts_tag.uStrmPos = offset;
    AMP_CBUFInsertTag(mPool, reinterpret_cast<UINT8 *>(&pts_tag),
        offset);
    returnBuffer(mInputPort, in_head);
    mCachedhead = NULL;
    mInBDBackNum++;
  } else if (AMPCBUF_LACKSPACE == ret) {
    OMX_LOGV("Cbuf Lack of space.");
    mInputFrameNum--;
  } else {
    OMX_LOGE("Cbuf already Reached Eos!");
    returnBuffer(mInputPort, in_head);
    mCachedhead = NULL;
    mInBDBackNum++;
  }
!!!11092748.cpp!!!	requestCbufBd() : UINT32
  AMP_BD_ST *bd;
  UINT32 ret, offset, framesize;
  ret = AMP_CBUFRequest(mPool, &bd, &offset, &framesize);
  if (AMPCBUF_SUCCESS == ret) {
    mPushedBdNum++;
    OMX_LOGD("Cbuf <%u/%u> Push Bd to Amp: offset %u  size %u",
        mReturnedBdNum, mPushedBdNum, offset, framesize);
    pushAmpBd(AMP_PORT_INPUT, 0, bd);
    // dump es data
    MEDIA_S8 value[MEDIA_VALUE_LENGTH];
    if (mediainfo_get_property(
        reinterpret_cast<const MEDIA_S8 *>(
        "mediainfo_dump_audio_cbuf_es_data"), value) &&
        kdMemcmp(value, "1", 1) == 0) {
      AMP_SHM_HANDLE mshm;
      AMP_CBUFGetShm(mPool, &mshm);
      void *pVirAddr = NULL;
      AMP_SHM_GetVirtualAddress(mshm, 0, &pVirAddr);
      mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_ES,
          reinterpret_cast<OMX_U8 *>(pVirAddr) + offset, framesize);
    }
  } else if (AMPCBUF_LACKBD == ret) {
    OMX_LOGV("Cbuf Lack of Bd, waitting.");
  } else if (AMPCBUF_LACKDATA == ret) {
    OMX_LOGV("Cbuf Lack of Data, waitting.");
  } else {
    OMX_LOGD("Cbuf Request Bd err %d.", ret);
  }
  return ret;
!!!11092876.cpp!!!	threadEntry(inout args : void) : void
  OmxAmpAudioDecoder *decoder = reinterpret_cast<OmxAmpAudioDecoder *>(args);
  prctl(PR_SET_NAME, "OMXAMPAudioDecoder-threadEntry", 0, 0, 0);
  decoder->pushBufferLoop();
  return NULL;
!!!11093004.cpp!!!	pushBufferDone(in component : AMP_COMPONENT, in port_Io : AMP_PORT_IO, in port_idx : UINT32, inout bd : AMP_BD_ST, inout context : void) : HRESULT
  MEDIA_S8 value[MEDIA_VALUE_LENGTH];
  if ((mediainfo_get_property(
      reinterpret_cast<const MEDIA_S8 *>("mediainfo_pushbufferdone"), value) &&
      kdMemcmp(value, "1", 1) == 0)) {
    OMX_LOGD("pushBufferDone, port_IO %d, bd 0x%x, bd.bdid 0x%x, bd.allocva 0x%x",
        port_Io, bd, bd->uiBDId, bd->uiAllocVA);
  }
  HRESULT err = SUCCESS;
  OMX_BUFFERHEADERTYPE *buf_header = NULL;
  OMX_BOOL isLastOutFrame = OMX_FALSE;
  OmxAmpAudioDecoder *decoder = static_cast<OmxAmpAudioDecoder *>(context);
  if (AMP_PORT_INPUT == port_Io && 0 == port_idx) {
    if (NULL != decoder->mPool) {
      OMX_U32 ret;
      ret = AMP_CBUFRelease(decoder->mPool, bd);
      if (AMPCBUF_SUCCESS == ret) {
        decoder->mReturnedBdNum++;
        OMX_LOGD("Cbuf [%u/%u] Return Bd from Amp", decoder->mReturnedBdNum,
            decoder->mPushedBdNum);
      } else {
        OMX_LOGE("Cbuf Release Bd error %u.", ret);
      }
      return err;
    }
    buf_header = (static_cast<OmxAmpAudioPort *>(decoder->mInputPort))
        ->getBufferHeader(bd);
    if (NULL != buf_header) {
      decoder->returnBuffer(decoder->mInputPort, buf_header);
      decoder->mInBDBackNum++;
      if (1 || (mediainfo_get_property(
          reinterpret_cast<const MEDIA_S8 *>("mediainfo_print_bd_in_back"), value) &&
          kdMemcmp(value, "1", 1) == 0)) {
        OMX_LOGD("[In] %d/%d", decoder->mInBDBackNum, decoder->mInputFrameNum);
      }
    }
  } else if (AMP_PORT_OUTPUT == port_Io && 0 == port_idx) {
    buf_header = (static_cast<OmxAmpAudioPort *>(decoder->mOutputPort))
        ->getBufferHeader(bd);
    if (NULL != buf_header) {
      AmpBuffer *amp_buffer =  static_cast<AmpBuffer *>(
          buf_header->pPlatformPrivate);
      if (decoder->mMark.hMarkTargetComponent != NULL) {
        buf_header->hMarkTargetComponent = decoder->mMark.hMarkTargetComponent;
        buf_header->pMarkData = decoder->mMark.pMarkData;
        decoder->mMark.hMarkTargetComponent = NULL;
        decoder->mMark.pMarkData = NULL;
      }
      AMP_BDTAG_AUD_FRAME_INFO *frame_info = amp_buffer->getAudioFrameInfo();
      if (frame_info->uFlag & AMP_MEMINFO_FLAG_EOS_MASK) {
        OMX_LOGD("[Out] Receive EOS");
        buf_header->nFlags |= OMX_BUFFERFLAG_EOS;
        frame_info->uFlag = 0;
        decoder->mOutputEOS = OMX_TRUE;
        decoder->postEvent(OMX_EventBufferFlag, buf_header->nOutputPortIndex,
            OMX_BUFFERFLAG_EOS);
      }
      AMP_BDTAG_AVS_PTS *pts_tag = amp_buffer->getOutputPts();
      #if 0
      OMX_TICKS pts_low, pts_high;
      pts_low = static_cast<OMX_TICKS>(frame_info->uiPtsLow);
      pts_high = static_cast<OMX_TICKS>(frame_info->uiPtsHigh);
      if (frame_info->uiPtsHigh & TIME_STAMP_VALID_MASK) {
        buf_header->nTimeStamp = (pts_high & 0x7FFFFFFF) << 32 | pts_low;
      }
      #endif
      void *pVirAddr = NULL;
      AMP_SHM_GetVirtualAddress(frame_info->uMemHandle, 0, &pVirAddr);

      buf_header->nTimeStamp = 1000000LL * (pts_tag->uPtsLow) / 90000;
      buf_header->nOffset = frame_info->uMemOffset[0];
      buf_header->nFilledLen = frame_info->uDataLength;
      buf_header->pBuffer = reinterpret_cast<OMX_U8 *>(pVirAddr);
      if (decoder->mOutputFrameNum == 0) {
        buf_header->nFlags |= OMX_BUFFERFLAG_STARTTIME;
        if (decoder->mInputPort->getAudioDefinition().eEncoding == OMX_AUDIO_CodingMP3) {
          OMX_U32 channel_num = 0;
          static_cast<OmxAmpAudioPort *>(decoder->mOutputPort)->GetOutputParameter(
              NULL, &channel_num);
          buf_header->nOffset = kMp3DecoderDelay * channel_num * sizeof(OMX_S16);
          buf_header->nFilledLen -= buf_header->nOffset;
        }
      }

      // TODO: workaround for amp filled buffer size after EOS
      if (decoder->mOutputEOS) {
        if ((buf_header->nFlags & OMX_BUFFERFLAG_EOS) != 0
            && decoder->mInputPort->getAudioDefinition().eEncoding == OMX_AUDIO_CodingMP3
            && decoder->mOutputFrameNum > 0) {
          OMX_U32 channel_num = 0;
          static_cast<OmxAmpAudioPort *>(decoder->mOutputPort)->GetOutputParameter(
              NULL, &channel_num);
          buf_header->nFilledLen = kMp3DecoderDelay * channel_num * sizeof(OMX_S16);
          kdMemset(buf_header->pBuffer, 0, buf_header->nFilledLen);
        } else {
          buf_header->nFilledLen = 0;
        }
      }
      // in case AMP audio can not return correct pts, would remove later
      if (decoder->mTimeStampUs == -1) {
        decoder->mTimeStampUs = 0;
      }
      if (buf_header->nTimeStamp <= 0 && decoder->mTimeStampUs > 0) {
        buf_header->nTimeStamp = decoder->mTimeStampUs;
      }

      if (frame_info->uSampleRate > 0) {
        decoder->mTimeStampUs += static_cast<OMX_TICKS>(
            (1000000LL * frame_info->uDataLength)) /
            (frame_info->uSampleRate * kDefaultChannels * 2);  // the 2 is bitdepts
      } else {
        decoder->mTimeStampUs += static_cast<OMX_TICKS>(
            (1000000LL * frame_info->uDataLength) /
            (kDefaultSampleRate * kDefaultChannels * 2));  // the 2 is bitdepts
      }

      if (decoder->mOutputConfigured == OMX_FALSE) {
        OMX_U32 mSamplerate = 0;
        OMX_U32 mChannel = 0;
        (static_cast<OmxAmpAudioPort *>(decoder->mOutputPort))->GetOutputParameter(
            &mSamplerate, &mChannel);
        if (frame_info->uSampleRate != mSamplerate ||
            frame_info->uChanNr != mChannel) {
          OMX_LOGD("Output port changed from samplerate %d channel %d to sr %d channel num %d\n",
              mSamplerate, mChannel, frame_info->uSampleRate, frame_info->uChanNr);
          (static_cast<OmxAmpAudioPort *>(decoder->mOutputPort))->SetOutputParameter(
              frame_info->uSampleRate, frame_info->uChanNr);
          decoder->mOutputFrameNum++;
          // unregisterBds output BD and set mOutputConfigChanged to TRUE
          decoder->unregisterBds(static_cast<OmxAmpAudioPort *>(decoder->mOutputPort));
          decoder->mOutputConfigChanged = OMX_TRUE;

          decoder->postEvent(OMX_EventPortSettingsChanged, buf_header->nOutputPortIndex, 0);
          decoder->mOutputConfigured = OMX_TRUE;
          return SUCCESS;
        }
        decoder->mOutputConfigured = OMX_TRUE;
      }

      // dump pcm data
      if (mediainfo_get_property(
          reinterpret_cast<const MEDIA_S8 *>("mediainfo_dump_audio_frame_data"), value) &&
          kdMemcmp(value, "1", 1) == 0) {
        mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_FRMAE,
            reinterpret_cast<OMX_U8 *>(pVirAddr), frame_info->uDataLength);
      }
      decoder->returnBuffer(decoder->mOutputPort, buf_header);
      decoder->mOutputFrameNum++;
      if (mediainfo_get_property(
          reinterpret_cast<const MEDIA_S8 *>("mediainfo_print_bd_out_back"), value) &&
          kdMemcmp(value, "1", 1) == 0) {
        OMX_LOGD("[Out] %d/%d, size %d, len %d, offset 0 %d shm %x buf num %d "
            "get pts 90K %0x us %lld calu pts "TIME_FORMAT
            " framerate %d channel num %d",
            decoder->mOutputFrameNum, decoder->mOutBDPushNum,
            frame_info->uSize, frame_info->uDataLength,
            frame_info->uMemOffset[0], frame_info->uMemHandle,
            frame_info->uBufNr,
            pts_tag->uPtsLow, buf_header->nTimeStamp,
            TIME_ARGS(decoder->mTimeStampUs),
            frame_info->uSampleRate, frame_info->uChanNr);
      }
    }
  } else {
    OMX_LOGE("bd not be used");
    err = ERR_NOTIMPL;
    return err;
  }
  return err;
!!!11093132.cpp!!!	createAmpAudioDecoder(inout handle : OMX_HANDLETYPE, in componentName : OMX_STRING, in appData : OMX_PTR, inout callBacks : OMX_CALLBACKTYPE) : OMX_ERRORTYPE
  OMX_LOGD("createAmpAudioDecoder");
  OmxAmpAudioDecoder *comp = new OmxAmpAudioDecoder(componentName);
  *handle = comp->makeComponent(comp);
  comp->setCallbacks(callBacks, appData);
  comp->componentInit();
  return OMX_ErrorNone;
!!!11093260.cpp!!!	getAmpAudioDecoder() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  err = AMP_GetFactory(&mFactory);
  CHECKAMPERRLOG(err, "Failed to get AMP factory");
  AMP_RPC(err, AMP_FACTORY_CreateComponent, mFactory, AMP_COMPONENT_ADEC,
      1, &mAmpHandle);
  CHECKAMPERRLOG(err, "Failed to create AMP audio decoder");
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11093388.cpp!!!	destroyAmpAudioDecoder() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (mAudioDrm == OMX_TRUE && mDMXHandle) {
    AMP_RPC(err, AMP_DMX_Destroy, mDMXHandle);
    CHECKAMPERRLOG(err, "Failed to destroy DMX handler");
    AMP_FACTORY_Release(mDMXHandle);
    mDMXHandle = NULL;
  }
  if (mAmpHandle) {
    AMP_RPC(err, AMP_ADEC_Destroy, mAmpHandle);
    CHECKAMPERRLOG(err, "Failed to destroy AMP handler");
    AMP_FACTORY_Release(mAmpHandle);
    mAmpHandle = NULL;
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11093516.cpp!!!	setAmpState(in state : AMP_STATE) : OMX_ERRORTYPE
  OMX_LOGD("setAmpState %s", AmpState2String(state));
  HRESULT err = SUCCESS;
  if (mAudioDrm == OMX_TRUE) {
    AMP_RPC(err, AMP_ADEC_SetState, mDMXHandle, state);
    CHECKAMPERRLOG(err, "Failed to set DMX state");
  }
  AMP_RPC(err, AMP_ADEC_SetState, mAmpHandle, state);
  CHECKAMPERRLOG(err, "Failed to set ADEC state");

  return static_cast<OMX_ERRORTYPE>(err);
!!!11093644.cpp!!!	getAmpState(inout state : AMP_STATE) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  if (mAudioDrm == OMX_TRUE) {
    AMP_RPC(err, AMP_ADEC_GetState, mDMXHandle, state);
    CHECKAMPERRLOG(err, "Failed to get DMX state");
  }
  AMP_RPC(err, AMP_ADEC_GetState, mAmpHandle, state);
  CHECKAMPERRLOG(err, "Failed to get ADEC state");

  OMX_LOGD("getAmpState is %s", AmpState2String(*state));
  return static_cast<OMX_ERRORTYPE>(err);
!!!11093772.cpp!!!	pushAmpBd(in port : AMP_PORT_IO, in portindex : UINT32, inout bd : AMP_BD_ST) : OMX_ERRORTYPE
  MEDIA_S8 value[MEDIA_VALUE_LENGTH];
  if (mediainfo_get_property(
      reinterpret_cast<const MEDIA_S8 *>("mediainfo_pushampbd"), value) &&
      kdMemcmp(value, "1", 1) == 0) {
    OMX_LOGD("pushAmpBd, port_IO %d, bd 0x%x, bd.bdid 0x%x, bd.allocva 0x%x",
        port, bd, bd->uiBDId, bd->uiAllocVA);
  }
  HRESULT err = SUCCESS;
  if (mAudioDrm == OMX_TRUE && portindex == AMP_PORT_INPUT) {
    AMP_RPC(err, AMP_ADEC_PushBD, mDMXHandle, port, portindex, bd);
    CHECKAMPERRLOG(err, "Failed to push BD to DMX");
  } else {
    AMP_RPC(err, AMP_ADEC_PushBD, mAmpHandle, port, portindex, bd);
    CHECKAMPERRLOG(err, "Failed to push BD to ADEC");
  }
  return static_cast<OMX_ERRORTYPE>(err);
!!!11093900.cpp!!!	registerBds(inout port : OmxAmpAudioPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  UINT32 uiPortIdx = 0;
  AMP_BD_ST *bd;
  if (port->isInput()) {
    for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
      AmpBuffer *amp_buffer = port->getAmpBuffer(i);
      if (NULL != amp_buffer) {
        if (mAudioDrm == OMX_FALSE) {
          amp_buffer->addMemInfoTag();
          amp_buffer->addPtsTag();
          AMP_RPC(err, AMP_ADEC_RegisterBD, mAmpHandle, AMP_PORT_INPUT,
              uiPortIdx, amp_buffer->getBD());
          CHECKAMPERRLOG(err, "Failed to register BD to ADEC at input port");
        }
      }
    }
  } else {
    for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
      AmpBuffer *amp_buffer = port->getAmpBuffer(i);
      if (NULL != amp_buffer) {
        // amp_buffer->addMemInfoTag();
        amp_buffer->addAudioFrameInfoTag();
        amp_buffer->addAVSPtsTag();
        AMP_RPC(err, AMP_ADEC_RegisterBD, mAmpHandle, AMP_PORT_OUTPUT,
            uiPortIdx, amp_buffer->getBD());
        CHECKAMPERRLOG(err, "Failed to register BD to ADEC at output port");
      }
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11094028.cpp!!!	unregisterBds(inout port : OmxAmpAudioPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  AMP_PORT_IO portIo;
  if (port->isInput()) {
    portIo = AMP_PORT_INPUT;
  } else {
    portIo = AMP_PORT_OUTPUT;
  }
  AMP_BD_ST *bd;
  UINT32 uiPortIdx = 0;
  for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
    bd = port->getBD(i);
    if (NULL != bd) {
      if (mAudioDrm == OMX_TRUE && port->isInput()) {
        AMP_RPC(err, AMP_ADEC_UnregisterBD, mDMXHandle, portIo, uiPortIdx, bd);
        CHECKAMPERRLOG(err, "Failed to unregister BD for DMX");
      } else {
        AMP_RPC(err, AMP_ADEC_UnregisterBD, mAmpHandle, portIo, uiPortIdx, bd);
        CHECKAMPERRLOG(err, "Failed to unregister BD for ADEC");
      }
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11094156.cpp!!!	getAmpDecType(in type : OMX_AUDIO_CODINGTYPE) : OMX_S32
  OMX_S32 amp_type = -1;
  switch (type) {
    case OMX_AUDIO_CodingAAC:
      amp_type = AMP_HE_AAC;
      break;
#ifdef OMX_IndexExt_h
    case OMX_AUDIO_CodingMP1:
    case OMX_AUDIO_CodingMP2:
      amp_type = AMP_MPG_AUDIO;
      break;
    case OMX_AUDIO_CodingAC3:
      amp_type = AMP_DD_DCV;
      break;
    case OMX_AUDIO_CodingDTS:
      amp_type = AMP_DTS_HD;
      break;
#endif
    case OMX_AUDIO_CodingMP3:
      amp_type = AMP_MP3;
      break;
    case OMX_AUDIO_CodingVORBIS:
      amp_type = AMP_VORBIS;
      break;
    case OMX_AUDIO_CodingPCM:
      amp_type = AMP_RAW_PCM;
      break;
      OmxPortImpl* port;
      OMX_AUDIO_PARAM_PCMMODETYPE pcmParams;
      // kAudioPortStartNumber need to get
      port = getPort(kAudioPortStartNumber);
      if (port != NULL && port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingPCM) {
        pcmParams = static_cast<OmxAmpPcmPort*>(port)->getCodecParam();
      } else {
        amp_type = AMP_RAW_PCM;
      }
      if (pcmParams.ePCMMode == OMX_AUDIO_PCMModeALaw) {
        amp_type = AMP_G711A;
      } else if (pcmParams.ePCMMode == OMX_AUDIO_PCMModeMULaw) {
        amp_type = AMP_G711U;
      } else {
        amp_type = AMP_RAW_PCM;
      }
      break;
    case OMX_AUDIO_CodingWMA:
      amp_type = AMP_WMA;
      break;
    case OMX_AUDIO_CodingAMR: {
      char *role_name = mName + kCompNamePrefixLength;
      if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AMRNB,
          OMX_ROLE_AUDIO_DECODER_AMRNB_LEN)) {
        amp_type = AMP_AMRNB;
      } else if (!strncmp(role_name, OMX_ROLE_AUDIO_DECODER_AMRWB,
          OMX_ROLE_AUDIO_DECODER_AMRWB_LEN)) {
        amp_type = AMP_AMRWB;
      }
      break;
    }
    default :
      OMX_LOGE("amp audio codec %d not supported", type);
  }
  return amp_type;
!!!11094284.cpp!!!	isAudioParamSupport(inout audio_param : OMX_AUDIO_PARAM_PORTFORMATTYPE) : OMX_BOOL
  OMX_BOOL isSupport = OMX_FALSE;
  for (OMX_U32 audio_index = 0; audio_index < NELM(kAudioFormatSupport);
      audio_index ++) {
    if (audio_param->eEncoding == static_cast<OMX_AUDIO_CODINGTYPE>
          (kAudioFormatSupport[audio_index].eCompressionFormat)) {
      isSupport = OMX_TRUE;
      break;
    }
  }
  return isSupport;
!!!11094412.cpp!!!	setADECParameter(in adec_type : OMX_S32) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_ADEC_PARAIDX para_index = 0;
  OmxPortImpl* port = NULL;
  AMP_ADEC_PARAS mParas;
  OMX_AUDIO_PARAM_PCMMODETYPE pcmParams;
  switch (adec_type) {
    case AMP_HE_AAC:
      mParas._d = AMP_ADEC_PARAIDX_AAC;
      mParas._u.AAC.ucLayer = 0;
      mParas._u.AAC.ucProfileType = 1;  // _LC;
      mParas._u.AAC.ucStreamFmt = 0;  // AAC_SF_MP2ADTS;
      mParas._u.AAC.ucVersion = 1;  // MPEG2
      mParas._u.AAC.uiBitRate = 6000;
      mParas._u.AAC.uiChanMask = 0x2;  // L R
      mParas._u.AAC.uiInThresh = (768 * 6);
      mParas._u.AAC.uiSampleRate = 4;  // 44100
      mParas._u.AAC.unBitDepth = 8;
      mParas._u.AAC.unChanMode = 2;  // IPP_STEREO;
      mParas._u.AAC.unChanNr = 2;
      mParas._u.AAC.unLfeMode = 0;
      AMP_RPC(err, AMP_ADEC_SetParameters, mAmpHandle,
          AMP_ADEC_PARAIDX_AAC, &mParas);
      break;
    case AMP_G711A:
    case AMP_G711U:
      port = getPort(kAudioPortStartNumber);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        OMX_LOGE("failed to get port");
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingPCM) {
        pcmParams = static_cast<OmxAmpPcmPort*>(port)->getCodecParam();
        OMX_LOGD("get OMX_AUDIO_PARAM_PCMMODETYPE");
      } else {
        OMX_LOGE("no OMX_AUDIO_PARAM_PCMMODETYPE found");
        break;
      }
      memset(&mParas, 0, sizeof(mParas));
      mParas._d = AMP_ADEC_PARAIDX_G711;
      mParas._u.G711.uiSampleRate = pcmParams.nSamplingRate;
      mParas._u.G711.unChanNr = pcmParams.nChannels;
      mParas._u.G711.unBitDepth = pcmParams.nBitPerSample;
      mParas._u.G711.uiInThresh = 0x4000;
      OMX_LOGD("sample rate = %d, channel count = %d, bit depth = %d",
          mParas._u.G711.uiSampleRate, mParas._u.G711.unChanNr, mParas._u.G711.unBitDepth);
      AMP_RPC(err, AMP_ADEC_SetParameters, mAmpHandle,
          AMP_ADEC_PARAIDX_G711, &mParas);
      break;
    case AMP_RAW_PCM:
      port = getPort(kAudioPortStartNumber);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        OMX_LOGE("failed to get port");
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingPCM) {
        pcmParams = static_cast<OmxAmpPcmPort*>(port)->getCodecParam();
        OMX_LOGD("get OMX_AUDIO_PARAM_PCMMODETYPE");
      } else {
        OMX_LOGE("no OMX_AUDIO_PARAM_PCMMODETYPE found");
        break;
      }
      memset(&mParas, 0, sizeof(mParas));
      mParas._d = AMP_ADEC_PARAIDX_RAWPCM;
      mParas._u.PCM.uiPcmType = AMP_AUDIO_PCM_16BIT;
      if ((8 == pcmParams.nBitPerSample) &&
          (OMX_NumericalDataUnsigned == pcmParams.eNumData)) {
        mParas._u.PCM.uiPcmType = AMP_AUDIO_PCMBITS8_UNSIGNED;
      } else if ((8 == pcmParams.nBitPerSample) &&
          (OMX_NumericalDataSigned == pcmParams.eNumData)) {
        mParas._u.PCM.uiPcmType = AMP_AUDIO_PCMBITS8_SINGED;
      } else if ((16 == pcmParams.nBitPerSample) &&
          (OMX_NumericalDataUnsigned == pcmParams.eNumData)) {
        mParas._u.PCM.uiPcmType = AMP_AUDIO_PCMBITS16_UNSIGNED;
      } else if ((24 == pcmParams.nBitPerSample) &&
          (OMX_NumericalDataUnsigned == pcmParams.eNumData)) {
        mParas._u.PCM.uiPcmType = AMP_AUDIO_PCMBITS24_UNSIGNED;
      } else if ((24 == pcmParams.nBitPerSample) &&
          (OMX_NumericalDataSigned == pcmParams.eNumData)) {
        mParas._u.PCM.uiPcmType = AMP_AUDIO_PCMBITS24_SINGED;
      }
      mParas._u.PCM.unChanMode = 9;
      mParas._u.PCM.cLittleEndian = 0;
      if (OMX_EndianBig == pcmParams.eEndian) {
        mParas._u.PCM.cLittleEndian = 1;
      }
      mParas._u.PCM.uiInThresh = 0x4000;
      mParas._u.PCM.uiSampleRate = pcmParams.nSamplingRate;
      mParas._u.PCM.unChanNr = pcmParams.nChannels;
      mParas._u.PCM.unBitDepth = pcmParams.nBitPerSample;
      OMX_LOGD("sample rate = %d, channel count = %d, bit depth = %d",
          mParas._u.PCM.uiSampleRate, mParas._u.PCM.unChanNr, mParas._u.PCM.unBitDepth);
      AMP_RPC(err, AMP_ADEC_SetParameters, mAmpHandle,
          AMP_ADEC_PARAIDX_RAWPCM, &mParas);
      break;
    case AMP_WMA:
      OMX_AUDIO_PARAM_WMATYPE wmaParams;
      // kAudioPortStartNumber need to get
      port = getPort(kAudioPortStartNumber);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio &&
          port->getAudioDefinition().eEncoding == OMX_AUDIO_CodingWMA) {
        wmaParams = static_cast<OmxAmpWmaPort*>(port)->getCodecParam();
      }
      mParas._d = AMP_ADEC_PARAIDX_WMA;
      mParas._u.WMA.uiBitRate = wmaParams.nBitRate;
      mParas._u.WMA.unBitDepth = wmaParams.nBitsPerSample;
      mParas._u.WMA.nBlockAlign = wmaParams.nBlockAlign;
      mParas._u.WMA.unChanNr = wmaParams.nChannels;
      mParas._u.WMA.uiSampleRate = wmaParams.nSamplingRate;
      switch(wmaParams.eFormat) {
        case OMX_AUDIO_WMAFormat9:
          mParas._u.WMA.unFormatTag = 0x0161;
          break;
        case OMX_AUDIO_WMAFormat9_Professional:
          mParas._u.WMA.unFormatTag = 0x0162;
          break;
        case OMX_AUDIO_WMAFormat9_Lossless:
          mParas._u.WMA.unFormatTag = 0x0163;
          break;
        default:
          OMX_LOGE("unsupported format %d\n", wmaParams.eFormat);
          return static_cast<OMX_ERRORTYPE>(ERR_ERRPARAM);
          break;
      }
      mParas._u.WMA.iAvgBytesPerSec = wmaParams.nBitRate / 8;
      mParas._u.WMA.iDecoderFlags = 0;
      // mParas._u.WMA.iPacketSize = ;
      // mParas._u.WMA.nPad = ;
      mParas._u.WMA.nPeakAmplitudeRef = 0;
      mParas._u.WMA.nPeakAmplitudeTarget = 0;
      mParas._u.WMA.nRmsAmplitudeRef = 0;
      mParas._u.WMA.nRmsAmplitudeTarget = 0;
      // mParas._u.WMA.ucExtraData = ;
      // mParas._u.WMA.uiChanMask = ;
      // mParas._u.WMA.uiInThresh = ;
      // mParas._u.WMA.unChanMode = wmaParams->;
      // mParas._u.WMA.unLfeMode = wmaParams->;
      static OMX_U32 kWMAExtradataSize = 32;
      mParas._u.WMA.nCbSize = kWMAExtradataSize;
      OMX_U8 data[kWMAExtradataSize];
      kdMemset(data, 0, kWMAExtradataSize);
      // TODO: Sample per block should be passed from IL client and set to
      //       data[0-3].
      data[4] = static_cast<OMX_U8>((wmaParams.nEncodeOptions) & 0xff);
      data[5] = static_cast<OMX_U8>(((wmaParams.nEncodeOptions) >> 8) & 0xff);
      data[6] = static_cast<OMX_U8>((wmaParams.nSuperBlockAlign) & 0xff);
      data[7] = static_cast<OMX_U8>(((wmaParams.nSuperBlockAlign) >> 8) & 0xff);
      data[8] = static_cast<OMX_U8>(((wmaParams.nSuperBlockAlign) >> 16) & 0xff);
      data[9] = static_cast<OMX_U8>(((wmaParams.nSuperBlockAlign) >> 24) & 0xff);
      data[10] = static_cast<OMX_U8>((wmaParams.nAdvancedEncodeOpt) & 0xff);
      data[11] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt) >> 8) & 0xff);
      data[12] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt) >> 16) & 0xff);
      data[13] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt) >> 24) & 0xff);
      data[14] = static_cast<OMX_U8>((wmaParams.nAdvancedEncodeOpt2) & 0xff);
      data[15] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt2) >> 8) & 0xff);
      data[16] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt2) >> 16) & 0xff);
      data[17] = static_cast<OMX_U8>(((wmaParams.nAdvancedEncodeOpt2) >> 24) & 0xff);
      kdMemcpy(mParas._u.WMA.ucExtraData, data, kWMAExtradataSize);
      AMP_RPC(err, AMP_ADEC_SetParameters, mAmpHandle,
          AMP_ADEC_PARAIDX_WMA, &mParas);
      break;
    case AMP_DD_DCV:
      memset(&mParas, 0, sizeof(mParas));
      mParas._d = AMP_ADEC_PARAIDX_DDP;
      mParas._u.DDP.unChanMode = ((AMP_AUDIO_CHMAP_2_0_0 == mPhyChmap)?
          AMP_AUDIO_CHMAP_2_0_0 : AMP_AUDIO_CHMAP_3_2_0);
      mParas._u.DDP.unLfeMode = ((AMP_AUDIO_CHMAP_2_0_0 == mParas._u.DDP.unChanMode) ?
          AMP_AUDIO_LFE_OFF : AMP_AUDIO_LFE_ON);
      mParas._u.DDP.unCompMode = ((-1 != mPhyDRCMode) ? static_cast<OMX_U16>((mPhyDRCMode )):
          AMP_AUDIO_COMPMODE_ON);
      mParas._u.DDP.unKMode = AMP_AUDIO_KARAOKE_BOTH_VOCAL;
      mParas._u.DDP.unStereoMode = ((-1 != mStereoMode) ? static_cast<OMX_U16>((mStereoMode )):
          AMP_AUDIO_STEREO_STEREO);
      mParas._u.DDP.unDualMode = ((-1 != mDualMode) ? static_cast<OMX_U16>((mDualMode )):
          AMP_AUDIO_DUALMODE_STEREO);
      mParas._u.DDP.uiPcmScale = 0x40000000L;
      mParas._u.DDP.uiDrcHigh = 0x40000000L;
      mParas._u.DDP.uiDrcLow = 0x40000000L;
      OMX_LOGD("mPhyChmap =%0x, chanmode = %0x, unLfeMode = %0x, "
          "mPhyDRCMode = %0x, unCompMode = %0x, unStereoMode = %0x, unDualMode = %0x",
          mPhyChmap, mParas._u.DDP.unChanMode, mParas._u.DDP.unLfeMode,
          mPhyDRCMode, mParas._u.DDP.unCompMode, mParas._u.DDP.unStereoMode,
          mParas._u.DDP.unDualMode);
      AMP_RPC(err, AMP_ADEC_SetParameters, mAmpHandle,
          AMP_ADEC_PARAIDX_DDP, &mParas);
      break;
  }
  CHECKAMPERRLOG(err, "Failed to set parameter to audio decoder");
  return static_cast<OMX_ERRORTYPE>(err);
!!!11094540.cpp!!!	clearAmpPort() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (mAudioDrm == OMX_TRUE) {
    AMP_RPC(err, AMP_DMX_ClearPortBuf, mDMXHandle, AMP_PORT_INPUT, mInputObj.uiPortIdx);
    CHECKAMPERRLOG(err, "Failed to clear DMX input port buffer");

    AMP_RPC(err, AMP_DMX_ClearPortBuf, mDMXHandle, AMP_PORT_OUTPUT, mChnlObj.uiPortIdx);
    CHECKAMPERRLOG(err, "Failed to clear DMX output port buffer");

    AMP_RPC(err, AMP_DMX_ChannelControl, mDMXHandle, &mChnlObj, AMP_DMX_CH_CTRL_OFF, 0);
    CHECKAMPERRLOG(err, "Failed to turn off DMX channel");
  } else {
    // AMP_RPC(err, AMP_ADEC_ClearPortBuf, mAmpHandle, AMP_PORT_INPUT, 0);
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11094668.cpp!!!	configDmxPort() : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_COMPONENT_CONFIG mConfig;
  static const char kUuidNoDrm[sizeof(mDrm.nUUID)] = { 0 };
  static const char kUuidWidevine[] = UUID_WIDEVINE;
  static const char kUuidPlayReady[] = UUID_PLAYREADY;
  if (kdMemcmp(mDrm.nUUID, kUuidNoDrm, sizeof(mDrm.nUUID))) {
    if (kdMemcmp(mDrm.nUUID, kUuidWidevine, sizeof(mDrm.nUUID)) == 0) {
      OMX_LOGD("Widevine");
      mAudioDrm = OMX_TRUE;
      mDrm_type = AMP_DRMSCHEME_WIDEVINE;
    } else if (kdMemcmp(mDrm.nUUID, kUuidPlayReady, sizeof(mDrm.nUUID)) == 0) {
      OMX_LOGD("PlayReady");
      mAudioDrm = OMX_TRUE;
      mDrm_type = AMP_DRMSCHEME_PLAYREADY;
    } else {
      OMX_LOGE("Unsupported DRM: "
          "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
          mDrm.nUUID[0], mDrm.nUUID[1], mDrm.nUUID[2], mDrm.nUUID[3],
          mDrm.nUUID[4], mDrm.nUUID[5], mDrm.nUUID[6], mDrm.nUUID[7],
          mDrm.nUUID[8], mDrm.nUUID[9], mDrm.nUUID[10], mDrm.nUUID[11],
          mDrm.nUUID[12], mDrm.nUUID[13], mDrm.nUUID[14], mDrm.nUUID[15]);
      return OMX_ErrorUndefined;
    }
    // create DMX
    if (mAudioDrm == OMX_TRUE) {
      OMX_LOGD("Create DMX component");
      AMP_RPC(err, AMP_FACTORY_CreateComponent, mFactory, AMP_COMPONENT_DMX,
          0, &mDMXHandle);
      CHECKAMPERRLOG(err, "Failed to create DMX component");
      mConfig._d = AMP_COMPONENT_DMX;
      mConfig._u.pDMX.mode = AMP_TUNNEL;
      // mConfig._u.pDMX.uiFlag = 0;  /* streamin mode*/
      mConfig._u.pDMX.uiInputPortNum = 1;
      mConfig._u.pDMX.uiOutputPortNum = 1;
      AMP_RPC(err, AMP_DMX_Open, mDMXHandle, &mConfig);
      CHECKAMPERRLOG(err, "Failed to open DMX handler");
    }
  }

  if (mAudioDrm == OMX_TRUE) {
    OMX_LOGD("Add DMX input port...");
    AMP_DMX_INPUT_CFG mInputCfg;

    err = AMP_SHM_Allocate(AMP_SHM_DYNAMIC,
        DMX_ES_BUF_SIZE + DMX_ES_BUF_PAD_SIZE,
        32,
        &mhInputBuf);
    CHECKAMPERRLOG(err, "Failed to allocate share memory for DRM");

    mInputCfg.InputType = AMP_DMX_INPUT_ES;
    mInputCfg.hInBuf = mhInputBuf;
    mInputCfg.uiBufSize = DMX_ES_BUF_SIZE;
    mInputCfg.uiBufPaddingSize = DMX_ES_BUF_PAD_SIZE;

    if (mDrm_type == AMP_DRMSCHEME_PLAYREADY) {
      mInputCfg.CyptCfg.SchemeType = AMP_DMX_AES_128_CTR_NO_NO;
    } else if (mDrm_type == AMP_DRMSCHEME_WIDEVINE) {
      mInputCfg.CyptCfg.SchemeType = AMP_DMX_AES_128_CBC_CTS_CLR;
    }

    AMP_RPC(err, AMP_DMX_AddInput, mDMXHandle, &mInputCfg, &mInputObj);
    CHECKAMPERRLOG(err, "Failed to add input to DMX handler");

    static_cast<OmxAmpAudioPort *>(mInputPort)->configMemInfo(mhInputBuf);

    OMX_LOGD("Add DMX output port...");
    AMP_DMX_CH_CFG ChCfg;
    AMP_DMX_CH_PROP Prop;
    ChCfg.eType = AMP_DMX_OUTPUT_AES;
    ChCfg.Tag = 0;

    mChnlObj.uiPortIdx = 0xFFFFFFFF;
    AMP_RPC(err, AMP_DMX_AddChannel, mDMXHandle, &ChCfg, &mChnlObj);
    CHECKAMPERRLOG(err, "Failed to add channel to DMX handler");

    Prop.uPropMask = AMP_DMX_CH_PROP_EVENTMASK_MASK;
    Prop.Property.EventMask = 0x10;
    AMP_RPC(err, AMP_DMX_ChannelPropSet, mDMXHandle, &mChnlObj, &Prop);
    CHECKAMPERRLOG(err, "Failed to set property to DMX handler");

    Prop.uPropMask = AMP_DMX_CH_PROP_EVENTMASK_MASK;
    Prop.Property.EventMask = 0;
    AMP_RPC(err, AMP_DMX_ChannelPropGet, mDMXHandle, &mChnlObj, &Prop);
    CHECKAMPERRLOG(err, "Failed to get property of DMX handler ");
    OMX_LOGD("Prop.Property.EventMask = 0x%x", Prop.Property.EventMask);

    AMP_RPC(err, AMP_DMX_ChannelControl, mDMXHandle, &mChnlObj, AMP_DMX_CH_CTRL_ON, 0);
    OMX_LOGD("DMX output port index %d", mChnlObj.uiPortIdx);
    CHECKAMPERRLOG(err, "Failed to control channel of DMX handler");
  }
  return static_cast<OMX_ERRORTYPE>(err);
!!!11094796.cpp!!!	initAQ() : void
  OMX_LOG_FUNCTION_ENTER;
  String8 FILE_SOURCE_URI;
  char ktmp[80] ;
  status_t ret;
  static const char* const kAudioSourcePrefix = "audio://localhost?decoder=";
  mAudioChannel = getAudioChannel();

  // TODO:some audio streams can't play by mooplayer but also use OMX.
  // In this case, it can't get RM and mAudioChannel = 0. AVSeting set the
  // audio channel is -0xff. it can use source_constants.h after chao's
  // code was merged: const int AUDIO_SOURCE_NONE_ID = -0xff;
  if ( 0 == mAudioChannel)
    mAudioChannel = - 0xff;

  mSourceControl = new SourceControl();
  if (NULL != mSourceControl) {
    sprintf(ktmp, "%s%d", kAudioSourcePrefix, mAudioChannel);
    FILE_SOURCE_URI = String8(ktmp);

    mSourceControl->getSourceByUri(FILE_SOURCE_URI, &mSourceId);
    OMX_LOGD("get sourceid :%d, sourceURL :%s", mSourceId, FILE_SOURCE_URI.string());
    if ( -1 != mSourceId) {
      mSourceControl->getDRCMode(mSourceId, &mPhyDRCMode);
      mSourceControl->getChannelMap(mSourceId, &mPhyChmap);
      mSourceControl->getStereoMode(mSourceId, &mStereoMode);
      mSourceControl->getDualMode(mSourceId, &mDualMode);
      OMX_LOGD("getDRC/chmap from avsetting, mPhyDRCMode :%0x,"
          "mPhyChmap :%0x, mStereoMode : %0x, mDualMode :%0x",
          mPhyDRCMode, mPhyChmap, mStereoMode, mDualMode);
    } else {
     OMX_LOGD("get source ID failed.");
    }
  }
  OMX_LOG_FUNCTION_EXIT;
!!!11094924.cpp!!!	getAudioChannel() : OMX_S32
#if (defined(OMX_IndexExt_h) && defined(_OMX_GTV_))
    if (mResourceInfo.nResourceSize > 0) {
      OMX_LOGD("Resouce size %d, value 0x%x",
          mResourceInfo.nResourceSize, mResourceInfo.nResource[0]);
      return mResourceInfo.nResource[0];
    }
#endif
    return 0;
!!!11095052.cpp!!!	registerEvent(in event : AMP_EVENT_CODE) : HRESULT
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }

  err = AMP_Event_RegisterCallback(mListener, event, eventHandle, static_cast<void *>(this));
  CHECK_AMP_RETURN_VAL(err, "register ADEC notify");

  if (!err) {
    AMP_RPC(err, AMP_ADEC_RegisterNotify, mAmpHandle,
        AMP_Event_GetServiceID(mListener), event);
    CHECK_AMP_RETURN_VAL(err, "register ADEC callback");
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11095180.cpp!!!	unRegisterEvent(in event : AMP_EVENT_CODE) : HRESULT
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }

  AMP_RPC(err, AMP_ADEC_UnregisterNotify, mAmpHandle,
      AMP_Event_GetServiceID(mListener), event);
  CHECK_AMP_RETURN_VAL(err, "unregister ADEC notify");

  if (!err) {
    err = AMP_Event_UnregisterCallback(mListener, event, eventHandle);
    CHECK_AMP_RETURN_VAL(err, "unregister ADEC callback");
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11095308.cpp!!!	eventHandle(in hListener : HANDLE, inout pEvent : AMP_EVENT, inout pUserData : VOID) : HRESULT
  if (!pEvent) {
    OMX_LOGE("pEvent is NULL!");
    return !SUCCESS;
  }
  AMP_ADEC_STRMINFO_EVENT *pStreamInfo = reinterpret_cast<AMP_ADEC_STRMINFO_EVENT *>(
      AMP_EVENT_PAYLOAD_PTR(pEvent));
  if (AMP_EVENT_ADEC_CALLBACK_STRMINFO == pEvent->stEventHead.eEventCode) {
    OmxAmpAudioDecoder *pComp = static_cast<OmxAmpAudioDecoder *>(pUserData);
    OMX_LOGD("event type:%d decformat:%ld streamformat:%d samplerate:%d channelnum:%d"
        "channelmode :%d lfe mode :%d bit depth:%d\n", pEvent->stEventHead.uiParam1,
        pStreamInfo->uiAdecFmt, pStreamInfo->uiStreamFmt,
        pStreamInfo->uiSampleRate, pStreamInfo->uiChannelNum,
        pStreamInfo->uiPriChanMode, pStreamInfo->uiLfeMode,
        pStreamInfo->uiBitDepth);
    if (-1 != pComp->mSourceId) {
      AudioStreamInfo streamInfo;
      streamInfo.decoder_format = pStreamInfo->uiAdecFmt;
      streamInfo.stream_format = pStreamInfo->uiStreamFmt;
      streamInfo.sample_rate = pStreamInfo->uiSampleRate;
      streamInfo.channels = pStreamInfo->uiChannelNum;
      streamInfo.pri_channel_mode = pStreamInfo->uiPriChanMode;
      streamInfo.lfe_mode = pStreamInfo->uiLfeMode;
      streamInfo.bit_depth = pStreamInfo->uiBitDepth;
      pComp->mSourceControl->notifySourceAudioInfo(pComp->mSourceId, streamInfo);
      pComp->mSourceControl->applyAQ(pComp->mSourceId);
     }
  }
  return SUCCESS;
!!!11095436.cpp!!!	resetPtsForFirstFrame(inout in_head : OMX_BUFFERHEADERTYPE) : OMX_ERRORTYPE
  // TODO: This is workaround to give a pts, but it's not accurate,
  // TODO: need player give right pts
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  if (mOutputPort->isTunneled()) {
    OMX_COMPONENTTYPE *aren =
        static_cast<OMX_COMPONENTTYPE *>(mOutputPort->getTunnelComponent());
    OmxPortImpl *clk_port = static_cast<OmxComponentImpl *>(
        aren->pComponentPrivate)->getPort(kClockPortStartNumber);
    if (clk_port->isTunneled()) {
      OMX_COMPONENTTYPE *clock =
          static_cast<OMX_COMPONENTTYPE *>(clk_port->getTunnelComponent());
      OMX_TIME_CONFIG_CLOCKSTATETYPE state;
      OMX_U32 wait_count = 20;
      InitOmxHeader(&state);
      while (wait_count > 0) {
        err = OMX_GetConfig(clock,
            OMX_IndexConfigTimeClockState, &state);
        CHECKOMXERR(err);
        if (OMX_TIME_ClockStateRunning == state.eState) {
          in_head->nTimeStamp = state.nStartTime;
          OMX_LOGD("Invalid pts, Reset the first frame pts %lld", in_head->nTimeStamp);
          return err;
        } else {
          OMX_LOGD("Invalid pts, clock eState %d, try again...", state.eState);
          usleep(5000);
          wait_count--;
          continue;
        }
      }
      OMX_LOGD("Invalid pts, reset pts failure, time out.");
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
