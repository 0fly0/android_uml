class OmxAmpVideoDecoder
!!!11120780.cpp!!!	OmxAmpVideoDecoder(in name : OMX_STRING)
  //OmxVideoDecoder(name);
  strncpy(mName, name, OMX_MAX_STRINGNAME_SIZE);
  mMark.hMarkTargetComponent = NULL;
  mMark.pMarkData = NULL;
  mShouldExit = OMX_FALSE;
  mInputFrameNum = 0;
  mOutputFrameNum = 0;
  mInBDBackNum = 0;
  mOutBDPushNum = 0;
  mStreamPosition = 0;
  mInited = OMX_FALSE;
  mOutputEOS = OMX_FALSE;
  mPaused = OMX_FALSE;
  mExtraData = NULL;
  mSourceControl = NULL;
  mVideoPlaneId = -1;
  mSourceId = -1;
  mPool = NULL;
  mPushedBdNum = 0;
  mReturnedBdNum = 0;
  mAddedPtsTagNum = 0;
  mCachedhead = NULL;
  //getAmpVideoDecoder();
!!!11120908.cpp!!!	~OmxAmpVideoDecoder()
  destroyAmpVideoDecoder();
  OMX_LOGD("destroyed");
!!!11121036.cpp!!!	initRole() : OMX_ERRORTYPE
  if (strncmp(mName, kCompNamePrefix, kCompNamePrefixLength)) {
    return OMX_ErrorInvalidComponentName;
  }
  char * role_name = mName + kCompNamePrefixLength;
  if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_AVC_SECURE, 24))
    addRole(OMX_ROLE_VIDEO_DECODER_AVC_SECURE);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_AVC, 17))
    addRole(OMX_ROLE_VIDEO_DECODER_AVC);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_H263, 18))
    addRole(OMX_ROLE_VIDEO_DECODER_H263);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_MPEG2, 19))
    addRole(OMX_ROLE_VIDEO_DECODER_MPEG2);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_MPEG4, 19))
    addRole(OMX_ROLE_VIDEO_DECODER_MPEG4);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_WMV, 17))
    addRole(OMX_ROLE_VIDEO_DECODER_WMV);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_MJPEG, 19))
    addRole(OMX_ROLE_VIDEO_DECODER_MJPEG);
#ifdef _ANDROID_
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_VPX, 17))
    addRole(OMX_ROLE_VIDEO_DECODER_VPX);
#endif
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_VP8, 17))
    addRole(OMX_ROLE_VIDEO_DECODER_VP8);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_VC1, 17))
    addRole(OMX_ROLE_VIDEO_DECODER_VC1);
  else if (!strncmp(role_name, OMX_ROLE_VIDEO_DECODER_MSMPEG4, 21))
    addRole(OMX_ROLE_VIDEO_DECODER_MSMPEG4);
#endif
  else if (!strncmp(role_name, "video_decoder", 13)) {
    addRole(OMX_ROLE_VIDEO_DECODER_AVC_SECURE);
    addRole(OMX_ROLE_VIDEO_DECODER_AVC);
    addRole(OMX_ROLE_VIDEO_DECODER_H263);
    addRole(OMX_ROLE_VIDEO_DECODER_MPEG2);
    addRole(OMX_ROLE_VIDEO_DECODER_MPEG4);
    addRole(OMX_ROLE_VIDEO_DECODER_WMV);
    addRole(OMX_ROLE_VIDEO_DECODER_MJPEG);
#ifdef _ANDROID_
    addRole(OMX_ROLE_VIDEO_DECODER_VPX);
#endif
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
    addRole(OMX_ROLE_VIDEO_DECODER_VP8);
    addRole(OMX_ROLE_VIDEO_DECODER_VC1);
    addRole(OMX_ROLE_VIDEO_DECODER_MSMPEG4);
#endif
  } else {
    return OMX_ErrorInvalidComponentName;
  }
  return OMX_ErrorNone;
!!!11121164.cpp!!!	initPort() : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;
  if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_AVC, 17)) {
    mInputPort = new  OmxAmpAvcPort(kVideoPortStartNumber, OMX_DirInput);
  } else if  (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_H263, 18)) {
    mInputPort = new  OmxAmpH263Port(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_MPEG2, 19)) {
    mInputPort = new  OmxAmpMpeg2Port(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_MPEG4, 19)) {
    mInputPort = new  OmxAmpMpeg4Port(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_WMV, 17)) {
    mInputPort = new  OmxAmpWMVPort(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_MJPEG, 19)) {
    mInputPort = new   OmxAmpMjpegPort(kVideoPortStartNumber, OMX_DirInput);
#ifdef _ANDROID_
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_VPX, 17)) {
    mInputPort = new  OmxAmpVP8Port(kVideoPortStartNumber, OMX_DirInput);
#endif
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_VP8, 17)) {
    mInputPort = new  OmxAmpVP8Port(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_VC1, 17)) {
    mInputPort = new  OmxAmpVC1Port(kVideoPortStartNumber, OMX_DirInput);
  } else if (!strncmp(mActiveRole, OMX_ROLE_VIDEO_DECODER_MSMPEG4, 21)) {
    mInputPort = new  OmxAmpMsMpeg4Port(kVideoPortStartNumber, OMX_DirInput);
#endif
  } else {
    mInputPort = new OmxAmpVideoPort(kVideoPortStartNumber, OMX_DirInput);
  }
  addPort(mInputPort);
  mOutputPort = new OmxAmpVideoPort(kVideoPortStartNumber + 1, OMX_DirOutput);
  addPort(mOutputPort);
  mUseNativeBuffers = OMX_FALSE;
  OMX_PARAM_PORTDEFINITIONTYPE def;
  mInputPort->getDefinition(&def);
  def.nBufferCountActual = 60;
  mInputPort->setDefinition(&def);
  mOutputPort->getDefinition(&def);
  def.nBufferSize = 1920 * 1088 * 2;
  def.nBufferCountActual = 19;
  def.nBufferAlignment = 64;
  mOutputPort->setDefinition(&def);
  return err;
!!!11121292.cpp!!!	componentDeInit(in hComponent : OMX_HANDLETYPE) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OmxComponent *comp = reinterpret_cast<OmxComponent *>(
      reinterpret_cast<OMX_COMPONENTTYPE *>(hComponent)->pComponentPrivate);
  OmxAmpVideoDecoder *vdec = static_cast<OmxAmpVideoDecoder *>(comp);
  delete vdec;
  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11121420.cpp!!!	getParameter(in index : OMX_INDEXTYPE, in params : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;
  switch (index) {
    case OMX_IndexParamVideoPortFormat: {
      OMX_VIDEO_PARAM_PORTFORMATTYPE *video_param =
          reinterpret_cast<OMX_VIDEO_PARAM_PORTFORMATTYPE *>(params);
      err = CheckOmxHeader(video_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(video_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (mInputPort->getPortIndex() == video_param->nPortIndex) {
        if (video_param->nIndex >= NELM(kFormatSupport)) {
          err = OMX_ErrorNoMore;
          break;
        }
        const VideoFormatType *v_fmt = &kFormatSupport[video_param->nIndex];
        video_param->eCompressionFormat = v_fmt->eCompressionFormat;
        video_param->eColorFormat = v_fmt->eColorFormat;
        video_param->xFramerate = v_fmt->xFramerate;
      } else {
        if (video_param->nIndex >= 1) {
          err = OMX_ErrorNoMore;
          break;
        }
        OMX_VIDEO_PORTDEFINITIONTYPE &v_def = mOutputPort->getVideoDefinition();
        video_param->eCompressionFormat = v_def.eCompressionFormat;
        video_param->eColorFormat = v_def.eColorFormat;
        video_param->xFramerate = v_def.xFramerate;
      }
      break;
    }
    case OMX_IndexParamVideoProfileLevelQuerySupported:  {
      OMX_VIDEO_PARAM_PROFILELEVELTYPE *prof_lvl =
          reinterpret_cast<OMX_VIDEO_PARAM_PROFILELEVELTYPE *>(params);
      err = CheckOmxHeader(prof_lvl);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(prof_lvl->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo) {
        if (port->getVideoDefinition().eCompressionFormat == OMX_VIDEO_CodingAVC) {
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
          OMX_U32 idx = prof_lvl->nIndex;
#else
          OMX_U32 idx = prof_lvl->nProfileIndex;
#endif
          if (idx >= NELM(kAvcProfileLevel)){
            err = OMX_ErrorNoMore;
          } else {
            prof_lvl->eProfile = kAvcProfileLevel[idx].eProfile;
            prof_lvl->eLevel= kAvcProfileLevel[idx].eLevel;
          }
        } else {
          err = OMX_ErrorNoMore;
        }
      }
      break;
    }
    case OMX_IndexParamVideoProfileLevelCurrent:{
      OMX_VIDEO_PARAM_PROFILELEVELTYPE *prof_lvl =
          reinterpret_cast<OMX_VIDEO_PARAM_PROFILELEVELTYPE *>(params);
      err = CheckOmxHeader(prof_lvl);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(prof_lvl->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo) {
        if (port->getVideoDefinition().eCompressionFormat == OMX_VIDEO_CodingAVC) {
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
          OMX_U32 idx = prof_lvl->nIndex;
#else
          OMX_U32 idx = prof_lvl->nProfileIndex;
#endif
          prof_lvl->eProfile = kAvcProfileLevel[idx].eProfile;
          prof_lvl->eLevel= kAvcProfileLevel[idx].eLevel;
        }
      }
      break;
    }
    case OMX_IndexParamVideoAvc: {
      OMX_VIDEO_PARAM_AVCTYPE* codec_param =
          reinterpret_cast<OMX_VIDEO_PARAM_AVCTYPE*>(params);
      err = CheckOmxHeader(codec_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(codec_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo &&
          port->getVideoDefinition().eCompressionFormat == OMX_VIDEO_CodingAVC)
        *codec_param = ((OmxAmpAvcPort*)port)->getCodecParam();
      break;
    }
    case OMX_IndexParamVideoH263:
      break;
    case OMX_IndexParamVideoMpeg4:
      break;
#ifdef _ANDROID_
    case OMX_IndexAndroidGetNativeBufferUsage: {
      android::GetAndroidNativeBufferUsageParams* getUsage_nativebuffer =
          reinterpret_cast<android::GetAndroidNativeBufferUsageParams*>(params);
      getUsage_nativebuffer->nUsage = 0;
      OMX_LOGD("GetNativeBufferUsage %lu", getUsage_nativebuffer->nUsage);
      break;
    }
#endif
    default:
      return OmxComponentImpl::getParameter(index, params);
  }
  return err;
!!!11121548.cpp!!!	setParameter(in index : OMX_INDEXTYPE, in params : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;
  switch (index) {
    case OMX_IndexParamVideoPortFormat: {
      OMX_VIDEO_PARAM_PORTFORMATTYPE* video_param =
          reinterpret_cast<OMX_VIDEO_PARAM_PORTFORMATTYPE*>(params);
      err = CheckOmxHeader(video_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(video_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo) {
        if (isVideoParamSupport(video_param)) {
          port->setVideoParam(video_param);
          port->updateDomainDefinition();
        } else {
          // TODO: find a proper error NO.
          err = OMX_ErrorNotImplemented;
        }
      }
      break;
    }
    case OMX_IndexParamVideoProfileLevelCurrent:  {
      OMX_VIDEO_PARAM_PROFILELEVELTYPE* prof_lvl =
          reinterpret_cast<OMX_VIDEO_PARAM_PROFILELEVELTYPE*>(params);
      err = CheckOmxHeader(prof_lvl);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(prof_lvl->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo) {
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
        if (prof_lvl->eCodecType == OMX_VIDEO_CodingAVC) {
          if (prof_lvl->nIndex >= NELM(kAvcProfileLevel)){
            err = OMX_ErrorBadParameter;
            break;
          }
          mProfile = prof_lvl->eProfile;
          mLevel = prof_lvl->eLevel;
        } else {
          err = OMX_ErrorNotImplemented;
        }
#else
        if (isProfileLevelSupport(prof_lvl)){
          mProfile = prof_lvl->eProfile;
          mLevel = prof_lvl->eLevel;
        } else {
          err = OMX_ErrorNotImplemented;
        }
#endif
      }
      break;
    }
#ifdef _ANDROID_
    case OMX_IndexAndroidEnableNativeBuffers: {
      OMX_LOGD("EnableNativeBuffers");
      android::EnableAndroidNativeBuffersParams*  enable_nativebuffer =
          reinterpret_cast<android::EnableAndroidNativeBuffersParams*>(params);
      err = CheckOmxHeader(enable_nativebuffer);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("EnableNativeBuffers error %d", err);
        break;
      }
      if (enable_nativebuffer->nPortIndex < 1) {
        err = OMX_ErrorBadPortIndex;
        OMX_LOGE("EnableNativeBuffers error %d", err);
        break;
      }
      OmxPortImpl* port = getPort(enable_nativebuffer->nPortIndex);
      if (!port) {
        err = OMX_ErrorUndefined;
        OMX_LOGE("EnableNativeBuffers error %d", err);
        break;
      }
      mUseNativeBuffers = enable_nativebuffer->enable;
      OMX_U32 size;
      OMX_U32 stride, height;
      OMX_COLOR_FORMATTYPE eFormat;
      OMX_PARAM_PORTDEFINITIONTYPE definition;
      port->getDefinition(&definition);
      stride = definition.format.video.nFrameWidth;
      height = definition.format.video.nFrameHeight;
      eFormat = static_cast<OMX_COLOR_FORMATTYPE>(HAL_PIXEL_FORMAT_UYVY);
      definition.format.video.nStride = stride;
      definition.format.video.eColorFormat = eFormat;
      stride = (stride + kWidthAlignment - 1) & (~(kWidthAlignment - 1));
      height = (height + kHeightAlignment - 1) & (~(kHeightAlignment - 1));
      definition.format.video.nFrameWidth = stride;
      definition.format.video.nFrameHeight = height;
      size = height * stride * 2;
      definition.nBufferSize = size;
      port->setDefinition(&definition);
      port->updateDomainParameter();
      if (stride <= 176 && height <= 144) {
        // Use 64k input buffer for resolution below QCIF.
        OmxPortImpl *in_port = getPort(kVideoPortStartNumber);
        in_port->setBufferSize(65536);
      }
      break;
    }
    case OMX_IndexAndroidUseNativeBuffer: {
      OMX_LOGD("UseNativeBuffer");
      android::UseAndroidNativeBufferParams*  use_nativebuffer =
          reinterpret_cast<android::UseAndroidNativeBufferParams*>(params);
      err = CheckOmxHeader(use_nativebuffer);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("UseNativeBuffer error %d", err);
        break;
      }
      if (!mUseNativeBuffers) {
        err = OMX_ErrorUndefined;
        OMX_LOGE("UseNativeBuffer error %d", err);
        break;
      }
      if (use_nativebuffer->nPortIndex < 1) {
        err = OMX_ErrorBadPortIndex;
        OMX_LOGE("UseNativeBuffer error %d", err);
        break;
      }
      OmxPortImpl* port = getPort(use_nativebuffer->nPortIndex);
      if (!port) {
        err = OMX_ErrorUndefined;
        OMX_LOGE("UseNativeBuffer error %d", err);
        break;
      }
      OMX_BUFFERHEADERTYPE **bufHdr = use_nativebuffer->bufferHeader;
      // port->mUseNativeBuffer = OMX_TRUE;
      GraphicBuffer *gfx = static_cast<GraphicBuffer *>(
          use_nativebuffer->nativeBuffer.get());
      uint32_t usage = GraphicBuffer::USAGE_SW_READ_OFTEN |
          GraphicBuffer::USAGE_SW_WRITE_RARELY;
      void *buf = NULL;
      gfx->lock(usage, &buf);
      err = useBuffer(
          bufHdr,
          use_nativebuffer->nPortIndex,
          use_nativebuffer->pAppPrivate,
          getNativeBufferSize(gfx),
          static_cast<OMX_U8 *>(buf));
      gfx->unlock();
      break;
    }
#endif
    case OMX_IndexParamVideoAvc: {
      OMX_VIDEO_PARAM_AVCTYPE* codec_param =
          reinterpret_cast<OMX_VIDEO_PARAM_AVCTYPE*>(params);
      err = CheckOmxHeader(codec_param);
      if (OMX_ErrorNone != err) {
        break;
      }
      OmxPortImpl* port = getPort(codec_param->nPortIndex);
      if (NULL == port) {
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainVideo &&
          port->getVideoDefinition().eCompressionFormat == OMX_VIDEO_CodingAVC)
        static_cast<OmxAmpAvcPort *>(port)->setCodecParam(codec_param);
      break;
    }
    case OMX_IndexParamVideoH263:
      break;
    case OMX_IndexParamVideoMpeg4:
      break;
    default:
      return OmxComponentImpl::setParameter(index, params);
  }
  return err;
!!!11121676.cpp!!!	prepare() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  // mediahelper init
  if (mediainfo_buildup()) {
    OMX_LOGD("Media helper build success");
  } else {
    OMX_LOGE("Media helper build fail");
  }
  // remove the dumped data
  mediainfo_remove_dumped_data(MEDIA_VIDEO);

  err = getAmpVideoDecoder();
  CHECKAMPERRLOG(err, "Failed to get AMP video decoder");

  AMP_MEDIA_TYPE amp_codec = getAmpVideoCodecType(
      mInputPort->getVideoDefinition().eCompressionFormat);
  if (NULL == amp_codec) {
    OMX_LOGE("can not find the AMP vdec type.");
    return OMX_ErrorUndefined;
  }
  OMX_LOGD("Amp video codec type is %d", amp_codec);
  if (amp_codec == MEDIA_VES_AVC) {
    mExtraData = new AvcExtraData();
  } else {
    mExtraData = new CodecExtraData();
  }

  AMP_COMPONENT_CONFIG config;
  kdMemset(&config, 0 ,sizeof(config));
  config._d = AMP_COMPONENT_VDEC;
  if (mOutputPort->isTunneled()) {
    config._u.pVDEC.mode = AMP_TUNNEL;
  } else {
    config._u.pVDEC.mode = AMP_NON_TUNNEL;
  }
  config._u.pVDEC.uiType = amp_codec;
  config._u.pVDEC.uiWidth = 0;
  config._u.pVDEC.uiHeight = 0;
  config._u.pVDEC.uiFrameRate = 0;
  char kUuidNoDrm[sizeof(mDrm.nUUID)] = { 0 };
  if (0 == kdMemcmp(mDrm.nUUID, kUuidPlayReady, sizeof(mDrm.nUUID))) {
    OMX_LOGD("Playready Tvp");
    AMP_SHM_HANDLE es_handle;
    static_cast<OmxAmpVideoPort *>(mInputPort)->configDrm(kPlayReadyType, &es_handle);
    config._u.pVDEC.uiFlag = kFrameInModeMask;
    config._u.pVDEC.uiSecureType = tsp_vdhub_stream_type_playready;
    config._u.pVDEC.uiSHMHandle = es_handle;
    config._u.pVDEC.uiSHMSize = es_buf_size;
    config._u.pVDEC.uiPadSize = es_buf_pad_size;
  } else if (0 == kdMemcmp(mDrm.nUUID, kUuidWidevine, sizeof(mDrm.nUUID))) {
    OMX_LOGD("Widevine Tvp");
    AMP_SHM_HANDLE es_handle;
    static_cast<OmxAmpVideoPort *>(mInputPort)->configDrm(kWideVineType, &es_handle);
    config._u.pVDEC.uiFlag = kFrameInModeMask;
    config._u.pVDEC.uiSecureType = tsp_vdhub_stream_type_widevine;
    config._u.pVDEC.uiSHMHandle = es_handle;
    config._u.pVDEC.uiSHMSize = es_buf_size;
    config._u.pVDEC.uiPadSize = es_buf_pad_size;
  } else if (0 != kdMemcmp(mDrm.nUUID, kUuidNoDrm, sizeof(mDrm.nUUID))) {
    OMX_LOGD("Unsupported DRM: "
        "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        mDrm.nUUID[0], mDrm.nUUID[1], mDrm.nUUID[2], mDrm.nUUID[3],
        mDrm.nUUID[4], mDrm.nUUID[5], mDrm.nUUID[6], mDrm.nUUID[7],
        mDrm.nUUID[8], mDrm.nUUID[9], mDrm.nUUID[10], mDrm.nUUID[11],
        mDrm.nUUID[12], mDrm.nUUID[13], mDrm.nUUID[14], mDrm.nUUID[15]);
      return OMX_ErrorUndefined;
  } else {
    if (mOutputPort->isTunneled()) {
      OMX_U32 ret = AMP_CBUFCreate(stream_in_buf_size, 0, stream_in_bd_num,
          stream_in_align_size, true, &mPool, false, 0);
      if (AMPCBUF_SUCCESS != ret) {
        OMX_LOGE("Cbuf Create Error %u.", ret);
        return OMX_ErrorUndefined;
      }
      config._u.pVDEC.uiFlag = kStreamInModeMask;
      OMX_PARAM_PORTDEFINITIONTYPE def;
      mInputPort->getDefinition(&def);
      def.nBufferCountActual = 4;
      mInputPort->setDefinition(&def);
    } else {
      config._u.pVDEC.uiFlag = kFrameInModeMask;
      OMX_PARAM_PORTDEFINITIONTYPE def;
      mInputPort->getDefinition(&def);
      def.nBufferCountActual = 16;
      mInputPort->setDefinition(&def);
    }
  }
  AMP_RPC(err, AMP_VDEC_Open, mAmpHandle, &config);
  CHECKAMPERRLOG(err, "Failed to open VDEC handler");

  AMP_PORT_INFO input_port_info, output_port_info;

  AMP_RPC(err, AMP_VDEC_QueryPort, mAmpHandle,
      AMP_PORT_INPUT, 0, &input_port_info);
  CHECKAMPERRLOG(err, "Failed to query info of VDEC input port");
  err = AMP_ConnectApp(mAmpHandle, AMP_PORT_INPUT,
      0, pushBufferDone, static_cast<void *>(this));
  CHECKAMPERRLOG(err, "Failed to connect video decoder with VDEC input port");

  if (!mOutputPort->isTunneled()) {
    AMP_RPC(err, AMP_VDEC_QueryPort, mAmpHandle, AMP_PORT_OUTPUT,
        0, &output_port_info);
    CHECKAMPERRLOG(err, "Failed to query info of VDEC output port");
    err = AMP_ConnectApp(mAmpHandle, AMP_PORT_OUTPUT,
        0, pushBufferDone, static_cast<void *>(this));
    CHECKAMPERRLOG(err, "Failed to connect video decoder with VDEC output port");
  }

  // Set the frame rate to vdec for calculating the pts of the output frames if the input frame
  // pts is invalid value.
  OMX_LOGD("xFramerate is %u", mInputPort->getVideoDefinition().xFramerate);
  AMP_RPC(err, AMP_VDEC_SetCmdP2, mAmpHandle, AMP_VDEC_CMD_SET_FRAME_RATE,
      mInputPort->getVideoDefinition().xFramerate, 0x10000);
  CHECKAMPERRLOG(err, "Failed to set video frame rate.");

  // Register a callback so that it can receive event - for example resolution changed -from VDEC.
  mListener = AMP_Event_CreateListener(AMP_EVENT_TYPE_MAX, 0);
  if (mListener) {
    err = registerEvent(AMP_EVENT_API_VDEC_CALLBACK);
    CHECKAMPERRLOG(err, "Failed to RegisterEvent with VDEC");
  }
  memset(&mVdecInfo, 0 , sizeof(mVdecInfo));
  mSourceControl = new SourceControl();
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11121804.cpp!!!	preroll() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11121932.cpp!!!	start() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  err = registerBds(static_cast<OmxAmpVideoPort *>(mInputPort));
  CHECKOMXERR(err);
  err = registerBds(static_cast<OmxAmpVideoPort *>(mOutputPort));
  CHECKOMXERR(err);
  OMX_LOGD("Create decoding thread");
  mPauseLock = kdThreadMutexCreate(KD_NULL);
  mPauseCond = kdThreadCondCreate(KD_NULL);
  mThread = kdThreadCreate(mThreadAttr, threadEntry,(void *)this);
  err = setAmpState(AMP_EXECUTING);
  CHECKOMXERR(err);
  bindPQSource();
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11122060.cpp!!!	pause() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  mPaused = OMX_TRUE;
  mShouldExit = OMX_TRUE;
  err = setAmpState(AMP_PAUSED);
  CHECKOMXERR(err);
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11122188.cpp!!!	resume() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  err = setAmpState(AMP_EXECUTING);
  CHECKOMXERR(err);
  if (mInputPort->getCachedBuffer() != NULL) {
    returnBuffer(mInputPort, mInputPort->getCachedBuffer());
  }
  if (mOutputPort->getCachedBuffer() != NULL) {
    returnBuffer(mOutputPort, mOutputPort->getCachedBuffer());
  }
  mShouldExit = OMX_FALSE;
  kdThreadMutexLock(mPauseLock);
  mPaused = OMX_FALSE;
  kdThreadCondSignal(mPauseCond);
  kdThreadMutexUnlock(mPauseLock);
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11122316.cpp!!!	stop() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  mShouldExit = OMX_TRUE;
  if (mPauseLock) {
    kdThreadMutexLock(mPauseLock);
    mPaused = OMX_FALSE;
    kdThreadCondSignal(mPauseCond);
    kdThreadMutexUnlock(mPauseLock);
  }
  if (mThread) {
    // post buffer may cause the sem value not correct
    // TODO: need correct the value
    if (mInputPort->isEmpty())
      mInputPort->postBuffer();
    if (mOutputPort->isEmpty())
      mOutputPort->postBuffer();
    void *retval;
    KDint ret;
    ret = kdThreadJoin(mThread, &retval);
    OMX_LOGD("Stop decoding thread");
    mThread = NULL;
  }
  if (mPauseLock) {
    kdThreadMutexFree(mPauseLock);
    mPauseLock = NULL;
  }
  if (mPauseCond) {
    kdThreadCondFree(mPauseCond);
    mPauseCond = NULL;
  }
  if (NULL != mCachedhead) {
    OMX_LOGD("return the cached buffer header.");
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  err = setAmpState(AMP_IDLE);
  CHECKOMXERR(err);
  // TODO: Change to wait event when AMP side is ready
  // Waiting for input/output buffers back
  OMX_U32 wait_count = 100;
  while ((mInputFrameNum > mInBDBackNum || mOutBDPushNum > mOutputFrameNum)
      && wait_count > 0) {
    usleep(5000);
    wait_count--;
  }
  if (!wait_count) {
    OMX_LOGE("There are %u inbuf and %u outbuf have not returned.",
        mInputFrameNum - mInBDBackNum, mOutBDPushNum - mOutputFrameNum);
  }
  if (NULL != mPool) {
    wait_count = 100;
    while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("There are %u pushed Bd not returned.", mPushedBdNum - mReturnedBdNum);
    }
    if (AMPCBUF_SUCCESS != AMP_CBUFDestroy(mPool)) {
      OMX_LOGE("Cbuf destroy pool error.");
    }
  }
  returnCachedBuffers(mInputPort);
  returnCachedBuffers(mOutputPort);
  err = unregisterBds(static_cast<OmxAmpVideoPort *>(mInputPort));
  CHECKOMXERR(err);
  err = unregisterBds(static_cast<OmxAmpVideoPort *>(mOutputPort));
  CHECKOMXERR(err);
  mInited = OMX_FALSE;
  mStreamPosition = 0;
  mEOS = OMX_FALSE;
  mOutputEOS = OMX_FALSE;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11122444.cpp!!!	release() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  // deinit mediahelper
  mediainfo_teardown();
  if (mExtraData) {
    delete mExtraData;
    mExtraData = NULL;
  }
  HRESULT err = SUCCESS;
  if (mListener) {
    err = unRegisterEvent(AMP_EVENT_API_VDEC_CALLBACK);
    CHECKAMPERRLOG(err, "Failed to unRegisterEvent with VDEC");
    CHECKAMPERR(AMP_Event_DestroyListener(mListener));
    mListener = NULL;
  }
  err = AMP_DisconnectApp(mAmpHandle, AMP_PORT_INPUT,
      0, pushBufferDone);
  CHECKAMPERRLOG(err, "Failed to disconnect video decoder with VDEC input port");

  if (!mOutputPort->isTunneled()) {
    err = AMP_DisconnectApp(mAmpHandle, AMP_PORT_OUTPUT,
        0, pushBufferDone);
    CHECKAMPERRLOG(err, "Failed to disconnect video decoder with VDEC output port");
  }
  AMP_RPC(err, AMP_VDEC_Close, mAmpHandle);
  CHECKAMPERRLOG(err, "Failed to close VDEC");

  err = destroyAmpVideoDecoder();
  CHECKAMPERRLOG(err, "Failed to destroy VDEC");

  if (OMX_TRUE == static_cast<OmxAmpVideoPort *>(mInputPort)->mIsDrm) {
    OMX_LOGD("releaseDrm");
    static_cast<OmxAmpVideoPort *>(mInputPort)->releaseDrm();
  }

  if (NULL != mSourceControl) {
    if (-1 != mSourceId) {
      mSourceControl->exitSource(mSourceId);
      mSourceId = -1;
    }
    delete mSourceControl;
    mSourceControl = NULL;
   }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11122572.cpp!!!	flush() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OMX_U32 wait_count = 100;
  if (!mOutputPort->isTunneled()) {
    // TODO: Waiting for clear the input/output buffer queue
    while ((!mInputPort->isEmpty() || !mOutputPort->isEmpty())
        && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("The buffer queue have not been cleared.");
    }
  }
  if (NULL != mCachedhead) {
    OMX_LOGD("return the cached buffer header.");
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  err = setAmpState(AMP_IDLE);
  CHECKOMXERR(err);
  // clear dumped data
  MEDIA_S8 value[MEDIA_VALUE_LENGTH];
  if (mediainfo_get_property(
      reinterpret_cast<const MEDIA_S8 *>("mediainfo_clear_dump"), value) &&
      kdMemcmp(value, "1", 1) == 0) {
    mediainfo_remove_dumped_data(MEDIA_VIDEO);
  }
  // TODO: Waiting for input/output buffer back
  wait_count = 100;
  while ((mInputFrameNum > mInBDBackNum || mOutBDPushNum > mOutputFrameNum)
      && wait_count > 0) {
    usleep(5000);
    wait_count--;
  }
  if (!wait_count) {
    OMX_LOGE("There are %u inbuf and %u outbuf have not returned.",
        mInputFrameNum - mInBDBackNum, mOutBDPushNum - mOutputFrameNum);
  }
  if (NULL != mPool) {
    wait_count = 100;
    while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("There are %u pushed Bd not returned.", mPushedBdNum - mReturnedBdNum);
    }
    if (AMPCBUF_SUCCESS != AMP_CBUFReset(mPool)) {
      OMX_LOGE("Cbuf AMP_CBUFReset error.");
    }
    mPushedBdNum = 0;
    mReturnedBdNum = 0;
    mAddedPtsTagNum = 0;
  }
  returnCachedBuffers(mInputPort);
  returnCachedBuffers(mOutputPort);
  if (OMX_TRUE == static_cast<OmxAmpVideoPort *>(mInputPort)->mIsDrm) {
    static_cast<OmxAmpVideoPort *>(mInputPort)->clearMemCtrlIndex();
  }
  if (getState() == OMX_StateExecuting) {
    err = setAmpState(AMP_EXECUTING);
  } else if (getState() == OMX_StatePause) {
    err = setAmpState(AMP_PAUSED);
  }
  CHECKOMXERR(err);
  mStreamPosition = 0;
  mInited = OMX_FALSE;
  mEOS = OMX_FALSE;
  mOutputEOS = OMX_FALSE;
  mInputFrameNum = 0;
  mOutputFrameNum = 0;
  mInBDBackNum = 0;
  mOutBDPushNum = 0;
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11122700.cpp!!!	pushBufferLoop() : void
  AMP_BD_ST *in_buf = NULL, *out_buf = NULL;
  OMX_BUFFERHEADERTYPE *in_head = NULL, *out_head = NULL;
  OMX_BOOL isCaching = OMX_FALSE;
Loop_start:
  OMX_LOGD("Start decoding loop");
  while (!mShouldExit) {
    //Get input Buffer
    if (!mInputPort->isEmpty() || NULL != mCachedhead) {
      if (NULL != mCachedhead) {
        in_head = mCachedhead;
        isCaching = OMX_TRUE;
        OMX_LOGV("Use the cached input buffer %p", in_head);
      } else {
        in_head = mInputPort->popBuffer();
        mCachedhead = in_head;
        isCaching = OMX_FALSE;
        OMX_LOGV("Got input buffer %p", in_head);
      }
      if (NULL != in_head) {
        if (mInputPort->isFlushing()) {
          OMX_LOGD("Return input buffer when flushing");
          returnBuffer(mInputPort, in_head);
          in_head = NULL;
          mCachedhead = NULL;
          continue;
        }
        // Process start frame
        if (in_head->nFlags & OMX_BUFFERFLAG_STARTTIME) {
        }
        if (in_head->nFlags & OMX_BUFFERFLAG_EOS) {
          OMX_LOGD("Meet EOS Frame, wait for stop");
          mEOS = OMX_TRUE;
        }
        if (in_head->hMarkTargetComponent != NULL) {
          mMark.hMarkTargetComponent = in_head->hMarkTargetComponent;
          mMark.pMarkData = in_head->pMarkData;
        }
        // Process codec config data
        if (in_head->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
          char *pData = reinterpret_cast<char *>(in_head->pBuffer)
              + in_head->nOffset;
          mExtraData->add(pData, in_head->nFilledLen);
          in_head->nFilledLen = 0;
          in_head->nOffset = 0;
          returnBuffer(mInputPort, in_head);
          mCachedhead = NULL;
          mInited = OMX_FALSE;
          continue;
        }
        CryptoInfo *cryptoInfo = NULL;
        if (in_head->nFlags & OMX_BUFFERFLAG_EXTRADATA) {
          OMX_U32 offset = (in_head->nOffset +in_head->nFilledLen + 3) / 4 * 4;
          OMX_OTHER_EXTRADATATYPE *extraData =
              reinterpret_cast<OMX_OTHER_EXTRADATATYPE *>(in_head->pBuffer + offset);
          while (OMX_ExtraDataNone != extraData->eType) {
            if (static_cast<OMX_EXTRADATATYPE>(OMX_ExtraDataCryptoInfo) ==
                extraData->eType) {
              CryptoInfo *hCryptoInfo = reinterpret_cast<CryptoInfo *>(extraData->data);
              OMX_U32 size = sizeof(CryptoInfo) + sizeof(CryptoInfo::SubSample) *
                  (hCryptoInfo->mNumSubSamples - 1);
              cryptoInfo = reinterpret_cast<CryptoInfo *>(kdMalloc(size));
              kdMemcpy(cryptoInfo, extraData->data, size);
            }
            offset += extraData->nSize;
            extraData = reinterpret_cast<OMX_OTHER_EXTRADATATYPE *>(
                in_head->pBuffer + offset);
          }
        }
        if (mInited == OMX_FALSE) {
          OMX_U32 codec_data_size = mExtraData->getExtraDataSize();
          OMX_U8 *data = in_head->pBuffer + in_head->nOffset;
          kdMemmove(data + codec_data_size, data, in_head->nFilledLen);
          mExtraData->merge(data, codec_data_size);
          in_head->nFilledLen += codec_data_size;
          if (NULL != cryptoInfo) {
            cryptoInfo->mSubSamples[0].mNumBytesOfClearData += codec_data_size;
          }
          (static_cast<OmxAmpVideoPort *>(mInputPort))->setCodecDataSize(codec_data_size);
          mInited = OMX_TRUE;
        }
        mInputFrameNum++;
        if (in_head->nTimeStamp < 0 && mStreamPosition == 0) {
            resetPtsForFirstFrame(in_head);
        }
        OMX_LOGD("<In> %d/%d, size %d\tpts "TIME_FORMAT "\tflag %s",
            mInBDBackNum, mInputFrameNum, in_head->nFilledLen,
            TIME_ARGS(in_head->nTimeStamp),
            GetOMXBufferFlagDescription(in_head->nFlags));
        //dump_bytes(in_head->pBuffer + in_head->nOffset, in_head->nFilledLen);
        // dump es data
        MEDIA_S8 value[MEDIA_VALUE_LENGTH];
        if (mediainfo_get_property(
            reinterpret_cast<const MEDIA_S8 *>("mediainfo_dump_video_es_data"), value) &&
            kdMemcmp(value, "1", 1) == 0 && isCaching != OMX_TRUE) {
          mediainfo_dump_data(MEDIA_VIDEO, MEDIA_DUMP_ES,
              in_head->pBuffer + in_head->nOffset, in_head->nFilledLen);
        }
        AmpBuffer *amp_buffer =  static_cast<AmpBuffer *>(
            in_head->pPlatformPrivate);
        if (OMX_FALSE == static_cast<OmxAmpVideoPort *>(mInputPort)->mIsDrm) {
          if (NULL != mPool) {
            OMX_U32 ret;
            OMX_U32 flag = (mEOS == OMX_TRUE) ? AMP_MEMINFO_FLAG_EOS_MASK : 0;
            if (!isCaching) {
              (static_cast<OmxAmpVideoPort *>(mInputPort))->formatEsData(in_head, OMX_FALSE);
            }
            if (flag & AMP_MEMINFO_FLAG_EOS_MASK && !isCaching) {
              //padding 64k to enable the vdec handle eos event.
              kdMemset(in_head->pBuffer + in_head->nOffset + in_head->nFilledLen, 0x88,
                stream_in_eos_padding_size);
              in_head->nFilledLen += stream_in_eos_padding_size;
            }
            ret = AMP_CBUFWriteData(mPool, in_head->pBuffer + in_head->nOffset,
                in_head->nFilledLen, flag, NULL);
            if (AMPCBUF_SUCCESS == ret) {
              // Because the free space of the Bd is only 512 Bytes, the Num of pts tag in one Bd
              // is limited to 12.
              if (mAddedPtsTagNum <= stream_in_max_pts_tag_num) {
                AMP_BDTAG_UNITSTART pts_tag;
                OMX_U32 offset = mStreamPosition % stream_in_buf_size;
                kdMemset(&pts_tag, 0, sizeof(AMP_BDTAG_UNITSTART));
                pts_tag.Header = {AMP_BDTAG_BS_UNITSTART_CTRL, sizeof(AMP_BDTAG_UNITSTART)};
                convertUsto90K(in_head->nTimeStamp, &pts_tag.uPtsHigh, &pts_tag.uPtsLow);
                pts_tag.uStrmPos = mStreamPosition;
                AMP_CBUFInsertTag(mPool, reinterpret_cast<UINT8 *>(&pts_tag), offset);
                mAddedPtsTagNum++;
              }
              mStreamPosition += in_head->nFilledLen;
              mStreamPosition &= kStreamPositionMask;
              returnBuffer(mInputPort, in_head);
              mCachedhead = NULL;
              mInBDBackNum++;
            } else if (AMPCBUF_LACKSPACE == ret) {
              OMX_LOGV("Cbuf Lack of space.");
              mInputFrameNum--;
            } else {
              OMX_LOGE("Cbuf already Reached Eos!");
              returnBuffer(mInputPort, in_head);
              mCachedhead = NULL;
              mInBDBackNum++;
            }
          } else {
            amp_buffer->updatePts(in_head, mStreamPosition);
            (static_cast<OmxAmpVideoPort *>(mInputPort))->formatEsData(in_head, OMX_TRUE);
            amp_buffer->updateMemInfo(in_head);
            mStreamPosition += in_head->nFilledLen;
            mStreamPosition &= kStreamPositionMask;
          }
        } else {
          amp_buffer->clearBdTag();
          amp_buffer->addPtsTag(in_head, mStreamPosition);
          OMX_U32 es_offset = static_cast<OmxAmpVideoPort *>(mInputPort)->getEsOffset();
          static_cast<OmxAmpVideoPort *>(mInputPort)->updateMemInfo(in_head);
          OMX_U32 padding_size = static_cast<OmxAmpVideoPort *>(mInputPort)->paddingsize;
          amp_buffer->addMemInfoTag(in_head, es_offset);
          if (kPlayReadyType ==
              static_cast<OmxAmpVideoPort *>(mInputPort)->mDrmType) {
            if (NULL != cryptoInfo) {
              OMX_U64 encryptionOffset = 0;
              OMX_U64 iv;
              kdMemcpy(&iv, cryptoInfo->mIv, sizeof(OMX_U64));
              OMX_U32 ctrl_count = 0;
              OMX_U32 ctrl_start = static_cast<OmxAmpVideoPort *>(mInputPort)->getCtrlIndex();
              for (OMX_U32 i = 0; i < cryptoInfo->mNumSubSamples; i++) {
                OMX_U32 numBytesOfClearData =
                    cryptoInfo->mSubSamples[i].mNumBytesOfClearData;
                OMX_U32 numBytesOfEncryptedData =
                    cryptoInfo->mSubSamples[i].mNumBytesOfEncryptedData;
                if (0u < numBytesOfClearData) {
                  static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                      numBytesOfClearData, OMX_FALSE, 0, 0);
                  ctrl_count++;
                }
                if (0u < numBytesOfEncryptedData) {
                  static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                      numBytesOfEncryptedData, OMX_TRUE, iv, encryptionOffset);
                  encryptionOffset += numBytesOfEncryptedData;
                  ctrl_count++;
                }
              }
              kdFree(cryptoInfo);
              cryptoInfo = NULL;
              if (padding_size) {
                static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                    padding_size, OMX_FALSE, 0, 0);
                static_cast<OmxAmpVideoPort *>(mInputPort)->paddingsize = 0;
                ctrl_count++;
              }
              amp_buffer->addCtrlInfoTag(ctrl_buf_num, ctrl_start, ctrl_count);
            } else {
              OMX_LOGD("playready frame with No cryptoInfo...");
              OMX_U32 ctrl_start = static_cast<OmxAmpVideoPort *>(mInputPort)->getCtrlIndex();
              if (in_head->nFilledLen) {
                static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                    in_head->nFilledLen, OMX_FALSE, 0, 0);
                static_cast<OmxAmpVideoPort *>(mInputPort)->paddingsize = 0;
              }
              amp_buffer->addCtrlInfoTag(ctrl_buf_num, ctrl_start, 1);
            }
          } else if (kWideVineType ==
              static_cast<OmxAmpVideoPort *>(mInputPort)->mDrmType) {
            if (NULL != cryptoInfo) {
              OMX_U32 ctrl_count = 0;
              OMX_U32 ctrl_start = static_cast<OmxAmpVideoPort *>(mInputPort)->getCtrlIndex();
              for (OMX_U32 i = 0; i < cryptoInfo->mNumSubSamples; i++) {
                OMX_U32 numBytesOfClearData =
                    cryptoInfo->mSubSamples[i].mNumBytesOfClearData;
                OMX_U32 numBytesOfEncryptedData =
                    cryptoInfo->mSubSamples[i].mNumBytesOfEncryptedData;
                if (0u < numBytesOfClearData) {
                  static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                      numBytesOfClearData, OMX_FALSE, NULL);
                  ctrl_count++;
                }
                if (0u < numBytesOfEncryptedData) {
                  static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                      numBytesOfEncryptedData, OMX_TRUE, cryptoInfo->mIv);
                  ctrl_count++;
                }
              }
              kdFree(cryptoInfo);
              cryptoInfo = NULL;
              if (padding_size) {
                static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                    padding_size, OMX_FALSE, NULL);
                static_cast<OmxAmpVideoPort *>(mInputPort)->paddingsize = 0;
                ctrl_count++;
              }
              amp_buffer->addCtrlInfoTag(ctrl_buf_num, ctrl_start, ctrl_count);
            } else {
              OMX_LOGD("widevine frame with No cryptoInfo...");
              OMX_U32 ctrl_start = static_cast<OmxAmpVideoPort *>(mInputPort)->getCtrlIndex();
              if (in_head->nFilledLen) {
                static_cast<OmxAmpVideoPort *>(mInputPort)->updateCtrlInfo(
                    in_head->nFilledLen, OMX_FALSE, NULL);
                static_cast<OmxAmpVideoPort *>(mInputPort)->paddingsize = 0;
              }
              amp_buffer->addCtrlInfoTag(ctrl_buf_num, ctrl_start, 1);
            }
          } else {
            OMX_LOGE("Unknow drm type, can not be here, error happened...");
          }
          mStreamPosition += in_head->nFilledLen;
          mStreamPosition &= kStreamPositionMask;
        }
        if (NULL == mPool) {
          pushAmpBd(AMP_PORT_INPUT, 0, amp_buffer->getBD());
          mCachedhead = NULL;
        }
      } else {
        OMX_LOGE("get input buffer %p error",in_head);
      }
    }
    // request and push bd to amp when use stream in mode.
    if (NULL != mPool) {
      AMP_BD_ST *bd;
      UINT32 ret, offset, framesize;
      ret = AMP_CBUFRequest(mPool, &bd, &offset, &framesize);
      if (AMPCBUF_SUCCESS == ret) {
        mPushedBdNum++;
        mAddedPtsTagNum = 0;
        OMX_LOGD("Cbuf <%u/%u> Push Bd to Amp: offset %u  size %u", mReturnedBdNum,
            mPushedBdNum, offset, framesize);
        pushAmpBd(AMP_PORT_INPUT, 0, bd);
      } else if (AMPCBUF_LACKBD == ret) {
        OMX_LOGV("Cbuf Lack of Bd, waitting.");
      } else if (AMPCBUF_LACKDATA == ret) {
        OMX_LOGV("Cbuf Lack of Data, waitting.");
      } else {
        OMX_LOGE("Cbuf Request Bd err %d.", ret);
      }
    }
    // Get output buffer
    if (!mOutputPort->isEmpty() && mOutputEOS == OMX_FALSE) {
      out_head = mOutputPort->popBuffer();
      OMX_LOGV("Got output buffer %p", out_head);
      if (NULL != out_head) {
        if (mOutputPort->isFlushing()) {
          OMX_LOGD("Return output buffer when flushing");
          returnBuffer(mOutputPort, out_head);
          out_buf = NULL;
          continue;
        }
        AmpBuffer *amp_buffer = static_cast<AmpBuffer *>(
            out_head->pPlatformPrivate);
        mOutBDPushNum++;
        OMX_LOGD("<Out> %d/%d", mOutputFrameNum, mOutBDPushNum);
        pushAmpBd(AMP_PORT_OUTPUT, 0, amp_buffer->getBD());
      } else {
        OMX_LOGE("get output buffer %p error",out_head);
      }
    }
    usleep(5000);
  } // end of while (!mShouldExit)

  kdThreadMutexLock(mPauseLock);
  if (mPaused) {
    kdThreadCondWait(mPauseCond, mPauseLock);
    kdThreadMutexUnlock(mPauseLock);
    goto Loop_start;
  }
  kdThreadMutexUnlock(mPauseLock);
!!!11122828.cpp!!!	threadEntry(inout args : void) : void
  OmxAmpVideoDecoder *decoder = (OmxAmpVideoDecoder *)args;
  decoder->pushBufferLoop();
  return NULL;
!!!11122956.cpp!!!	pushBufferDone(in component : AMP_COMPONENT, in port_Io : AMP_PORT_IO, in port_idx : UINT32, inout bd : AMP_BD_ST, inout context : void) : HRESULT
  OMX_LOGD("pushBufferDone, port_IO %d, bd 0x%x, bd.bdid 0x%x, bd.allocva 0x%x",
      port_Io, bd, bd->uiBDId, bd->uiAllocVA);
  HRESULT err = SUCCESS;
  OMX_BUFFERHEADERTYPE *buf_header = NULL;
  OMX_BOOL isLastOutFrame = OMX_FALSE;
  OmxAmpVideoDecoder *decoder = static_cast<OmxAmpVideoDecoder *>(context);
  if (AMP_PORT_INPUT == port_Io && 0 == port_idx) {
    if (NULL != decoder->mPool) {
      OMX_U32 ret;
      ret = AMP_CBUFRelease(decoder->mPool, bd);
      if (AMPCBUF_SUCCESS == ret) {
        decoder->mReturnedBdNum++;
        OMX_LOGD("Cbuf [%u/%u] Return Bd from Amp", decoder->mReturnedBdNum,
            decoder->mPushedBdNum);
      } else {
        OMX_LOGE("Cbuf Release Bd error %u.", ret);
      }
      return err;
    }
    buf_header = (static_cast<OmxAmpVideoPort *>(decoder->mInputPort))
        ->getBufferHeader(bd);
    if (OMX_TRUE == static_cast<OmxAmpVideoPort *>(decoder->mInputPort)->mIsDrm) {
      AmpBuffer *amp_buffer =  static_cast<AmpBuffer *>(
          buf_header->pPlatformPrivate);
      AMP_BDTAG_MEMINFO *mem_info = amp_buffer->getMemInfo();
      static_cast<OmxAmpVideoPort *>(decoder->mInputPort)->updatePushedBytes(
          mem_info->uSize);
      AMP_BDTAG_TVPCTRLBUF *ctrl_info = amp_buffer->getCtrlInfo();
      static_cast<OmxAmpVideoPort *>(decoder->mInputPort)->updatePushedCtrls(
          ctrl_info->uSize);
    }
    if (NULL != buf_header) {
      decoder->returnBuffer(decoder->mInputPort, buf_header);
      decoder->mInBDBackNum++;
      OMX_LOGD("[In] %d/%d", decoder->mInBDBackNum, decoder->mInputFrameNum);
    }
  } else if (AMP_PORT_OUTPUT == port_Io && 0 == port_idx) {
    buf_header = (static_cast<OmxAmpVideoPort *>(decoder->mOutputPort))
        ->getBufferHeader(bd);
    if (NULL != buf_header) {
      AmpBuffer *amp_buffer =  static_cast<AmpBuffer *>(
          buf_header->pPlatformPrivate);
      AMP_BDTAG_MEMINFO *mem_info = amp_buffer->getMemInfo();
      if (mem_info->uFlag & AMP_MEMINFO_FLAG_EOS_MASK) {
        OMX_LOGD("[Out] Receive EOS");
        buf_header->nFlags |= OMX_BUFFERFLAG_EOS;
        mem_info->uFlag = 0;
        decoder->mOutputEOS = OMX_TRUE;
        decoder->postEvent(OMX_EventBufferFlag, buf_header->nOutputPortIndex,
            OMX_BUFFERFLAG_EOS);
      }
      if (decoder->mMark.hMarkTargetComponent != NULL) {
        buf_header->hMarkTargetComponent = decoder->mMark.hMarkTargetComponent;
        buf_header->pMarkData = decoder->mMark.pMarkData;
        decoder->mMark.hMarkTargetComponent = NULL;
        decoder->mMark.pMarkData = NULL;
      }
      AMP_BGTAG_FRAME_INFO *frame_info = amp_buffer->getFrameInfo();
      OMX_TICKS pts_low, pts_high;
      pts_low = static_cast<OMX_TICKS>(frame_info->uiPtsLow);
      pts_high = static_cast<OMX_TICKS>(frame_info->uiPtsHigh);
      if (frame_info->uiPtsHigh & TIME_STAMP_VALID_MASK) {
        buf_header->nTimeStamp = convert90KtoUs(pts_high, pts_low);
      }
      if (OMX_TRUE == decoder->mOutputEOS) {
        buf_header->nFilledLen = 0;
      } else {
        buf_header->nFilledLen = buf_header->nAllocLen;
      }
      if (decoder->mOutputFrameNum == 0) {
        buf_header->nFlags |= OMX_BUFFERFLAG_STARTTIME;
      }
      decoder->returnBuffer(decoder->mOutputPort, buf_header);
      decoder->mOutputFrameNum++;
      OMX_LOGD("[Out] %d/%d, size %d, pts %lld, flag %x",
          decoder->mOutputFrameNum, decoder->mOutBDPushNum,
          buf_header->nFilledLen, buf_header->nTimeStamp, buf_header->nFlags);
    }
  } else {
    OMX_LOGE("bd not be used");
    err = ERR_NOTIMPL;
    return err;
  }
  return err;
!!!11123084.cpp!!!	createAmpVideoDecoder(inout handle : OMX_HANDLETYPE, in componentName : OMX_STRING, in appData : OMX_PTR, inout callBacks : OMX_CALLBACKTYPE) : OMX_ERRORTYPE
  OmxAmpVideoDecoder *comp = new  OmxAmpVideoDecoder(componentName);
  *handle = comp->makeComponent(comp);
  comp->setCallbacks(callBacks, appData);
  comp->componentInit();
  return OMX_ErrorNone;
!!!11123212.cpp!!!	getAmpVideoDecoder() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  AMP_FACTORY factory;
  err = AMP_GetFactory(&factory);
  CHECKAMPERRLOG(err, "Failed to get AMP factory");

  AMP_RPC(err, AMP_FACTORY_CreateComponent, factory, AMP_COMPONENT_VDEC,
      1, &mAmpHandle);
  CHECKAMPERRLOG(err, "Failed to create VDEC component");

  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11123340.cpp!!!	destroyAmpVideoDecoder() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (mAmpHandle) {
    AMP_RPC(err, AMP_VDEC_Destroy, mAmpHandle);
    CHECKAMPERRLOG(err, "Failed to destory VDEC");

    AMP_FACTORY_Release(mAmpHandle);
    mAmpHandle = NULL;
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11123468.cpp!!!	setAmpState(in state : AMP_STATE) : OMX_ERRORTYPE
  OMX_LOGD("setAmpState %s", AmpState2String(state));
  HRESULT err = SUCCESS;

  AMP_RPC(err, AMP_VDEC_SetState, mAmpHandle, state);
  CHECKAMPERRLOG(err, "Failed to set VDEC state");

  return static_cast<OMX_ERRORTYPE>(err);
!!!11123596.cpp!!!	getAmpState(inout state : AMP_STATE) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;

  AMP_RPC(err, AMP_VDEC_GetState, mAmpHandle, state);
  CHECKAMPERRLOG(err, "Failed to get VDEC state");

  OMX_LOGD("getAmpState is %s", AmpState2String(*state));
  return static_cast<OMX_ERRORTYPE>(err);
!!!11123724.cpp!!!	pushAmpBd(in port : AMP_PORT_IO, in portindex : UINT32, inout bd : AMP_BD_ST) : OMX_ERRORTYPE
  OMX_LOGD("(%s)pushAmpBd, bd 0x%x, bdid 0x%x, allocva 0x%x",
      port == AMP_PORT_INPUT ? "In":"Out", bd, bd->uiBDId, bd->uiAllocVA);
  HRESULT err = SUCCESS;

  AMP_RPC(err, AMP_VDEC_PushBD, mAmpHandle, port, portindex, bd);
  CHECKAMPERRLOG(err, "Failed to push BD to VDEC");

  return static_cast<OMX_ERRORTYPE>(err);
!!!11123852.cpp!!!	registerBds(inout port : OmxAmpVideoPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  UINT32 uiPortIdx = 0;
  if (port->isInput()) {
    for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
      AmpBuffer *amp_buffer = port->getAmpBuffer(i);
      if (NULL != amp_buffer) {
        if (OMX_FALSE == static_cast<OmxAmpVideoPort *>(port)->mIsDrm) {
          amp_buffer->addMemInfoTag();
          amp_buffer->addPtsTag();
        }
        AMP_RPC(err, AMP_VDEC_RegisterBD, mAmpHandle, AMP_PORT_INPUT,
            uiPortIdx, amp_buffer->getBD());
        CHECKAMPERRLOG(err, "Failed to register BDs at VDEC input port");
      }
    }
  } else {
    for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
      AmpBuffer *amp_buffer = port->getAmpBuffer(i);
      if (NULL != amp_buffer) {
        amp_buffer->addMemInfoTag();
        amp_buffer->addFrameInfoTag();
        AMP_RPC(err, AMP_VDEC_RegisterBD, mAmpHandle, AMP_PORT_OUTPUT,
            uiPortIdx, amp_buffer->getBD());
        CHECKAMPERRLOG(err, "Failed to regsiter BDs at VDEC output port");
      }
    }
  }
  return static_cast<OMX_ERRORTYPE>(err);
!!!11123980.cpp!!!	unregisterBds(inout port : OmxAmpVideoPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  AMP_PORT_IO portIo;
  if (port->isInput()) {
    portIo = AMP_PORT_INPUT;
  } else {
    portIo = AMP_PORT_OUTPUT;
  }
  AMP_BD_ST *bd;
  UINT32 uiPortIdx = 0;
  for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
    bd = port->getBD(i);
    if (NULL != bd) {
      AMP_RPC(err, AMP_VDEC_UnregisterBD, mAmpHandle, portIo, uiPortIdx, bd);
      CHECKAMPERRLOG(err, "Failed to unregsiter BDs for VDEC");

      OMX_LOGD("AMP_VDEC_UnregisterBD, portIo %d, bd %p", portIo, bd);
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11124108.cpp!!!	resetPtsForFirstFrame(inout in_head : OMX_BUFFERHEADERTYPE) : OMX_ERRORTYPE
// TODO: Need to set a true value If the first frame pts is invalid after seeking
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OmxPortImpl *port0 = getPort(kVideoPortStartNumber + 1);
  if (port0->isTunneled()) {
    OMX_COMPONENTTYPE *video_processor =
        static_cast<OMX_COMPONENTTYPE *>(port0->getTunnelComponent());
    OmxPortImpl *port1 = static_cast<OmxComponentImpl *>(
        video_processor->pComponentPrivate)->getPort(kVideoPortStartNumber + 1);
    if (port1->isTunneled()) {
      OMX_COMPONENTTYPE *video_scheduler =
          static_cast<OMX_COMPONENTTYPE *>(port1->getTunnelComponent());
      OmxPortImpl *port2 = static_cast<OmxComponentImpl *>(
          video_scheduler->pComponentPrivate)->getPort(kClockPortStartNumber);
      if (port2->isTunneled()) {
        OMX_COMPONENTTYPE *clock =
            static_cast<OMX_COMPONENTTYPE *>(port2->getTunnelComponent());
        OMX_TIME_CONFIG_CLOCKSTATETYPE state;
        OMX_U32 wait_count = 20;
        InitOmxHeader(&state);
        while (wait_count > 0) {
          err = OMX_GetConfig(clock,
              OMX_IndexConfigTimeClockState, &state);
          CHECKOMXERR(err);
          if (OMX_TIME_ClockStateRunning == state.eState) {
            in_head->nTimeStamp = state.nStartTime;
            OMX_LOGD("Invalid pts, Reset the first frame pts %lld", in_head->nTimeStamp);
            return err;
          } else {
            OMX_LOGD("Invalid pts, clock eState %d, try again...", state.eState);
            usleep(5000);
            wait_count--;
            continue;
          }
        }
        OMX_LOGD("Invalid pts, reset pts failure, time out.");
      }
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11124236.cpp!!!	getNativeBufferSize(inout gfx : GraphicBuffer) : OMX_U32
  OMX_U32 stride = gfx->getStride();
  OMX_U32 height = gfx->getHeight();
  stride = (stride + kWidthAlignment - 1) & (~(kWidthAlignment - 1));
  height = (height + kHeightAlignment - 1) & (~(kHeightAlignment - 1));
  OMX_U32 size = stride * height;
  switch (gfx->format) {
    case HAL_PIXEL_FORMAT_RGBA_8888:
    case HAL_PIXEL_FORMAT_RGBX_8888:
    case HAL_PIXEL_FORMAT_BGRA_8888:
      stride *= 4;
      size *= 4;
      break;
    case HAL_PIXEL_FORMAT_RGB_888:
      stride *= 3;
      size *= 3;
      break;
    case HAL_PIXEL_FORMAT_RGB_565:
    case HAL_PIXEL_FORMAT_RGBA_5551:
    case HAL_PIXEL_FORMAT_RGBA_4444:
      stride *= 2;
      size *= 2;
      break;
    case HAL_PIXEL_FORMAT_YCbCr_422_I:
    case HAL_PIXEL_FORMAT_UYVY:
      size *= 2;
      break;
    case HAL_PIXEL_FORMAT_YV12:
      size = size * 3 / 2;
      break;
    default:
      break;
  }
  return size;
!!!11124364.cpp!!!	isVideoParamSupport(inout video_param : OMX_VIDEO_PARAM_PORTFORMATTYPE) : OMX_BOOL
  // TODO: implement this
  OMX_BOOL isSupport = OMX_FALSE;
  switch (mInputPort->getVideoDefinition().eCompressionFormat) {
    case OMX_VIDEO_CodingAVC:
    case OMX_VIDEO_CodingMPEG4:
    case OMX_VIDEO_CodingMPEG2:
    case OMX_VIDEO_CodingH263:
#ifdef _ANDROID_
    case OMX_VIDEO_CodingVPX:
#endif
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
    case OMX_VIDEO_CodingVP8:
#endif
      isSupport = OMX_TRUE;
      break;
    default:
      isSupport = OMX_FALSE;
  }
  return isSupport;
!!!11124492.cpp!!!	isProfileLevelSupport(inout prof_lvl : OMX_VIDEO_PARAM_PROFILELEVELTYPE) : OMX_BOOL
  // TODO: implement this
  OMX_BOOL isSupport = OMX_FALSE;
  switch(mInputPort->getVideoDefinition().eCompressionFormat) {
    case OMX_VIDEO_CodingAVC:
    case OMX_VIDEO_CodingMPEG4:
    case OMX_VIDEO_CodingMPEG2:
    case OMX_VIDEO_CodingH263:
#ifdef _ANDROID_
    case OMX_VIDEO_CodingVPX:
#endif
#ifdef OMX_SPEC_1_2_0_0_SUPPORT
    case OMX_VIDEO_CodingVP8:
#endif
      isSupport = OMX_TRUE;
      break;
    default:
      isSupport = OMX_FALSE;
  }
  return isSupport;
!!!11124620.cpp!!!	bindPQSource() : OMX_S32
  OMX_LOG_FUNCTION_ENTER;
  //Bind PQ sourceID with videoplane;
  String8 FILE_SOURCE_URI;
  if ( -1 == mSourceId) {
    mVideoPlaneId = getVideoPlane();
    OMX_LOGD("mVideoPlaneId = %d", mVideoPlaneId);
    if ((-1 != mVideoPlaneId) && (NULL != mSourceControl)) {
     if (0 == mVideoPlaneId) {
       FILE_SOURCE_URI = String8("file://localhost?plane=0");
     } else {
       FILE_SOURCE_URI = String8("file://localhost?plane=1");
     }
     mSourceControl->getSourceByUri(FILE_SOURCE_URI, &mSourceId);
     if ( -1 != mSourceId) {
       OMX_LOGD("get PQ sourceid :%d, sourceURL :%s", mSourceId, FILE_SOURCE_URI.string());
       status_t ret = mSourceControl->setSource(mSourceId, mVideoPlaneId);
       if (OK != ret) {
         OMX_LOGE("setSource() through source control failed!");
         mSourceId = -1;
       }
      }
     } else {
       OMX_LOGD("blind PQ source with videoplane failed.");
     }
   }
  OMX_LOG_FUNCTION_ENTER;
  return mSourceId;
!!!11124748.cpp!!!	getVideoPlane() : OMX_S32
  OMX_LOG_FUNCTION_ENTER;
  OmxPortImpl *port = getPort(kVideoPortStartNumber + 1);
  if ((NULL != port) && (port->isTunneled())) {
    OmxComponentImpl *pComp =  static_cast<OmxComponentImpl *>(
      static_cast<OMX_COMPONENTTYPE *>(port->getTunnelComponent())->pComponentPrivate);
    if (NULL != strstr(pComp->mName, "iv_processor")) {
      return static_cast<OmxVoutProxy *>(pComp)->getVideoPlane();
    }
  }
  OMX_LOG_FUNCTION_EXIT;
  return -1;
!!!11124876.cpp!!!	registerEvent(in event : AMP_EVENT_CODE) : HRESULT
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }

  err = AMP_Event_RegisterCallback(mListener, event, eventHandle, static_cast<void *>(this));
  CHECK_AMP_RETURN_VAL(err, "register VDEC notify");

  if (!err) {
    AMP_RPC(err, AMP_VDEC_RegisterNotify, mAmpHandle,
        AMP_Event_GetServiceID(mListener), event);
    CHECK_AMP_RETURN_VAL(err, "register VDEC callback");
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11125004.cpp!!!	unRegisterEvent(in event : AMP_EVENT_CODE) : HRESULT
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }

  AMP_RPC(err, AMP_VDEC_UnregisterNotify, mAmpHandle,
      AMP_Event_GetServiceID(mListener), event);
  CHECK_AMP_RETURN_VAL(err, "unregister VDEC notify");

  if (!err) {
    err = AMP_Event_UnregisterCallback(mListener, event, eventHandle);
    CHECK_AMP_RETURN_VAL(err, "unregister VDEC callback");
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11125132.cpp!!!	eventHandle(in hListener : HANDLE, inout pEvent : AMP_EVENT, inout pUserData : VOID) : HRESULT
  if (!pEvent) {
    OMX_LOGE("pEvent is NULL!");
    return !SUCCESS;
  }

  if (AMP_EVENT_API_VDEC_CALLBACK == pEvent->stEventHead.eEventCode) {
    UINT32 *payload = static_cast<UINT32 *>(AMP_EVENT_PAYLOAD_PTR(pEvent));
    OmxAmpVideoDecoder *pComp = static_cast<OmxAmpVideoDecoder *>(pUserData);
    switch (pEvent->stEventHead.uiParam1) {
      case AMP_VDEC_EVENT_RES_CHANGE:
        pComp->mVdecInfo.nMaxWidth = payload[0];
        pComp->mVdecInfo.nMaxHeight = payload[1];
        break;
      case AMP_VDEC_EVENT_FR_CHANGE:
        pComp->mVdecInfo.nFrameRateNum = payload[0];
        pComp->mVdecInfo.nFrameRateDen = payload[1];
        if (0 !=pComp->mVdecInfo.nFrameRateDen) {
          pComp->mVdecInfo.nFrameRate = (pComp->mVdecInfo.nFrameRateNum * 1000)
              /pComp->mVdecInfo.nFrameRateDen;
        }
        break;
      case AMP_VDEC_EVENT_AR_CHANGE:
        pComp->mVdecInfo.nSarWidth = payload[0];
        pComp->mVdecInfo.nSarHeight = payload[1];
        break;
      case AMP_VDEC_EVENT_1ST_I_DECODED:
        pComp->mVdecInfo.nMaxWidth = payload[0];
        pComp->mVdecInfo.nMaxHeight = payload[1];
        pComp->mVdecInfo.nIsIntlSeq = static_cast<MEDIA_BOOL>(payload[2]);
        pComp->mVdecInfo.nFrameRateNum = payload[3];
        pComp->mVdecInfo.nFrameRateDen = payload[4];
        pComp->mVdecInfo.nSarWidth = payload[5];
        pComp->mVdecInfo.nSarHeight = payload[6];
        pComp->mVdecInfo.nIsFirstIFrameMg = MEDIA_TRUE;
        if (0 !=pComp->mVdecInfo.nFrameRateDen) {
          pComp->mVdecInfo.nFrameRate = (pComp->mVdecInfo.nFrameRateNum * 1000)
              /pComp->mVdecInfo.nFrameRateDen;
      }
        break;
      default:
        return SUCCESS;
    }

    if ((-1 != pComp->mSourceId) && (NULL != pComp->mSourceControl)) {
      if ((pComp->mVdecInfo.nIsFirstIFrameMg)
          && (0 != pComp->mVdecInfo.nMaxWidth)
          && (0 != pComp->mVdecInfo.nMaxHeight)) {
        pComp->mSourceControl->notifySourceVideoInfo(pComp->mSourceId,
            pComp->mVdecInfo.nMaxWidth, pComp->mVdecInfo.nMaxHeight,
            0, pComp->mVdecInfo.nIsIntlSeq,
            (0 == pComp->mVdecInfo.nFrameRate) ? 25000 : pComp->mVdecInfo.nFrameRate,
            (0 == pComp->mVdecInfo.nSarWidth) ? 1 : pComp->mVdecInfo.nSarWidth,
            (0 == pComp->mVdecInfo.nSarHeight) ? 1 : pComp->mVdecInfo.nSarHeight);
        pComp->mSourceControl->applyPQ(pComp->mSourceId);
        OMX_LOGD("event type:%d firstIframe:%d width:%d height:%d is_intl:%d "
          "framerate*1000:%d sar_width:%d sar_height:%d\n",
          pEvent->stEventHead.uiParam1, pComp->mVdecInfo.nIsFirstIFrameMg,
          pComp->mVdecInfo.nMaxWidth, pComp->mVdecInfo.nMaxHeight,
          pComp->mVdecInfo.nIsIntlSeq, pComp->mVdecInfo.nFrameRate,
          pComp->mVdecInfo.nSarWidth, pComp->mVdecInfo.nSarHeight);
      }
    }
  }
  return SUCCESS;
