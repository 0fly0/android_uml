format 74
"locks" // _unknown::java::util::concurrent::locks
  revision 1
  modified_by 27 "shchen"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  java_dir "/home/shchen/work/android-x86/libcore/luni/src/main/java/java/util/concurrent/locks/"
  java_package "java.util.concurrent.locks"
  classview 133019 "locks"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 254235 "ReentrantLock"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A reentrant mutual exclusion {@link Lock} with the same basic
behavior and semantics as the implicit monitor lock accessed using
{@code synchronized} methods and statements, but with extended
capabilities.

<p>A {@code ReentrantLock} is <em>owned</em> by the thread last
successfully locking, but not yet unlocking it. A thread invoking
{@code lock} will return, successfully acquiring the lock, when
the lock is not owned by another thread. The method will return
immediately if the current thread already owns the lock. This can
be checked using methods {@link #isHeldByCurrentThread}, and {@link
#getHoldCount}.

<p>The constructor for this class accepts an optional
<em>fairness</em> parameter.  When set {@code true}, under
contention, locks favor granting access to the longest-waiting
thread.  Otherwise this lock does not guarantee any particular
access order.  Programs using fair locks accessed by many threads
may display lower overall throughput (i.e., are slower; often much
slower) than those using the default setting, but have smaller
variances in times to obtain locks and guarantee lack of
starvation. Note however, that fairness of locks does not guarantee
fairness of thread scheduling. Thus, one of many threads using a
fair lock may obtain it multiple times in succession while other
active threads are not progressing and not currently holding the
lock.
Also note that the untimed {@link #tryLock() tryLock} method does not
honor the fairness setting. It will succeed if the lock
is available even if other threads are waiting.

<p>It is recommended practice to <em>always</em> immediately
follow a call to {@code lock} with a {@code try} block, most
typically in a before/after construction such as:

 <pre> {@code
class X {
  private final ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
    lock.lock();  // block until condition holds
    try {
      // ... method body
    } finally {
      lock.unlock()
    }
  }
}}</pre>

<p>In addition to implementing the {@link Lock} interface, this
class defines methods {@code isLocked} and
{@code getLockQueueLength}, as well as some associated
{@code protected} access methods that may be useful for
instrumentation and monitoring.

<p>Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p>This lock supports a maximum of 2147483647 recursive locks by
the same thread. Attempts to exceed this limit result in
{@link Error} throws from locking methods.

@since 1.5
@author Doug Lea"
      classrelation 414875 // <realization>
	relation 414875 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 414875 // <realization>
	  b parent class_ref 256027 // Lock
      end

      classrelation 415003 // <realization>
	relation 415003 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 415003 // <realization>
	  b parent class_ref 128155 // Serializable
      end

      attribute 356507 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984872572414699L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      class 256155 "Sync"
	abstract visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 417435 // <generalisation>
	  relation 417435 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 417435 // <generalisation>
	    b parent class_ref 256283 // AbstractQueuedSynchronizer
	end

	attribute 358811 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -5179523762034025860L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1448859 "lock"
	  abstract package explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs {@link Lock#lock}. The main reason for subclassing
is to allow fast path for nonfair version."
	end

	operation 1448987 "nonfairTryAcquire"
	  package explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs non-fair tryLock.  tryAcquire is
implemented in subclasses, but both need nonfair
try for trylock method."
	end

	operation 1449115 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1449243 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1449371 "newCondition"
	  package return_type class_ref 256667 // ConditionObject
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1449499 "getOwner"
	  package return_type class_ref 1201420 // Thread
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed from outer class"
	end

	operation 1449627 "getHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1449755 "isLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1449883 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 128667 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 128539 // IOException
	    exception class_ref 128795 // ClassNotFoundException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitutes this lock instance from a stream.
@param s the stream"
	end
      end

      classrelation 415131 // sync (<unidirectional association>)
	relation 415131 --->
	  a role_name "sync" const_relation private
	    comment " Synchronizer providing all implementation mechanics 
"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 415131 // sync (<unidirectional association>)
	  b parent class_ref 256155 // Sync
      end

      class 256795 "NonfairSync"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 417563 // <generalisation>
	  relation 417563 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 417563 // <generalisation>
	    b parent class_ref 256155 // Sync
	end

	attribute 358939 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 7316153563782823691L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1450011 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs lock.  Try immediate barge, backing up to normal
acquire on failure."
	end

	operation 1450139 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      class 256923 "FairSync"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 417691 // <generalisation>
	  relation 417691 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 417691 // <generalisation>
	    b parent class_ref 256155 // Sync
	end

	attribute 359067 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -3000897897090466540L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1450267 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1450395 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Fair version of tryAcquire.  Don't grant access unless
recursive call or no waiters or is first."
	end
      end

      operation 1450523 "ReentrantLock"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of {@code ReentrantLock}.
This is equivalent to using {@code ReentrantLock(false)}."
      end

      operation 1450651 "ReentrantLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of {@code ReentrantLock} with the
given fairness policy.

@param fair {@code true} if this lock should use a fair ordering policy"
      end

      operation 1450779 "lock"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock.

<p>Acquires the lock if it is not held by another thread and returns
immediately, setting the lock hold count to one.

<p>If the current thread already holds the lock then the hold
count is incremented by one and the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until the lock has been acquired,
at which time the lock hold count is set to one."
      end

      operation 1450907 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns
immediately, setting the lock hold count to one.

<p>If the current thread already holds this lock then the hold count
is incremented by one and the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of two things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread.

</ul>

<p>If the lock is acquired by the current thread then the lock hold
count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while acquiring
the lock,

</ul>

then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to the
interrupt over normal or reentrant acquisition of the lock.

@throws InterruptedException if the current thread is interrupted"
      end

      operation 1451035 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is not held by another thread at the time
of invocation.

<p>Acquires the lock if it is not held by another thread and
returns immediately with the value {@code true}, setting the
lock hold count to one. Even when this lock has been set to use a
fair ordering policy, a call to {@code tryLock()} <em>will</em>
immediately acquire the lock if it is available, whether or not
other threads are currently waiting for the lock.
This &quot;barging&quot; behavior can be useful in certain
circumstances, even though it breaks fairness. If you want to honor
the fairness setting for this lock, then use
{@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p> If the current thread already holds this lock then the hold
count is incremented by one and the method returns {@code true}.

<p>If the lock is held by another thread then this method will return
immediately with the value {@code false}.

@return {@code true} if the lock was free and was acquired by the
        current thread, or the lock was already held by the current
        thread; and {@code false} otherwise"
      end

      operation 1451163 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 253211 // TimeUnit
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is not held by another thread within the given
waiting time and the current thread has not been
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns
immediately with the value {@code true}, setting the lock hold count
to one. If this lock has been set to use a fair ordering policy then
an available lock <em>will not</em> be acquired if any other threads
are waiting for the lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed {@code tryLock} that does permit barging on
a fair lock then combine the timed and un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the current thread
already holds this lock then the hold count is incremented by one and
the method returns {@code true}.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses

</ul>

<p>If the lock is acquired then the value {@code true} is returned and
the lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the lock,

</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>If the specified waiting time elapses then the value {@code false}
is returned.  If the time is less than or equal to zero, the method
will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to the
interrupt over normal or reentrant acquisition of the lock, and
over reporting the elapse of the waiting time.

@param timeout the time to wait for the lock
@param unit the time unit of the timeout argument
@return {@code true} if the lock was free and was acquired by the
        current thread, or the lock was already held by the current
        thread; and {@code false} if the waiting time elapsed before
        the lock could be acquired
@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
      end

      operation 1451291 "unlock"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to release this lock.

<p>If the current thread is the holder of this lock then the hold
count is decremented.  If the hold count is now zero then the lock
is released.  If the current thread is not the holder of this
lock then {@link IllegalMonitorStateException} is thrown.

@throws IllegalMonitorStateException if the current thread does not
        hold this lock"
      end

      operation 1451419 "newCondition"
	public return_type class_ref 254363 // Condition
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a {@link Condition} instance for use with this
{@link Lock} instance.

<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this lock is not held when any of the {@link Condition}
{@linkplain Condition#await() waiting} or {@linkplain
Condition#signal signalling} methods are called, then an {@link
IllegalMonitorStateException} is thrown.

<li>When the condition {@linkplain Condition#await() waiting}
methods are called the lock is released and, before they
return, the lock is reacquired and the lock hold count restored
to what it was when the method was called.

<li>If a thread is {@linkplain Thread#interrupt interrupted}
while waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order.

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>

@return the Condition object"
      end

      operation 1451547 "getHoldCount"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of holds on this lock by the current thread.

<p>A thread has a hold on a lock for each lock action that is not
matched by an unlock action.

<p>The hold count information is typically only used for testing and
debugging purposes. For example, if a certain section of code should
not be entered with the lock already held then we can assert that
fact:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...
  public void m() {
    assert lock.getHoldCount() == 0;
    lock.lock();
    try {
      // ... method body
    } finally {
      lock.unlock();
    }
  }
}}</pre>

@return the number of holds on this lock by the current thread,
        or zero if this lock is not held by the current thread"
      end

      operation 1451675 "isHeldByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by the current thread.

<p>Analogous to the {@link Thread#holdsLock} method for built-in
monitor locks, this method is typically used for debugging and
testing. For example, a method that should only be called while
a lock is held can assert that this is the case:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
      assert lock.isHeldByCurrentThread();
      // ... method body
  }
}}</pre>

<p>It can also be used to ensure that a reentrant lock is used
in a non-reentrant manner, for example:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
      assert !lock.isHeldByCurrentThread();
      lock.lock();
      try {
          // ... method body
      } finally {
          lock.unlock();
      }
  }
}}</pre>

@return {@code true} if current thread holds this lock and
        {@code false} otherwise"
      end

      operation 1451803 "isLocked"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by any thread. This method is
designed for use in monitoring of the system state,
not for synchronization control.

@return {@code true} if any thread holds this lock and
        {@code false} otherwise"
      end

      operation 1451931 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if this lock has fairness set true.

@return {@code true} if this lock has fairness set true"
      end

      operation 1452059 "getOwner"
	protected return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns this lock, or
{@code null} if not owned. When this method is called by a
thread that is not the owner, the return value reflects a
best-effort approximation of current lock status. For example,
the owner may be momentarily {@code null} even if there are
threads trying to acquire the lock but have not yet done so.
This method is designed to facilitate construction of
subclasses that provide more extensive lock monitoring
facilities.

@return the owner, or {@code null} if not owned"
      end

      operation 1452187 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire this lock. Note that
because cancellations may occur at any time, a {@code true}
return does not guarantee that any other thread will ever
acquire this lock.  This method is designed primarily for use in
monitoring of the system state.

@return {@code true} if there may be other threads waiting to
        acquire the lock"
      end

      operation 1452315 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire this
lock. Note that because cancellations may occur at any time, a
{@code true} return does not guarantee that this thread
will ever acquire this lock.  This method is designed primarily for use
in monitoring of the system state.

@param thread the thread
@return {@code true} if the given thread is queued waiting for this lock
@throws NullPointerException if the thread is null"
      end

      operation 1452443 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to
acquire this lock.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring of the system state, not for synchronization
control.

@return the estimated number of threads waiting for this lock"
      end

      operation 1452571 "getQueuedThreads"
	protected return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire this lock.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads"
      end

      operation 1452699 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this lock. Note that because timeouts and
interrupts may occur at any time, a {@code true} return does
not guarantee that a future {@code signal} will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1452827 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1452955 "getWaitingThreads"
	protected return_type class_ref 160667 // Collection
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1453083 "toString"
	public return_type class_ref 3399692 // String
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes either the String {@code \"Unlocked\"}
or the String {@code \"Locked by\"} followed by the
{@linkplain Thread#getName name} of the owning thread.

@return a string identifying this lock, as well as its lock state"
      end
    end

    class 254363 "Condition"
      visibility public stereotype "interface"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "{@code Condition} factors out the {@code Object} monitor
methods ({@link Object#wait() wait}, {@link Object#notify notify}
and {@link Object#notifyAll notifyAll}) into distinct objects to
give the effect of having multiple wait-sets per object, by
combining them with the use of arbitrary {@link Lock} implementations.
Where a {@code Lock} replaces the use of {@code synchronized} methods
and statements, a {@code Condition} replaces the use of the Object
monitor methods.

<p>Conditions (also known as <em>condition queues</em> or
<em>condition variables</em>) provide a means for one thread to
suspend execution (to &quot;wait&quot;) until notified by another
thread that some state condition may now be true.  Because access
to this shared state information occurs in different threads, it
must be protected, so a lock of some form is associated with the
condition. The key property that waiting for a condition provides
is that it <em>atomically</em> releases the associated lock and
suspends the current thread, just like {@code Object.wait}.

<p>A {@code Condition} instance is intrinsically bound to a lock.
To obtain a {@code Condition} instance for a particular {@link Lock}
instance use its {@link Lock#newCondition newCondition()} method.

<p>As an example, suppose we have a bounded buffer which supports
{@code put} and {@code take} methods.  If a
{@code take} is attempted on an empty buffer, then the thread will block
until an item becomes available; if a {@code put} is attempted on a
full buffer, then the thread will block until a space becomes available.
We would like to keep waiting {@code put} threads and {@code take}
threads in separate wait-sets so that we can use the optimization of
only notifying a single thread at a time when items or spaces become
available in the buffer. This can be achieved using two
{@link Condition} instances.
<pre>
class BoundedBuffer {
  <b>final Lock lock = new ReentrantLock();</b>
  final Condition notFull  = <b>lock.newCondition(); </b>
  final Condition notEmpty = <b>lock.newCondition(); </b>

  final Object[] items = new Object[100];
  int putptr, takeptr, count;

  public void put(Object x) throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == items.length)
        <b>notFull.await();</b>
      items[putptr] = x;
      if (++putptr == items.length) putptr = 0;
      ++count;
      <b>notEmpty.signal();</b>
    <b>} finally {
      lock.unlock();
    }</b>
  }

  public Object take() throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == 0)
        <b>notEmpty.await();</b>
      Object x = items[takeptr];
      if (++takeptr == items.length) takeptr = 0;
      --count;
      <b>notFull.signal();</b>
      return x;
    <b>} finally {
      lock.unlock();
    }</b>
  }
}
</pre>

(The {@link java.util.concurrent.ArrayBlockingQueue} class provides
this functionality, so there is no reason to implement this
sample usage class.)

<p>A {@code Condition} implementation can provide behavior and semantics
that is
different from that of the {@code Object} monitor methods, such as
guaranteed ordering for notifications, or not requiring a lock to be held
when performing notifications.
If an implementation provides such specialized semantics then the
implementation must document those semantics.

<p>Note that {@code Condition} instances are just normal objects and can
themselves be used as the target in a {@code synchronized} statement,
and can have their own monitor {@link Object#wait wait} and
{@link Object#notify notification} methods invoked.
Acquiring the monitor lock of a {@code Condition} instance, or using its
monitor methods, has no specified relationship with acquiring the
{@link Lock} associated with that {@code Condition} or the use of its
{@linkplain #await waiting} and {@linkplain #signal signalling} methods.
It is recommended that to avoid confusion you never use {@code Condition}
instances in this way, except perhaps within their own implementation.

<p>Except where noted, passing a {@code null} value for any parameter
will result in a {@link NullPointerException} being thrown.

<h3>Implementation Considerations</h3>

<p>When waiting upon a {@code Condition}, a &quot;<em>spurious
wakeup</em>&quot; is permitted to occur, in
general, as a concession to the underlying platform semantics.
This has little practical impact on most application programs as a
{@code Condition} should always be waited upon in a loop, testing
the state predicate that is being waited for.  An implementation is
free to remove the possibility of spurious wakeups but it is
recommended that applications programmers always assume that they can
occur and so always wait in a loop.

<p>The three forms of condition waiting
(interruptible, non-interruptible, and timed) may differ in their ease of
implementation on some platforms and in their performance characteristics.
In particular, it may be difficult to provide these features and maintain
specific semantics such as ordering guarantees.
Further, the ability to interrupt the actual suspension of the thread may
not always be feasible to implement on all platforms.

<p>Consequently, an implementation is not required to define exactly the
same guarantees or semantics for all three forms of waiting, nor is it
required to support interruption of the actual suspension of the thread.

<p>An implementation is required to
clearly document the semantics and guarantees provided by each of the
waiting methods, and when an implementation does support interruption of
thread suspension then it must obey the interruption semantics as defined
in this interface.

<p>As interruption generally implies cancellation, and checks for
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action that may have
unblocked the thread. An implementation should document this behavior.

@since 1.5
@author Doug Lea"
      operation 1445147 "await"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or
{@linkplain Thread#interrupt interrupted}.

<p>The lock associated with this {@code Condition} is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of four things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal. In that case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)"
      end

      operation 1445275 "awaitUninterruptibly"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of three things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread's interrupted status is set when it enters
this method, or it is {@linkplain Thread#interrupt interrupted}
while waiting, it will continue to wait until signalled. When it finally
returns from this method its interrupted status will still
be set.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact."
      end

      operation 1445403 "awaitNanos"
	public explicit_return_type "long"
	nparams 1
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>The specified waiting time elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p>The method returns an estimate of the number of nanoseconds
remaining to wait given the supplied {@code nanosTimeout}
value upon return, or a value less than or equal to zero if it
timed out. This value can be used to determine whether and how
long to re-wait in cases where the wait returns but an awaited
condition still does not hold. Typical uses of this method take
the following form:

 <pre> {@code
boolean aMethod(long timeout, TimeUnit unit) {
  long nanos = unit.toNanos(timeout);
  lock.lock();
  try {
    while (!conditionBeingWaitedFor()) {
      if (nanos <= 0L)
        return false;
      nanos = theCondition.awaitNanos(nanos);
    }
    // ...
  } finally {
    lock.unlock();
  }
}}</pre>

<p> Design note: This method requires a nanosecond argument so
as to avoid truncation errors in reporting remaining times.
Such precision loss would make it difficult for programmers to
ensure that total waiting times are not systematically shorter
than specified when re-waits occur.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the elapse
of the specified waiting time. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@param nanosTimeout the maximum time to wait, in nanoseconds
@return an estimate of the {@code nanosTimeout} value minus
        the time spent waiting upon return from this method.
        A positive value may be used as the argument to a
        subsequent call to this method to finish waiting out
        the desired time.  A value less than or equal to zero
        indicates that no time remains.
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)"
      end

      operation 1445531 "await"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 253211 // TimeUnit
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses. This method is behaviorally
equivalent to:
 <pre> {@code awaitNanos(unit.toNanos(time)) > 0}</pre>

@param time the maximum time to wait
@param unit the time unit of the {@code time} argument
@return {@code false} if the waiting time detectably elapsed
        before return from the method, else {@code true}
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)"
      end

      operation 1445659 "awaitUntil"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "deadline" type class_ref 171931 // Date
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified deadline elapses.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>The specified deadline elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.


<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.


<p>The return value indicates whether the deadline has elapsed,
which can be used as follows:
 <pre> {@code
boolean aMethod(Date deadline) {
  boolean stillWaiting = true;
  lock.lock();
  try {
    while (!conditionBeingWaitedFor()) {
      if (!stillWaiting)
        return false;
      stillWaiting = theCondition.awaitUntil(deadline);
    }
    // ...
  } finally {
    lock.unlock();
  }
}}</pre>

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the passing
of the specified deadline. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@param deadline the absolute time to wait until
@return {@code false} if the deadline has elapsed upon return, else
        {@code true}
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)"
      end

      operation 1445787 "signal"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up one waiting thread.

<p>If any threads are waiting on this condition then one
is selected for waking up. That thread must then re-acquire the
lock before returning from {@code await}.

<p><b>Implementation Considerations</b>

<p>An implementation may (and typically does) require that the
current thread hold the lock associated with this {@code
Condition} when this method is called. Implementations must
document this precondition and any actions taken if the lock is
not held. Typically, an exception such as {@link
IllegalMonitorStateException} will be thrown."
      end

      operation 1445915 "signalAll"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up all waiting threads.

<p>If any threads are waiting on this condition then they are
all woken up. Each thread must re-acquire the lock before it can
return from {@code await}.

<p><b>Implementation Considerations</b>

<p>An implementation may (and typically does) require that the
current thread hold the lock associated with this {@code
Condition} when this method is called. Implementations must
document this precondition and any actions taken if the lock is
not held. Typically, an exception such as {@link
IllegalMonitorStateException} will be thrown."
      end
    end

    class 256027 "Lock"
      visibility public stereotype "interface"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "{@code Lock} implementations provide more extensive locking
operations than can be obtained using {@code synchronized} methods
and statements.  They allow more flexible structuring, may have
quite different properties, and may support multiple associated
{@link Condition} objects.

<p>A lock is a tool for controlling access to a shared resource by
multiple threads. Commonly, a lock provides exclusive access to a
shared resource: only one thread at a time can acquire the lock and
all access to the shared resource requires that the lock be
acquired first. However, some locks may allow concurrent access to
a shared resource, such as the read lock of a {@link ReadWriteLock}.

<p>The use of {@code synchronized} methods or statements provides
access to the implicit monitor lock associated with every object, but
forces all lock acquisition and release to occur in a block-structured way:
when multiple locks are acquired they must be released in the opposite
order, and all locks must be released in the same lexical scope in which
they were acquired.

<p>While the scoping mechanism for {@code synchronized} methods
and statements makes it much easier to program with monitor locks,
and helps avoid many common programming errors involving locks,
there are occasions where you need to work with locks in a more
flexible way. For example, some algorithms for traversing
concurrently accessed data structures require the use of
&quot;hand-over-hand&quot; or &quot;chain locking&quot;: you
acquire the lock of node A, then node B, then release A and acquire
C, then release B and acquire D and so on.  Implementations of the
{@code Lock} interface enable the use of such techniques by
allowing a lock to be acquired and released in different scopes,
and allowing multiple locks to be acquired and released in any
order.

<p>With this increased flexibility comes additional
responsibility. The absence of block-structured locking removes the
automatic release of locks that occurs with {@code synchronized}
methods and statements. In most cases, the following idiom
should be used:

 <pre> {@code
Lock l = ...;
l.lock();
try {
  // access the resource protected by this lock
} finally {
  l.unlock();
}}</pre>

When locking and unlocking occur in different scopes, care must be
taken to ensure that all code that is executed while the lock is
held is protected by try-finally or try-catch to ensure that the
lock is released when necessary.

<p>{@code Lock} implementations provide additional functionality
over the use of {@code synchronized} methods and statements by
providing a non-blocking attempt to acquire a lock ({@link
#tryLock()}), an attempt to acquire the lock that can be
interrupted ({@link #lockInterruptibly}, and an attempt to acquire
the lock that can timeout ({@link #tryLock(long, TimeUnit)}).

<p>A {@code Lock} class can also provide behavior and semantics
that is quite different from that of the implicit monitor lock,
such as guaranteed ordering, non-reentrant usage, or deadlock
detection. If an implementation provides such specialized semantics
then the implementation must document those semantics.

<p>Note that {@code Lock} instances are just normal objects and can
themselves be used as the target in a {@code synchronized} statement.
Acquiring the
monitor lock of a {@code Lock} instance has no specified relationship
with invoking any of the {@link #lock} methods of that instance.
It is recommended that to avoid confusion you never use {@code Lock}
instances in this way, except within their own implementation.

<p>Except where noted, passing a {@code null} value for any
parameter will result in a {@link NullPointerException} being
thrown.

<h3>Memory Synchronization</h3>

<p>All {@code Lock} implementations <em>must</em> enforce the same
memory synchronization semantics as provided by the built-in monitor
lock, as described in <a href=\"http://java.sun.com/docs/books/jls/\">
The Java Language Specification, Third Edition (17.4 Memory Model)</a>:
<ul>
<li>A successful {@code lock} operation has the same memory
synchronization effects as a successful <em>Lock</em> action.
<li>A successful {@code unlock} operation has the same
memory synchronization effects as a successful <em>Unlock</em> action.
</ul>

Unsuccessful locking and unlocking operations, and reentrant
locking/unlocking operations, do not require any memory
synchronization effects.

<h3>Implementation Considerations</h3>

<p> The three forms of lock acquisition (interruptible,
non-interruptible, and timed) may differ in their performance
characteristics, ordering guarantees, or other implementation
qualities.  Further, the ability to interrupt the <em>ongoing</em>
acquisition of a lock may not be available in a given {@code Lock}
class.  Consequently, an implementation is not required to define
exactly the same guarantees or semantics for all three forms of
lock acquisition, nor is it required to support interruption of an
ongoing lock acquisition.  An implementation is required to clearly
document the semantics and guarantees provided by each of the
locking methods. It must also obey the interruption semantics as
defined in this interface, to the extent that interruption of lock
acquisition is supported: which is either totally, or only on
method entry.

<p>As interruption generally implies cancellation, and checks for
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action may have unblocked
the thread. An implementation should document this behavior.

@see ReentrantLock
@see Condition
@see ReadWriteLock

@since 1.5
@author Doug Lea"
      operation 1436443 "lock"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock.

<p>If the lock is not available then the current thread becomes
disabled for thread scheduling purposes and lies dormant until the
lock has been acquired.

<p><b>Implementation Considerations</b>

<p>A {@code Lock} implementation may be able to detect erroneous use
of the lock, such as an invocation that would cause deadlock, and
may throw an (unchecked) exception in such circumstances.  The
circumstances and the exception type must be documented by that
{@code Lock} implementation."
      end

      operation 1436571 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is available and returns immediately.

<p>If the lock is not available then the current thread becomes
disabled for thread scheduling purposes and lies dormant until
one of two things happens:

<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of lock acquisition is supported.
</ul>

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while acquiring the
lock, and interruption of lock acquisition is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p><b>Implementation Considerations</b>

<p>The ability to interrupt a lock acquisition in some
implementations may not be possible, and if possible may be an
expensive operation.  The programmer should be aware that this
may be the case. An implementation should document when this is
the case.

<p>An implementation can favor responding to an interrupt over
normal method return.

<p>A {@code Lock} implementation may be able to detect
erroneous use of the lock, such as an invocation that would
cause deadlock, and may throw an (unchecked) exception in such
circumstances.  The circumstances and the exception type must
be documented by that {@code Lock} implementation.

@throws InterruptedException if the current thread is
        interrupted while acquiring the lock (and interruption
        of lock acquisition is supported)."
      end

      operation 1436699 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is free at the time of invocation.

<p>Acquires the lock if it is available and returns immediately
with the value {@code true}.
If the lock is not available then this method will return
immediately with the value {@code false}.

<p>A typical usage idiom for this method would be:
 <pre> {@code
Lock lock = ...;
if (lock.tryLock()) {
  try {
    // manipulate protected state
  } finally {
    lock.unlock();
  }
} else {
  // perform alternative actions
}}</pre>

This usage ensures that the lock is unlocked if it was acquired, and
doesn't try to unlock if the lock was not acquired.

@return {@code true} if the lock was acquired and
        {@code false} otherwise"
      end

      operation 1436827 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 253211 // TimeUnit
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is free within the given waiting time and the
current thread has not been {@linkplain Thread#interrupt interrupted}.

<p>If the lock is available this method returns immediately
with the value {@code true}.
If the lock is not available then
the current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:
<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of lock acquisition is supported; or
<li>The specified waiting time elapses
</ul>

<p>If the lock is acquired then the value {@code true} is returned.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while acquiring
the lock, and interruption of lock acquisition is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>If the specified waiting time elapses then the value {@code false}
is returned.
If the time is
less than or equal to zero, the method will not wait at all.

<p><b>Implementation Considerations</b>

<p>The ability to interrupt a lock acquisition in some implementations
may not be possible, and if possible may
be an expensive operation.
The programmer should be aware that this may be the case. An
implementation should document when this is the case.

<p>An implementation can favor responding to an interrupt over normal
method return, or reporting a timeout.

<p>A {@code Lock} implementation may be able to detect
erroneous use of the lock, such as an invocation that would cause
deadlock, and may throw an (unchecked) exception in such circumstances.
The circumstances and the exception type must be documented by that
{@code Lock} implementation.

@param time the maximum time to wait for the lock
@param unit the time unit of the {@code time} argument
@return {@code true} if the lock was acquired and {@code false}
        if the waiting time elapsed before the lock was acquired

@throws InterruptedException if the current thread is interrupted
        while acquiring the lock (and interruption of lock
        acquisition is supported)"
      end

      operation 1436955 "unlock"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases the lock.

<p><b>Implementation Considerations</b>

<p>A {@code Lock} implementation will usually impose
restrictions on which thread can release a lock (typically only the
holder of the lock can release it) and may throw
an (unchecked) exception if the restriction is violated.
Any restrictions and the exception
type must be documented by that {@code Lock} implementation."
      end

      operation 1437083 "newCondition"
	public return_type class_ref 254363 // Condition
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a new {@link Condition} instance that is bound to this
{@code Lock} instance.

<p>Before waiting on the condition the lock must be held by the
current thread.
A call to {@link Condition#await()} will atomically release the lock
before waiting and re-acquire the lock before the wait returns.

<p><b>Implementation Considerations</b>

<p>The exact operation of the {@link Condition} instance depends on
the {@code Lock} implementation and must be documented by that
implementation.

@return A new {@link Condition} instance for this {@code Lock} instance
@throws UnsupportedOperationException if this {@code Lock}
        implementation does not support conditions"
      end
    end

    class 256283 "AbstractQueuedSynchronizer"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " BEGIN android-note
 Use older class level documentation to not @link to hasQueuedPredecessors
 END android-changed

Provides a framework for implementing blocking locks and related
synchronizers (semaphores, events, etc) that rely on
first-in-first-out (FIFO) wait queues.  This class is designed to
be a useful basis for most kinds of synchronizers that rely on a
single atomic <tt>int</tt> value to represent state. Subclasses
must define the protected methods that change this state, and which
define what that state means in terms of this object being acquired
or released.  Given these, the other methods in this class carry
out all queuing and blocking mechanics. Subclasses can maintain
other state fields, but only the atomically updated <tt>int</tt>
value manipulated using methods {@link #getState}, {@link
#setState} and {@link #compareAndSetState} is tracked with respect
to synchronization.

<p>Subclasses should be defined as non-public internal helper
classes that are used to implement the synchronization properties
of their enclosing class.  Class
<tt>AbstractQueuedSynchronizer</tt> does not implement any
synchronization interface.  Instead it defines methods such as
{@link #acquireInterruptibly} that can be invoked as
appropriate by concrete locks and related synchronizers to
implement their public methods.

<p>This class supports either or both a default <em>exclusive</em>
mode and a <em>shared</em> mode. When acquired in exclusive mode,
attempted acquires by other threads cannot succeed. Shared mode
acquires by multiple threads may (but need not) succeed. This class
does not &quot;understand&quot; these differences except in the
mechanical sense that when a shared mode acquire succeeds, the next
waiting thread (if one exists) must also determine whether it can
acquire as well. Threads waiting in the different modes share the
same FIFO queue. Usually, implementation subclasses support only
one of these modes, but both can come into play for example in a
{@link ReadWriteLock}. Subclasses that support only exclusive or
only shared modes need not define the methods supporting the unused mode.

<p>This class defines a nested {@link ConditionObject} class that
can be used as a {@link Condition} implementation by subclasses
supporting exclusive mode for which method {@link
#isHeldExclusively} reports whether synchronization is exclusively
held with respect to the current thread, method {@link #release}
invoked with the current {@link #getState} value fully releases
this object, and {@link #acquire}, given this saved state value,
eventually restores this object to its previous acquired state.  No
<tt>AbstractQueuedSynchronizer</tt> method otherwise creates such a
condition, so if this constraint cannot be met, do not use it.  The
behavior of {@link ConditionObject} depends of course on the
semantics of its synchronizer implementation.

<p>This class provides inspection, instrumentation, and monitoring
methods for the internal queue, as well as similar methods for
condition objects. These can be exported as desired into classes
using an <tt>AbstractQueuedSynchronizer</tt> for their
synchronization mechanics.

<p>Serialization of this class stores only the underlying atomic
integer maintaining state, so deserialized objects have empty
thread queues. Typical subclasses requiring serializability will
define a <tt>readObject</tt> method that restores this to a known
initial state upon deserialization.

<h3>Usage</h3>

<p>To use this class as the basis of a synchronizer, redefine the
following methods, as applicable, by inspecting and/or modifying
the synchronization state using {@link #getState}, {@link
#setState} and/or {@link #compareAndSetState}:

<ul>
<li> {@link #tryAcquire}
<li> {@link #tryRelease}
<li> {@link #tryAcquireShared}
<li> {@link #tryReleaseShared}
<li> {@link #isHeldExclusively}
</ul>

Each of these methods by default throws {@link
UnsupportedOperationException}.  Implementations of these methods
must be internally thread-safe, and should in general be short and
not block. Defining these methods is the <em>only</em> supported
means of using this class. All other methods are declared
<tt>final</tt> because they cannot be independently varied.

<p>You may also find the inherited methods from {@link
AbstractOwnableSynchronizer} useful to keep track of the thread
owning an exclusive synchronizer.  You are encouraged to use them
-- this enables monitoring and diagnostic tools to assist users in
determining which threads hold locks.

<p>Even though this class is based on an internal FIFO queue, it
does not automatically enforce FIFO acquisition policies.  The core
of exclusive synchronization takes the form:

<pre>
Acquire:
    while (!tryAcquire(arg)) {
       <em>enqueue thread if it is not already queued</em>;
       <em>possibly block current thread</em>;
    }

Release:
    if (tryRelease(arg))
       <em>unblock the first queued thread</em>;
</pre>

(Shared mode is similar but may involve cascading signals.)

<p><a name=\"barging\">Because checks in acquire are invoked before
enqueuing, a newly acquiring thread may <em>barge</em> ahead of
others that are blocked and queued. However, you can, if desired,
define <tt>tryAcquire</tt> and/or <tt>tryAcquireShared</tt> to
disable barging by internally invoking one or more of the inspection
methods. In particular, a strict FIFO lock can define
<tt>tryAcquire</tt> to immediately return <tt>false</tt> if {@link
#getFirstQueuedThread} does not return the current thread.  A
normally preferable non-strict fair version can immediately return
<tt>false</tt> only if {@link #hasQueuedThreads} returns
<tt>true</tt> and <tt>getFirstQueuedThread</tt> is not the current
thread; or equivalently, that <tt>getFirstQueuedThread</tt> is both
non-null and not the current thread.  Further variations are
possible.

<p>Throughput and scalability are generally highest for the
default barging (also known as <em>greedy</em>,
<em>renouncement</em>, and <em>convoy-avoidance</em>) strategy.
While this is not guaranteed to be fair or starvation-free, earlier
queued threads are allowed to recontend before later queued
threads, and each recontention has an unbiased chance to succeed
against incoming threads.  Also, while acquires do not
&quot;spin&quot; in the usual sense, they may perform multiple
invocations of <tt>tryAcquire</tt> interspersed with other
computations before blocking.  This gives most of the benefits of
spins when exclusive synchronization is only briefly held, without
most of the liabilities when it isn't. If so desired, you can
augment this by preceding calls to acquire methods with
\"fast-path\" checks, possibly prechecking {@link #hasContended}
and/or {@link #hasQueuedThreads} to only do so if the synchronizer
is likely not to be contended.

<p>This class provides an efficient and scalable basis for
synchronization in part by specializing its range of use to
synchronizers that can rely on <tt>int</tt> state, acquire, and
release parameters, and an internal FIFO wait queue. When this does
not suffice, you can build synchronizers from a lower level using
{@link java.util.concurrent.atomic atomic} classes, your own custom
{@link java.util.Queue} classes, and {@link LockSupport} blocking
support.

<h3>Usage Examples</h3>

<p>Here is a non-reentrant mutual exclusion lock class that uses
the value zero to represent the unlocked state, and one to
represent the locked state. While a non-reentrant lock
does not strictly require recording of the current owner
thread, this class does so anyway to make usage easier to monitor.
It also supports conditions and exposes
one of the instrumentation methods:

 <pre> {@code
class Mutex implements Lock, java.io.Serializable {

  // Our internal helper class
  private static class Sync extends AbstractQueuedSynchronizer {
    // Report whether in locked state
    protected boolean isHeldExclusively() {
      return getState() == 1;
    }

    // Acquire the lock if state is zero
    public boolean tryAcquire(int acquires) {
      assert acquires == 1; // Otherwise unused
      if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
      }
      return false;
    }

    // Release the lock by setting state to zero
    protected boolean tryRelease(int releases) {
      assert releases == 1; // Otherwise unused
      if (getState() == 0) throw new IllegalMonitorStateException();
      setExclusiveOwnerThread(null);
      setState(0);
      return true;
    }

    // Provide a Condition
    Condition newCondition() { return new ConditionObject(); }

    // Deserialize properly
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
      s.defaultReadObject();
      setState(0); // reset to unlocked state
    }
  }

  // The sync object does all the hard work. We just forward to it.
  private final Sync sync = new Sync();

  public void lock()                { sync.acquire(1); }
  public boolean tryLock()          { return sync.tryAcquire(1); }
  public void unlock()              { sync.release(1); }
  public Condition newCondition()   { return sync.newCondition(); }
  public boolean isLocked()         { return sync.isHeldExclusively(); }
  public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
  public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
  }
  public boolean tryLock(long timeout, TimeUnit unit)
      throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
  }
}}</pre>

<p>Here is a latch class that is like a {@link CountDownLatch}
except that it only requires a single <tt>signal</tt> to
fire. Because a latch is non-exclusive, it uses the <tt>shared</tt>
acquire and release methods.

 <pre> {@code
class BooleanLatch {

  private static class Sync extends AbstractQueuedSynchronizer {
    boolean isSignalled() { return getState() != 0; }

    protected int tryAcquireShared(int ignore) {
      return isSignalled() ? 1 : -1;
    }

    protected boolean tryReleaseShared(int ignore) {
      setState(1);
      return true;
    }
  }

  private final Sync sync = new Sync();
  public boolean isSignalled() { return sync.isSignalled(); }
  public void signal()         { sync.releaseShared(1); }
  public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
  }
}}</pre>

@since 1.5
@author Doug Lea"
      classrelation 415515 // <generalisation>
	relation 415515 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 415515 // <generalisation>
	  b parent class_ref 256411 // AbstractOwnableSynchronizer
      end

      classrelation 415643 // <realization>
	relation 415643 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 415643 // <realization>
	  b parent class_ref 128155 // Serializable
      end

      attribute 356763 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984972572414691L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 1437595 "AbstractQueuedSynchronizer"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new <tt>AbstractQueuedSynchronizer</tt> instance
with initial synchronization state of zero."
      end

      class 256539 "Node"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 415771 // SHARED (<unidirectional association>)
	  relation 415771 --->
	    a role_name "SHARED" init_value " new Node()" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in shared mode 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 415771 // SHARED (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	classrelation 415899 // EXCLUSIVE (<unidirectional association>)
	  relation 415899 --->
	    a role_name "EXCLUSIVE" init_value " null" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in exclusive mode 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 415899 // EXCLUSIVE (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	attribute 356891 "CANCELLED"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "  1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread has cancelled "
	end

	attribute 357019 "SIGNAL"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate successor's thread needs unparking "
	end

	attribute 357147 "CONDITION"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -2"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread is waiting on condition "
	end

	attribute 357275 "PROPAGATE"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -3"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "waitStatus value to indicate the next acquireShared should
unconditionally propagate
"
	end

	attribute 357403 "waitStatus"
	  volatile package explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "Status field, taking on only the values:
  SIGNAL:     The successor of this node is (or will soon be)
              blocked (via park), so the current node must
              unpark its successor when it releases or
              cancels. To avoid races, acquire methods must
              first indicate they need a signal,
              then retry the atomic acquire, and then,
              on failure, block.
  CANCELLED:  This node is cancelled due to timeout or interrupt.
              Nodes never leave this state. In particular,
              a thread with cancelled node never again blocks.
  CONDITION:  This node is currently on a condition queue.
              It will not be used as a sync queue node
              until transferred, at which time the status
              will be set to 0. (Use of this value here has
              nothing to do with the other uses of the
              field, but simplifies mechanics.)
  PROPAGATE:  A releaseShared should be propagated to other
              nodes. This is set (for head node only) in
              doReleaseShared to ensure propagation
              continues, even if other operations have
              since intervened.
  0:          None of the above

The values are arranged numerically to simplify use.
Non-negative values mean that a node doesn't need to
signal. So, most code doesn't need to check for particular
values, just for sign.

The field is initialized to 0 for normal sync nodes, and
CONDITION for condition nodes.  It is modified using CAS
(or when possible, unconditional volatile writes).
"
	end

	classrelation 416027 // prev (<unidirectional association>)
	  relation 416027 --->
	    a role_name "prev" volatile package
	      comment "
Link to predecessor node that current node/thread relies on
for checking waitStatus. Assigned during enqueing, and nulled
out (for sake of GC) only upon dequeuing.  Also, upon
cancellation of a predecessor, we short-circuit while
finding a non-cancelled one, which will always exist
because the head node is never cancelled: A node becomes
head only as a result of successful acquire. A
cancelled thread never succeeds in acquiring, and a thread only
cancels itself, not any other node.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 416027 // prev (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	classrelation 416155 // next (<unidirectional association>)
	  relation 416155 --->
	    a role_name "next" volatile package
	      comment "
Link to the successor node that the current node/thread
unparks upon release. Assigned during enqueuing, adjusted
when bypassing cancelled predecessors, and nulled out (for
sake of GC) when dequeued.  The enq operation does not
assign next field of a predecessor until after attachment,
so seeing a null next field does not necessarily mean that
node is at end of queue. However, if a next field appears
to be null, we can scan prev's from the tail to
double-check.  The next field of cancelled nodes is set to
point to the node itself instead of null, to make life
easier for isOnSyncQueue.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 416155 // next (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	classrelation 416283 // thread (<unidirectional association>)
	  relation 416283 --->
	    a role_name "thread" volatile package
	      comment "
The thread that enqueued this node.  Initialized on
construction and nulled out after use.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 416283 // thread (<unidirectional association>)
	    b parent class_ref 1201420 // Thread
	end

	classrelation 416411 // nextWaiter (<unidirectional association>)
	  relation 416411 --->
	    a role_name "nextWaiter" package
	      comment "
Link to next node waiting on condition, or the special
value SHARED.  Because condition queues are accessed only
when holding in exclusive mode, we just need a simple
linked queue to hold nodes while they are waiting on
conditions. They are then transferred to the queue to
re-acquire. And because conditions can only be exclusive,
we save a field by using special value to indicate shared
mode.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 416411 // nextWaiter (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	operation 1437723 "isShared"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if node is waiting in shared mode"
	end

	operation 1437851 "predecessor"
	  package return_type class_ref 256539 // Node
	  nparams 0
	  nexceptions 1
	    exception class_ref 156699 // NullPointerException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns previous node, or throws NullPointerException if null.
Use when predecessor cannot be null.  The null check could
be elided, but is present to help the VM.

@return the predecessor of this node"
	end

	operation 1437979 "Node"
	  package explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1438107 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 1201420 // Thread
	    param inout name "mode" type class_ref 256539 // Node
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1438235 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 1201420 // Thread
	    param in name "waitStatus" explicit_type "int"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 416539 // head (<unidirectional association>)
	relation 416539 --->
	  a role_name "head" volatile private
	    comment "
Head of the wait queue, lazily initialized.  Except for
initialization, it is modified only via method setHead.  Note:
If head exists, its waitStatus is guaranteed not to be
CANCELLED.

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 416539 // head (<unidirectional association>)
	  b parent class_ref 256539 // Node
      end

      classrelation 416667 // tail (<unidirectional association>)
	relation 416667 --->
	  a role_name "tail" volatile private
	    comment "
Tail of the wait queue, lazily initialized.  Modified only via
method enq to add new wait node.

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 416667 // tail (<unidirectional association>)
	  b parent class_ref 256539 // Node
      end

      attribute 357531 "state"
	volatile private explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The synchronization state.
"
      end

      operation 1438363 "getState"
	protected explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> read.
@return current state value"
      end

      operation 1438491 "setState"
	protected explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> write.
@param newState the new state value"
      end

      operation 1438619 "compareAndSetState"
	protected explicit_return_type "boolean"
	nparams 2
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Atomically sets synchronization state to the given updated
value if the current state value equals the expected value.
This operation has memory semantics of a <tt>volatile</tt> read
and write.

@param expect the expected value
@param update the new value
@return true if successful. False return indicates that the actual
        value was not equal to the expected value."
      end

      attribute 357659 "spinForTimeoutThreshold"
	class_attribute const_attribute package explicit_type "long"
	init_value " 1000L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " Queuing utilities

The number of nanoseconds for which it is faster to spin
rather than to use timed park. A rough estimate suffices
to improve responsiveness with very short timeouts.
"
      end

      operation 1438747 "enq"
	private return_type class_ref 256539 // Node
	nparams 1
	  param in name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Inserts node into queue, initializing if necessary. See picture above.
@param node the node to insert
@return node's predecessor"
      end

      operation 1438875 "addWaiter"
	private return_type class_ref 256539 // Node
	nparams 1
	  param inout name "mode" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates and enqueues node for current thread and given mode.

@param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
@return the new node"
      end

      operation 1439003 "setHead"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue to be node, thus dequeuing. Called only by
acquire methods.  Also nulls out unused fields for sake of GC
and to suppress unnecessary signals and traversals.

@param node the node"
      end

      operation 1439131 "unparkSuccessor"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up node's successor, if one exists.

@param node the node"
      end

      operation 1439259 "doReleaseShared"
	private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Release action for shared mode -- signal successor and ensure
propagation. (Note: For exclusive mode, release just amounts
to calling unparkSuccessor of head if it needs signal.)"
      end

      operation 1439387 "setHeadAndPropagate"
	private explicit_return_type "void"
	nparams 2
	  param inout name "node" type class_ref 256539 // Node
	  param in name "propagate" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue, and checks if successor may be waiting
in shared mode, if so propagating if either propagate > 0 or
PROPAGATE status was set.

@param node the node
@param propagate the return value from a tryAcquireShared"
      end

      operation 1439515 "cancelAcquire"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Utilities for various versions of acquire

Cancels an ongoing attempt to acquire.

@param node the node"
      end

      operation 1439643 "shouldParkAfterFailedAcquire"
	class_operation private explicit_return_type "boolean"
	nparams 2
	  param inout name "pred" type class_ref 256539 // Node
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Checks and updates status for a node that failed to acquire.
Returns true if thread should block. This is the main signal
control in all acquire loops.  Requires that pred == node.prev

@param pred node's predecessor holding status
@param node the node
@return {@code true} if thread should block"
      end

      operation 1439771 "selfInterrupt"
	class_operation package explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to interrupt current thread."
      end

      operation 1439899 "parkAndCheckInterrupt"
	private explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to park and then check if interrupted

@return {@code true} if interrupted"
      end

      operation 1440027 "acquireQueued"
	package explicit_return_type "boolean"
	nparams 2
	  param in name "node" type class_ref 256539 // Node
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Various flavors of acquire, varying in exclusive/shared and
control modes.  Each is mostly the same, but annoyingly
different.  Only a little bit of factoring is possible due to
interactions of exception mechanics (including ensuring that we
cancel if tryAcquire throws exception) and other control, at
least not without hurting performance too much.


Acquires in exclusive uninterruptible mode for thread already in
queue. Used by condition wait methods as well as acquire.

@param node the node
@param arg the acquire argument
@return {@code true} if interrupted while waiting"
      end

      operation 1440155 "doAcquireInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive interruptible mode.
@param arg the acquire argument"
      end

      operation 1440283 "doAcquireNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired"
      end

      operation 1440411 "doAcquireShared"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared uninterruptible mode.
@param arg the acquire argument"
      end

      operation 1440539 "doAcquireSharedInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared interruptible mode.
@param arg the acquire argument"
      end

      operation 1440667 "doAcquireSharedNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired"
      end

      operation 1440795 "tryAcquire"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Main exported methods

Attempts to acquire in exclusive mode. This method should query
if the state of the object permits it to be acquired in the
exclusive mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread. This can be used
to implement method {@link Lock#tryLock()}.

<p>The default
implementation throws {@link UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return {@code true} if successful. Upon success, this object has
        been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 1440923 "tryRelease"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in exclusive
mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this object is now in a fully released
        state, so that any waiting threads may attempt to acquire;
        and {@code false} otherwise.
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 1441051 "tryAcquireShared"
	protected explicit_return_type "int"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode. This method should query if
the state of the object permits it to be acquired in the shared
mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread.

<p>The default implementation throws {@link
UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return a negative value on failure; zero if acquisition in shared
        mode succeeded but no subsequent shared-mode acquire can
        succeed; and a positive value if acquisition in shared
        mode succeeded and subsequent shared-mode acquires might
        also succeed, in which case a subsequent waiting thread
        must check availability. (Support for three different
        return values enables this method to be used in contexts
        where acquires only sometimes act exclusively.)  Upon
        success, this object has been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 1441179 "tryReleaseShared"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in shared mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this release of shared mode may permit a
        waiting acquire (shared or exclusive) to succeed; and
        {@code false} otherwise
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 1441307 "isHeldExclusively"
	protected explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if synchronization is held exclusively with
respect to the current (calling) thread.  This method is invoked
upon each call to a non-waiting {@link ConditionObject} method.
(Waiting methods instead invoke {@link #release}.)

<p>The default implementation throws {@link
UnsupportedOperationException}. This method is invoked
internally only within {@link ConditionObject} methods, so need
not be defined if conditions are not used.

@return {@code true} if synchronization is held exclusively;
        {@code false} otherwise
@throws UnsupportedOperationException if conditions are not supported"
      end

      operation 1441435 "acquire"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, ignoring interrupts.  Implemented
by invoking at least once {@link #tryAcquire},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquire} until success.  This method can be used
to implement method {@link Lock#lock}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like."
      end

      operation 1441563 "acquireInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, aborting if interrupted.
Implemented by first checking interrupt status, then invoking
at least once {@link #tryAcquire}, returning on
success.  Otherwise the thread is queued, possibly repeatedly
blocking and unblocking, invoking {@link #tryAcquire}
until success or the thread is interrupted.  This method can be
used to implement method {@link Lock#lockInterruptibly}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1441691 "tryAcquireNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in exclusive mode, aborting if interrupted,
and failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquire}, returning on success.  Otherwise, the thread is
queued, possibly repeatedly blocking and unblocking, invoking
{@link #tryAcquire} until success or the thread is interrupted
or the timeout elapses.  This method can be used to implement
method {@link Lock#tryLock(long, TimeUnit)}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1441819 "release"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in exclusive mode.  Implemented by unblocking one or
more threads if {@link #tryRelease} returns true.
This method can be used to implement method {@link Lock#unlock}.

@param arg the release argument.  This value is conveyed to
       {@link #tryRelease} but is otherwise uninterpreted and
       can represent anything you like.
@return the value returned from {@link #tryRelease}"
      end

      operation 1441947 "acquireShared"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, ignoring interrupts.  Implemented by
first invoking at least once {@link #tryAcquireShared},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquireShared} until success.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like."
      end

      operation 1442075 "acquireSharedInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, aborting if interrupted.  Implemented
by first checking interrupt status, then invoking at least once
{@link #tryAcquireShared}, returning on success.  Otherwise the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted.
@param arg the acquire argument
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1442203 "tryAcquireSharedNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode, aborting if interrupted, and
failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquireShared}, returning on success.  Otherwise, the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted or the timeout elapses.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1442331 "releaseShared"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in shared mode.  Implemented by unblocking one or more
threads if {@link #tryReleaseShared} returns true.

@param arg the release argument.  This value is conveyed to
       {@link #tryReleaseShared} but is otherwise uninterpreted
       and can represent anything you like.
@return the value returned from {@link #tryReleaseShared}"
      end

      operation 1442459 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queue inspection methods

Queries whether any threads are waiting to acquire. Note that
because cancellations due to interrupts and timeouts may occur
at any time, a {@code true} return does not guarantee that any
other thread will ever acquire.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there may be other threads waiting to acquire"
      end

      operation 1442587 "hasContended"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have ever contended to acquire this
synchronizer; that is if an acquire method has ever blocked.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there has ever been contention"
      end

      operation 1442715 "getFirstQueuedThread"
	public return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the first (longest-waiting) thread in the queue, or
{@code null} if no threads are currently queued.

<p>In this implementation, this operation normally returns in
constant time, but may iterate upon contention if other threads are
concurrently modifying the queue.

@return the first (longest-waiting) thread in the queue, or
        {@code null} if no threads are currently queued"
      end

      operation 1442843 "fullGetFirstQueuedThread"
	private return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Version of getFirstQueuedThread called when fastpath fails"
      end

      operation 1442971 "isQueued"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the given thread is currently queued.

<p>This implementation traverses the queue to determine
presence of the given thread.

@param thread the thread
@return {@code true} if the given thread is on the queue
@throws NullPointerException if the thread is null"
      end

      operation 1443099 "apparentlyFirstQueuedIsExclusive"
	package explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the apparent first queued thread, if one
exists, is waiting in exclusive mode.  If this method returns
{@code true}, and the current thread is attempting to acquire in
shared mode (that is, this method is invoked from {@link
#tryAcquireShared}) then it is guaranteed that the current thread
is not the first queued thread.  Used only as a heuristic in
ReentrantReadWriteLock."
      end

      operation 1443227 "hasQueuedPredecessors"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have been waiting to acquire longer
than the current thread.

<p>An invocation of this method is equivalent to (but may be
more efficient than):
 <pre> {@code
getFirstQueuedThread() != Thread.currentThread() &&
hasQueuedThreads()}</pre>

<p>Note that because cancellations due to interrupts and
timeouts may occur at any time, a {@code true} return does not
guarantee that some other thread will acquire before the current
thread.  Likewise, it is possible for another thread to win a
race to enqueue after this method has returned {@code false},
due to the queue being empty.

<p>This method is designed to be used by a fair synchronizer to
avoid <a href=\"AbstractQueuedSynchronizer#barging\">barging</a>.
Such a synchronizer's {@link #tryAcquire} method should return
{@code false}, and its {@link #tryAcquireShared} method should
return a negative value, if this method returns {@code true}
(unless this is a reentrant acquire).  For example, the {@code
tryAcquire} method for a fair, reentrant, exclusive mode
synchronizer might look like this:

 <pre> {@code
protected boolean tryAcquire(int arg) {
  if (isHeldExclusively()) {
    // A reentrant acquire; increment hold count
    return true;
  } else if (hasQueuedPredecessors()) {
    return false;
  } else {
    // try to acquire normally
  }
}}</pre>

@return {@code true} if there is a queued thread preceding the
        current thread, and {@code false} if the current thread
        is at the head of the queue or the queue is empty
@since 1.7
@hide"
      end

      operation 1443355 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and monitoring methods

Returns an estimate of the number of threads waiting to
acquire.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring system state, not for synchronization
control.

@return the estimated number of threads waiting to acquire"
      end

      operation 1443483 "getQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads"
      end

      operation 1443611 "getExclusiveQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in exclusive mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to an exclusive acquire.

@return the collection of threads"
      end

      operation 1443739 "getSharedQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in shared mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to a shared acquire.

@return the collection of threads"
      end

      operation 1443867 "toString"
	public return_type class_ref 3399692 // String
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this synchronizer, as well as its state.
The state, in brackets, includes the String {@code \"State =\"}
followed by the current value of {@link #getState}, and either
{@code \"nonempty\"} or {@code \"empty\"} depending on whether the
queue is empty.

@return a string identifying this synchronizer, as well as its state"
      end

      operation 1443995 "isOnSyncQueue"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal support methods for Conditions

Returns true if a node, always one that was initially placed on
a condition queue, is now waiting to reacquire on sync queue.
@param node the node
@return true if is reacquiring"
      end

      operation 1444123 "findNodeFromTail"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if node is on sync queue by searching backwards from tail.
Called only when needed by isOnSyncQueue.
@return true if present"
      end

      operation 1444251 "transferForSignal"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers a node from a condition queue onto sync queue.
Returns true if successful.
@param node the node
@return true if successfully transferred (else the node was
cancelled before signal)."
      end

      operation 1444379 "transferAfterCancelledWait"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers node, if necessary, to sync queue after a cancelled
wait. Returns true if thread was cancelled before being
signalled.
@param node its node
@return true if cancelled before the node was signalled"
      end

      operation 1444507 "fullyRelease"
	package explicit_return_type "int"
	nparams 1
	  param inout name "node" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invokes release with current state value; returns saved state.
Cancels node and throws exception on failure.
@param node the condition node for this wait
@return previous sync state"
      end

      operation 1444635 "owns"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 256667 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation methods for conditions

Queries whether the given ConditionObject
uses this synchronizer as its lock.

@param condition the condition
@return <tt>true</tt> if owned
@throws NullPointerException if the condition is null"
      end

      class 256667 "ConditionObject"
	visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 416795 // <realization>
	  relation 416795 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 416795 // <realization>
	    b parent class_ref 254363 // Condition
	end

	classrelation 416923 // <realization>
	  relation 416923 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 416923 // <realization>
	    b parent class_ref 128155 // Serializable
	end

	attribute 357787 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 1173984872572414699L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 417051 // firstWaiter (<unidirectional association>)
	  relation 417051 --->
	    a role_name "firstWaiter" private
	      comment " First node of condition queue. 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 417051 // firstWaiter (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	classrelation 417179 // lastWaiter (<unidirectional association>)
	  relation 417179 --->
	    a role_name "lastWaiter" private
	      comment " Last node of condition queue. 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 417179 // lastWaiter (<unidirectional association>)
	    b parent class_ref 256539 // Node
	end

	operation 1446043 "ConditionObject"
	  public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Creates a new <tt>ConditionObject</tt> instance."
	end

	operation 1446171 "addConditionWaiter"
	  private return_type class_ref 256539 // Node
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Internal methods

Adds a new waiter to wait queue.
@return its new wait node"
	end

	operation 1446299 "doSignal"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 256539 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers nodes until hit non-cancelled one or
null. Split out from signal in part to encourage compilers
to inline the case of no waiters.
@param first (non-null) the first node on condition queue"
	end

	operation 1446427 "doSignalAll"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 256539 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers all nodes.
@param first (non-null) the first node on condition queue"
	end

	operation 1446555 "unlinkCancelledWaiters"
	  private explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Unlinks cancelled waiter nodes from condition queue.
Called only while holding lock. This is called when
cancellation occurred during condition wait, and upon
insertion of a new waiter when lastWaiter is seen to have
been cancelled. This method is needed to avoid garbage
retention in the absence of signals. So even though it may
require a full traversal, it comes into play only when
timeouts or cancellations occur in the absence of
signals. It traverses all nodes rather than stopping at a
particular target to unlink all pointers to garbage nodes
without requiring many re-traversals during cancellation
storms."
	end

	operation 1446683 "signal"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " public methods

Moves the longest-waiting thread, if one exists, from the
wait queue for this condition to the wait queue for the
owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1446811 "signalAll"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Moves all threads from the wait queue for this condition to
the wait queue for the owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1446939 "awaitUninterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements uninterruptible condition wait.
<ol>
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
</ol>"
	end

	attribute 357915 "REINTERRUPT"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "  1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "For interruptible waits, we need to track whether to throw
InterruptedException, if interrupted while blocked on
condition, versus reinterrupt current thread, if
interrupted while blocked waiting to re-acquire.

 Mode meaning to reinterrupt on exit from wait "
	end

	attribute 358043 "THROW_IE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " -1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " Mode meaning to throw InterruptedException on exit from wait "
	end

	operation 1447067 "checkInterruptWhileWaiting"
	  private explicit_return_type "int"
	  nparams 1
	    param inout name "node" type class_ref 256539 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Checks for interrupt, returning THROW_IE if interrupted
before signalled, REINTERRUPT if after signalled, or
0 if not interrupted."
	end

	operation 1447195 "reportInterruptAfterWait"
	  private explicit_return_type "void"
	  nparams 1
	    param in name "interruptMode" explicit_type "int"
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws InterruptedException, reinterrupts current thread, or
does nothing, depending on mode."
	end

	operation 1447323 "await"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements interruptible condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled or interrupted.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>"
	end

	operation 1447451 "awaitNanos"
	  public explicit_return_type "long"
	  nparams 1
	    param in name "nanosTimeout" explicit_type "long"
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>"
	end

	operation 1447579 "awaitUntil"
	  public explicit_return_type "boolean"
	  nparams 1
	    param inout name "deadline" type class_ref 171931 // Date
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements absolute timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>"
	end

	operation 1447707 "await"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 253211 // TimeUnit
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>"
	end

	operation 1447835 "isOwnedBy"
	  package explicit_return_type "boolean"
	  nparams 1
	    param inout name "sync" type class_ref 256283 // AbstractQueuedSynchronizer
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "  support for instrumentation

Returns true if this condition was created by the given
synchronization object.

@return {@code true} if owned"
	end

	operation 1447963 "hasWaiters"
	  protected explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries whether any threads are waiting on this condition.
Implements {@link AbstractQueuedSynchronizer#hasWaiters}.

@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1448091 "getWaitQueueLength"
	  protected explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an estimate of the number of threads waiting on
this condition.
Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength}.

@return the estimated number of waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1448219 "getWaitingThreads"
	  protected return_type class_ref 160667 // Collection
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a collection containing those threads that may be
waiting on this Condition.
Implements {@link AbstractQueuedSynchronizer#getWaitingThreads}.

@return the collection of threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end
      end

      operation 1444763 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 256667 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this synchronizer. Note that because timeouts
and interrupts may occur at any time, a <tt>true</tt> return
does not guarantee that a future <tt>signal</tt> will awaken
any threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return <tt>true</tt> if there are any waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      operation 1444891 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 256667 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this synchronizer. Note that
because timeouts and interrupts may occur at any time, the
estimate serves only as an upper bound on the actual number of
waiters.  This method is designed for use in monitoring of the
system state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      operation 1445019 "getWaitingThreads"
	public return_type class_ref 160667 // Collection
	nparams 1
	  param inout name "condition" type class_ref 256667 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this
synchronizer.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate. The elements of the
returned collection are in no particular order.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      classrelation 417307 // unsafe (<unidirectional association>)
	relation 417307 --->
	  a role_name "unsafe" init_value " Unsafe.getUnsafe()" class_relation const_relation private
	    comment "
Setup to support compareAndSet. We need to natively implement
this here: For the sake of permitting future enhancements, we
cannot explicitly subclass AtomicInteger, which would be
efficient and useful otherwise. So, as the lesser of evils, we
natively implement using hotspot intrinsics API. And while we
are at it, we do the same for other CASable fields (which could
otherwise be done with atomic field updaters).

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 417307 // unsafe (<unidirectional association>)
	  b parent class_ref 255899 // Unsafe
      end

      attribute 358171 "stateOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 358299 "headOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 358427 "tailOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 358555 "waitStatusOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 358683 "nextOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      extra_member 131227 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"waitStatus\"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"next\"));

        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
      end

      operation 1448347 "compareAndSetHead"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "update" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS head field. Used only by enq."
      end

      operation 1448475 "compareAndSetTail"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "expect" type class_ref 256539 // Node
	  param inout name "update" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS tail field. Used only by enq."
      end

      operation 1448603 "compareAndSetWaitStatus"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 256539 // Node
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS waitStatus field of a node."
      end

      operation 1448731 "compareAndSetNext"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 256539 // Node
	  param inout name "expect" type class_ref 256539 // Node
	  param inout name "update" type class_ref 256539 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS next field of a node."
      end
    end

    class 256411 "AbstractOwnableSynchronizer"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A synchronizer that may be exclusively owned by a thread.  This
class provides a basis for creating locks and related synchronizers
that may entail a notion of ownership.  The
<tt>AbstractOwnableSynchronizer</tt> class itself does not manage or
use this information. However, subclasses and tools may use
appropriately maintained values to help control and monitor access
and provide diagnostics.

@since 1.6
@author Doug Lea"
      classrelation 415259 // <realization>
	relation 415259 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 415259 // <realization>
	  b parent class_ref 128155 // Serializable
      end

      attribute 356635 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 3737899427754241961L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " Use serial ID even though all fields transient. "
      end

      operation 1437211 "AbstractOwnableSynchronizer"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Empty constructor for use by subclasses."
      end

      classrelation 415387 // exclusiveOwnerThread (<unidirectional association>)
	relation 415387 --->
	  a role_name "exclusiveOwnerThread" private
	    comment "
The current owner of exclusive mode synchronization.

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 415387 // exclusiveOwnerThread (<unidirectional association>)
	  b parent class_ref 1201420 // Thread
      end

      operation 1437339 "setExclusiveOwnerThread"
	protected explicit_return_type "void"
	nparams 1
	  param inout name "t" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the thread that currently owns exclusive access. A
<tt>null</tt> argument indicates that no thread owns access.
This method does not otherwise impose any synchronization or
<tt>volatile</tt> field accesses."
      end

      operation 1437467 "getExclusiveOwnerThread"
	protected return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread last set by
<tt>setExclusiveOwnerThread</tt>, or <tt>null</tt> if never
set.  This method does not otherwise impose any synchronization
or <tt>volatile</tt> field accesses.
@return the owner thread"
      end
    end

    class 274843 "AbstractQueuedLongSynchronizer"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A version of {@link AbstractQueuedSynchronizer} in
which synchronization state is maintained as a <tt>long</tt>.
This class has exactly the same structure, properties, and methods
as <tt>AbstractQueuedSynchronizer</tt> with the exception
that all state-related parameters and results are defined
as <tt>long</tt> rather than <tt>int</tt>. This class
may be useful when creating synchronizers such as
multilevel locks and barriers that require
64 bits of state.

<p>See {@link AbstractQueuedSynchronizer} for usage
notes and examples.

@since 1.6
@author Doug Lea"
      classrelation 468507 // <generalisation>
	relation 468507 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 468507 // <generalisation>
	  b parent class_ref 256411 // AbstractOwnableSynchronizer
      end

      classrelation 468635 // <realization>
	relation 468635 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 468635 // <realization>
	  b parent class_ref 128155 // Serializable
      end

      attribute 404251 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984972572414692L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 1653403 "AbstractQueuedLongSynchronizer"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "To keep sources in sync, the remainder of this source file is
exactly cloned from AbstractQueuedSynchronizer, replacing class
name and changing ints related with sync state to longs. Please
keep it that way.


Creates a new <tt>AbstractQueuedLongSynchronizer</tt> instance
with initial synchronization state of zero."
      end

      class 274971 "Node"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 468763 // SHARED (<unidirectional association>)
	  relation 468763 --->
	    a role_name "SHARED" init_value " new Node()" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in shared mode 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 468763 // SHARED (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	classrelation 468891 // EXCLUSIVE (<unidirectional association>)
	  relation 468891 --->
	    a role_name "EXCLUSIVE" init_value " null" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in exclusive mode 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 468891 // EXCLUSIVE (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	attribute 404379 "CANCELLED"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "  1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread has cancelled "
	end

	attribute 404507 "SIGNAL"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate successor's thread needs unparking "
	end

	attribute 404635 "CONDITION"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -2"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread is waiting on condition "
	end

	attribute 404763 "PROPAGATE"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -3"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "waitStatus value to indicate the next acquireShared should
unconditionally propagate
"
	end

	attribute 404891 "waitStatus"
	  volatile package explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "Status field, taking on only the values:
  SIGNAL:     The successor of this node is (or will soon be)
              blocked (via park), so the current node must
              unpark its successor when it releases or
              cancels. To avoid races, acquire methods must
              first indicate they need a signal,
              then retry the atomic acquire, and then,
              on failure, block.
  CANCELLED:  This node is cancelled due to timeout or interrupt.
              Nodes never leave this state. In particular,
              a thread with cancelled node never again blocks.
  CONDITION:  This node is currently on a condition queue.
              It will not be used as a sync queue node
              until transferred, at which time the status
              will be set to 0. (Use of this value here has
              nothing to do with the other uses of the
              field, but simplifies mechanics.)
  PROPAGATE:  A releaseShared should be propagated to other
              nodes. This is set (for head node only) in
              doReleaseShared to ensure propagation
              continues, even if other operations have
              since intervened.
  0:          None of the above

The values are arranged numerically to simplify use.
Non-negative values mean that a node doesn't need to
signal. So, most code doesn't need to check for particular
values, just for sign.

The field is initialized to 0 for normal sync nodes, and
CONDITION for condition nodes.  It is modified using CAS
(or when possible, unconditional volatile writes).
"
	end

	classrelation 469019 // prev (<unidirectional association>)
	  relation 469019 --->
	    a role_name "prev" volatile package
	      comment "
Link to predecessor node that current node/thread relies on
for checking waitStatus. Assigned during enqueing, and nulled
out (for sake of GC) only upon dequeuing.  Also, upon
cancellation of a predecessor, we short-circuit while
finding a non-cancelled one, which will always exist
because the head node is never cancelled: A node becomes
head only as a result of successful acquire. A
cancelled thread never succeeds in acquiring, and a thread only
cancels itself, not any other node.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 469019 // prev (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	classrelation 469147 // next (<unidirectional association>)
	  relation 469147 --->
	    a role_name "next" volatile package
	      comment "
Link to the successor node that the current node/thread
unparks upon release. Assigned during enqueuing, adjusted
when bypassing cancelled predecessors, and nulled out (for
sake of GC) when dequeued.  The enq operation does not
assign next field of a predecessor until after attachment,
so seeing a null next field does not necessarily mean that
node is at end of queue. However, if a next field appears
to be null, we can scan prev's from the tail to
double-check.  The next field of cancelled nodes is set to
point to the node itself instead of null, to make life
easier for isOnSyncQueue.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 469147 // next (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	classrelation 469275 // thread (<unidirectional association>)
	  relation 469275 --->
	    a role_name "thread" volatile package
	      comment "
The thread that enqueued this node.  Initialized on
construction and nulled out after use.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 469275 // thread (<unidirectional association>)
	    b parent class_ref 1201420 // Thread
	end

	classrelation 469403 // nextWaiter (<unidirectional association>)
	  relation 469403 --->
	    a role_name "nextWaiter" package
	      comment "
Link to next node waiting on condition, or the special
value SHARED.  Because condition queues are accessed only
when holding in exclusive mode, we just need a simple
linked queue to hold nodes while they are waiting on
conditions. They are then transferred to the queue to
re-acquire. And because conditions can only be exclusive,
we save a field by using special value to indicate shared
mode.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 469403 // nextWaiter (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	operation 1653531 "isShared"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if node is waiting in shared mode"
	end

	operation 1653659 "predecessor"
	  package return_type class_ref 274971 // Node
	  nparams 0
	  nexceptions 1
	    exception class_ref 156699 // NullPointerException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns previous node, or throws NullPointerException if null.
Use when predecessor cannot be null.  The null check could
be elided, but is present to help the VM.

@return the predecessor of this node"
	end

	operation 1653787 "Node"
	  package explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1653915 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 1201420 // Thread
	    param inout name "mode" type class_ref 274971 // Node
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1654043 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 1201420 // Thread
	    param in name "waitStatus" explicit_type "int"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 469531 // head (<unidirectional association>)
	relation 469531 --->
	  a role_name "head" volatile private
	    comment "
Head of the wait queue, lazily initialized.  Except for
initialization, it is modified only via method setHead.  Note:
If head exists, its waitStatus is guaranteed not to be
CANCELLED.

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 469531 // head (<unidirectional association>)
	  b parent class_ref 274971 // Node
      end

      classrelation 469659 // tail (<unidirectional association>)
	relation 469659 --->
	  a role_name "tail" volatile private
	    comment "
Tail of the wait queue, lazily initialized.  Modified only via
method enq to add new wait node.

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 469659 // tail (<unidirectional association>)
	  b parent class_ref 274971 // Node
      end

      attribute 405019 "state"
	volatile private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The synchronization state.
"
      end

      operation 1654171 "getState"
	protected explicit_return_type "long"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> read.
@return current state value"
      end

      operation 1654299 "setState"
	protected explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> write.
@param newState the new state value"
      end

      operation 1654427 "compareAndSetState"
	protected explicit_return_type "boolean"
	nparams 2
	  param in name "expect" explicit_type "long"
	  param in name "update" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Atomically sets synchronization state to the given updated
value if the current state value equals the expected value.
This operation has memory semantics of a <tt>volatile</tt> read
and write.

@param expect the expected value
@param update the new value
@return true if successful. False return indicates that the actual
        value was not equal to the expected value."
      end

      attribute 405147 "spinForTimeoutThreshold"
	class_attribute const_attribute package explicit_type "long"
	init_value " 1000L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " Queuing utilities

The number of nanoseconds for which it is faster to spin
rather than to use timed park. A rough estimate suffices
to improve responsiveness with very short timeouts.
"
      end

      operation 1654555 "enq"
	private return_type class_ref 274971 // Node
	nparams 1
	  param in name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Inserts node into queue, initializing if necessary. See picture above.
@param node the node to insert
@return node's predecessor"
      end

      operation 1654683 "addWaiter"
	private return_type class_ref 274971 // Node
	nparams 1
	  param inout name "mode" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates and enqueues node for current thread and given mode.

@param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
@return the new node"
      end

      operation 1654811 "setHead"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue to be node, thus dequeuing. Called only by
acquire methods.  Also nulls out unused fields for sake of GC
and to suppress unnecessary signals and traversals.

@param node the node"
      end

      operation 1654939 "unparkSuccessor"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up node's successor, if one exists.

@param node the node"
      end

      operation 1655067 "doReleaseShared"
	private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Release action for shared mode -- signal successor and ensure
propagation. (Note: For exclusive mode, release just amounts
to calling unparkSuccessor of head if it needs signal.)"
      end

      operation 1655195 "setHeadAndPropagate"
	private explicit_return_type "void"
	nparams 2
	  param inout name "node" type class_ref 274971 // Node
	  param in name "propagate" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue, and checks if successor may be waiting
in shared mode, if so propagating if either propagate > 0 or
PROPAGATE status was set.

@param node the node
@param propagate the return value from a tryAcquireShared"
      end

      operation 1655323 "cancelAcquire"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Utilities for various versions of acquire

Cancels an ongoing attempt to acquire.

@param node the node"
      end

      operation 1655451 "shouldParkAfterFailedAcquire"
	class_operation private explicit_return_type "boolean"
	nparams 2
	  param inout name "pred" type class_ref 274971 // Node
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Checks and updates status for a node that failed to acquire.
Returns true if thread should block. This is the main signal
control in all acquire loops.  Requires that pred == node.prev

@param pred node's predecessor holding status
@param node the node
@return {@code true} if thread should block"
      end

      operation 1655579 "selfInterrupt"
	class_operation package explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to interrupt current thread."
      end

      operation 1655707 "parkAndCheckInterrupt"
	private explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to park and then check if interrupted

@return {@code true} if interrupted"
      end

      operation 1655835 "acquireQueued"
	package explicit_return_type "boolean"
	nparams 2
	  param in name "node" type class_ref 274971 // Node
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Various flavors of acquire, varying in exclusive/shared and
control modes.  Each is mostly the same, but annoyingly
different.  Only a little bit of factoring is possible due to
interactions of exception mechanics (including ensuring that we
cancel if tryAcquire throws exception) and other control, at
least not without hurting performance too much.


Acquires in exclusive uninterruptible mode for thread already in
queue. Used by condition wait methods as well as acquire.

@param node the node
@param arg the acquire argument
@return {@code true} if interrupted while waiting"
      end

      operation 1655963 "doAcquireInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive interruptible mode.
@param arg the acquire argument"
      end

      operation 1656091 "doAcquireNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired"
      end

      operation 1656219 "doAcquireShared"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared uninterruptible mode.
@param arg the acquire argument"
      end

      operation 1656347 "doAcquireSharedInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared interruptible mode.
@param arg the acquire argument"
      end

      operation 1656475 "doAcquireSharedNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired"
      end

      operation 1656603 "tryAcquire"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Main exported methods

Attempts to acquire in exclusive mode. This method should query
if the state of the object permits it to be acquired in the
exclusive mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread. This can be used
to implement method {@link Lock#tryLock()}.

<p>The default
implementation throws {@link UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return {@code true} if successful. Upon success, this object has
        been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 1656731 "tryRelease"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in exclusive
mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this object is now in a fully released
        state, so that any waiting threads may attempt to acquire;
        and {@code false} otherwise.
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 1656859 "tryAcquireShared"
	protected explicit_return_type "long"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode. This method should query if
the state of the object permits it to be acquired in the shared
mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread.

<p>The default implementation throws {@link
UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return a negative value on failure; zero if acquisition in shared
        mode succeeded but no subsequent shared-mode acquire can
        succeed; and a positive value if acquisition in shared
        mode succeeded and subsequent shared-mode acquires might
        also succeed, in which case a subsequent waiting thread
        must check availability. (Support for three different
        return values enables this method to be used in contexts
        where acquires only sometimes act exclusively.)  Upon
        success, this object has been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 1656987 "tryReleaseShared"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in shared mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this release of shared mode may permit a
        waiting acquire (shared or exclusive) to succeed; and
        {@code false} otherwise
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 1657115 "isHeldExclusively"
	protected explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if synchronization is held exclusively with
respect to the current (calling) thread.  This method is invoked
upon each call to a non-waiting {@link ConditionObject} method.
(Waiting methods instead invoke {@link #release}.)

<p>The default implementation throws {@link
UnsupportedOperationException}. This method is invoked
internally only within {@link ConditionObject} methods, so need
not be defined if conditions are not used.

@return {@code true} if synchronization is held exclusively;
        {@code false} otherwise
@throws UnsupportedOperationException if conditions are not supported"
      end

      operation 1657243 "acquire"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, ignoring interrupts.  Implemented
by invoking at least once {@link #tryAcquire},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquire} until success.  This method can be used
to implement method {@link Lock#lock}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like."
      end

      operation 1657371 "acquireInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, aborting if interrupted.
Implemented by first checking interrupt status, then invoking
at least once {@link #tryAcquire}, returning on
success.  Otherwise the thread is queued, possibly repeatedly
blocking and unblocking, invoking {@link #tryAcquire}
until success or the thread is interrupted.  This method can be
used to implement method {@link Lock#lockInterruptibly}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1657499 "tryAcquireNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in exclusive mode, aborting if interrupted,
and failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquire}, returning on success.  Otherwise, the thread is
queued, possibly repeatedly blocking and unblocking, invoking
{@link #tryAcquire} until success or the thread is interrupted
or the timeout elapses.  This method can be used to implement
method {@link Lock#tryLock(long, TimeUnit)}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1657627 "release"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in exclusive mode.  Implemented by unblocking one or
more threads if {@link #tryRelease} returns true.
This method can be used to implement method {@link Lock#unlock}.

@param arg the release argument.  This value is conveyed to
       {@link #tryRelease} but is otherwise uninterpreted and
       can represent anything you like.
@return the value returned from {@link #tryRelease}"
      end

      operation 1657755 "acquireShared"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, ignoring interrupts.  Implemented by
first invoking at least once {@link #tryAcquireShared},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquireShared} until success.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like."
      end

      operation 1657883 "acquireSharedInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, aborting if interrupted.  Implemented
by first checking interrupt status, then invoking at least once
{@link #tryAcquireShared}, returning on success.  Otherwise the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted.
@param arg the acquire argument
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1658011 "tryAcquireSharedNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 155547 // InterruptedException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode, aborting if interrupted, and
failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquireShared}, returning on success.  Otherwise, the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted or the timeout elapses.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 1658139 "releaseShared"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in shared mode.  Implemented by unblocking one or more
threads if {@link #tryReleaseShared} returns true.

@param arg the release argument.  This value is conveyed to
       {@link #tryReleaseShared} but is otherwise uninterpreted
       and can represent anything you like.
@return the value returned from {@link #tryReleaseShared}"
      end

      operation 1658267 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queue inspection methods

Queries whether any threads are waiting to acquire. Note that
because cancellations due to interrupts and timeouts may occur
at any time, a {@code true} return does not guarantee that any
other thread will ever acquire.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there may be other threads waiting to acquire"
      end

      operation 1658395 "hasContended"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have ever contended to acquire this
synchronizer; that is if an acquire method has ever blocked.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there has ever been contention"
      end

      operation 1658523 "getFirstQueuedThread"
	public return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the first (longest-waiting) thread in the queue, or
{@code null} if no threads are currently queued.

<p>In this implementation, this operation normally returns in
constant time, but may iterate upon contention if other threads are
concurrently modifying the queue.

@return the first (longest-waiting) thread in the queue, or
        {@code null} if no threads are currently queued"
      end

      operation 1658651 "fullGetFirstQueuedThread"
	private return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Version of getFirstQueuedThread called when fastpath fails"
      end

      operation 1658779 "isQueued"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the given thread is currently queued.

<p>This implementation traverses the queue to determine
presence of the given thread.

@param thread the thread
@return {@code true} if the given thread is on the queue
@throws NullPointerException if the thread is null"
      end

      operation 1658907 "apparentlyFirstQueuedIsExclusive"
	package explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the apparent first queued thread, if one
exists, is waiting in exclusive mode.  If this method returns
{@code true}, and the current thread is attempting to acquire in
shared mode (that is, this method is invoked from {@link
#tryAcquireShared}) then it is guaranteed that the current thread
is not the first queued thread.  Used only as a heuristic in
ReentrantReadWriteLock."
      end

      operation 1659035 "hasQueuedPredecessors"
	package explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have been waiting to acquire longer
than the current thread.

<p>An invocation of this method is equivalent to (but may be
more efficient than):
 <pre> {@code
getFirstQueuedThread() != Thread.currentThread() &&
hasQueuedThreads()}</pre>

<p>Note that because cancellations due to interrupts and
timeouts may occur at any time, a {@code true} return does not
guarantee that some other thread will acquire before the current
thread.  Likewise, it is possible for another thread to win a
race to enqueue after this method has returned {@code false},
due to the queue being empty.

<p>This method is designed to be used by a fair synchronizer to
avoid <a href=\"AbstractQueuedSynchronizer.html#barging\">barging</a>.
Such a synchronizer's {@link #tryAcquire} method should return
{@code false}, and its {@link #tryAcquireShared} method should
return a negative value, if this method returns {@code true}
(unless this is a reentrant acquire).  For example, the {@code
tryAcquire} method for a fair, reentrant, exclusive mode
synchronizer might look like this:

 <pre> {@code
protected boolean tryAcquire(int arg) {
  if (isHeldExclusively()) {
    // A reentrant acquire; increment hold count
    return true;
  } else if (hasQueuedPredecessors()) {
    return false;
  } else {
    // try to acquire normally
  }
}}</pre>

@return {@code true} if there is a queued thread preceding the
        current thread, and {@code false} if the current thread
        is at the head of the queue or the queue is empty
@since 1.7

public"
      end

      operation 1659163 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and monitoring methods

Returns an estimate of the number of threads waiting to
acquire.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring system state, not for synchronization
control.

@return the estimated number of threads waiting to acquire"
      end

      operation 1659291 "getQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads"
      end

      operation 1659419 "getExclusiveQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in exclusive mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to an exclusive acquire.

@return the collection of threads"
      end

      operation 1659547 "getSharedQueuedThreads"
	public return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in shared mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to a shared acquire.

@return the collection of threads"
      end

      operation 1659675 "toString"
	public return_type class_ref 3399692 // String
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this synchronizer, as well as its state.
The state, in brackets, includes the String {@code \"State =\"}
followed by the current value of {@link #getState}, and either
{@code \"nonempty\"} or {@code \"empty\"} depending on whether the
queue is empty.

@return a string identifying this synchronizer, as well as its state"
      end

      operation 1659803 "isOnSyncQueue"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal support methods for Conditions

Returns true if a node, always one that was initially placed on
a condition queue, is now waiting to reacquire on sync queue.
@param node the node
@return true if is reacquiring"
      end

      operation 1659931 "findNodeFromTail"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if node is on sync queue by searching backwards from tail.
Called only when needed by isOnSyncQueue.
@return true if present"
      end

      operation 1660059 "transferForSignal"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers a node from a condition queue onto sync queue.
Returns true if successful.
@param node the node
@return true if successfully transferred (else the node was
cancelled before signal)."
      end

      operation 1660187 "transferAfterCancelledWait"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers node, if necessary, to sync queue after a cancelled
wait. Returns true if thread was cancelled before being
signalled.
@param node its node
@return true if cancelled before the node was signalled"
      end

      operation 1660315 "fullyRelease"
	package explicit_return_type "long"
	nparams 1
	  param inout name "node" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invokes release with current state value; returns saved state.
Cancels node and throws exception on failure.
@param node the condition node for this wait
@return previous sync state"
      end

      operation 1660443 "owns"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 275099 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation methods for conditions

Queries whether the given ConditionObject
uses this synchronizer as its lock.

@param condition the condition
@return <tt>true</tt> if owned
@throws NullPointerException if the condition is null"
      end

      class 275099 "ConditionObject"
	visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 469787 // <realization>
	  relation 469787 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 469787 // <realization>
	    b parent class_ref 254363 // Condition
	end

	classrelation 469915 // <realization>
	  relation 469915 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 469915 // <realization>
	    b parent class_ref 128155 // Serializable
	end

	attribute 405275 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 1173984872572414699L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 470043 // firstWaiter (<unidirectional association>)
	  relation 470043 --->
	    a role_name "firstWaiter" private
	      comment " First node of condition queue. 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 470043 // firstWaiter (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	classrelation 470171 // lastWaiter (<unidirectional association>)
	  relation 470171 --->
	    a role_name "lastWaiter" private
	      comment " Last node of condition queue. 
"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 470171 // lastWaiter (<unidirectional association>)
	    b parent class_ref 274971 // Node
	end

	operation 1660955 "ConditionObject"
	  public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Creates a new <tt>ConditionObject</tt> instance."
	end

	operation 1661083 "addConditionWaiter"
	  private return_type class_ref 274971 // Node
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Internal methods

Adds a new waiter to wait queue.
@return its new wait node"
	end

	operation 1661211 "doSignal"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 274971 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers nodes until hit non-cancelled one or
null. Split out from signal in part to encourage compilers
to inline the case of no waiters.
@param first (non-null) the first node on condition queue"
	end

	operation 1661339 "doSignalAll"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 274971 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers all nodes.
@param first (non-null) the first node on condition queue"
	end

	operation 1661467 "unlinkCancelledWaiters"
	  private explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Unlinks cancelled waiter nodes from condition queue.
Called only while holding lock. This is called when
cancellation occurred during condition wait, and upon
insertion of a new waiter when lastWaiter is seen to have
been cancelled. This method is needed to avoid garbage
retention in the absence of signals. So even though it may
require a full traversal, it comes into play only when
timeouts or cancellations occur in the absence of
signals. It traverses all nodes rather than stopping at a
particular target to unlink all pointers to garbage nodes
without requiring many re-traversals during cancellation
storms."
	end

	operation 1661595 "signal"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " public methods

Moves the longest-waiting thread, if one exists, from the
wait queue for this condition to the wait queue for the
owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1661723 "signalAll"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Moves all threads from the wait queue for this condition to
the wait queue for the owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1661851 "awaitUninterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements uninterruptible condition wait.
<ol>
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
</ol>"
	end

	attribute 405403 "REINTERRUPT"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "  1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "For interruptible waits, we need to track whether to throw
InterruptedException, if interrupted while blocked on
condition, versus reinterrupt current thread, if
interrupted while blocked waiting to re-acquire.

 Mode meaning to reinterrupt on exit from wait "
	end

	attribute 405531 "THROW_IE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " -1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " Mode meaning to throw InterruptedException on exit from wait "
	end

	operation 1661979 "checkInterruptWhileWaiting"
	  private explicit_return_type "int"
	  nparams 1
	    param inout name "node" type class_ref 274971 // Node
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Checks for interrupt, returning THROW_IE if interrupted
before signalled, REINTERRUPT if after signalled, or
0 if not interrupted."
	end

	operation 1662107 "reportInterruptAfterWait"
	  private explicit_return_type "void"
	  nparams 1
	    param in name "interruptMode" explicit_type "int"
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws InterruptedException, reinterrupts current thread, or
does nothing, depending on mode."
	end

	operation 1662235 "await"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements interruptible condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled or interrupted.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>"
	end

	operation 1662363 "awaitNanos"
	  public explicit_return_type "long"
	  nparams 1
	    param in name "nanosTimeout" explicit_type "long"
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>"
	end

	operation 1662491 "awaitUntil"
	  public explicit_return_type "boolean"
	  nparams 1
	    param inout name "deadline" type class_ref 171931 // Date
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements absolute timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>"
	end

	operation 1662619 "await"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 253211 // TimeUnit
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with
     saved state as argument, throwing
     IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>"
	end

	operation 1662747 "isOwnedBy"
	  package explicit_return_type "boolean"
	  nparams 1
	    param inout name "sync" type class_ref 274843 // AbstractQueuedLongSynchronizer
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "  support for instrumentation

Returns true if this condition was created by the given
synchronization object.

@return {@code true} if owned"
	end

	operation 1662875 "hasWaiters"
	  protected explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries whether any threads are waiting on this condition.
Implements {@link AbstractQueuedLongSynchronizer#hasWaiters}.

@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1663003 "getWaitQueueLength"
	  protected explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an estimate of the number of threads waiting on
this condition.
Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength}.

@return the estimated number of waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end

	operation 1663131 "getWaitingThreads"
	  protected return_type class_ref 160667 // Collection
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a collection containing those threads that may be
waiting on this Condition.
Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads}.

@return the collection of threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}"
	end
      end

      operation 1660571 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 275099 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this synchronizer. Note that because timeouts
and interrupts may occur at any time, a <tt>true</tt> return
does not guarantee that a future <tt>signal</tt> will awaken
any threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return <tt>true</tt> if there are any waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      operation 1660699 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 275099 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this synchronizer. Note that
because timeouts and interrupts may occur at any time, the
estimate serves only as an upper bound on the actual number of
waiters.  This method is designed for use in monitoring of the
system state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      operation 1660827 "getWaitingThreads"
	public return_type class_ref 160667 // Collection
	nparams 1
	  param inout name "condition" type class_ref 275099 // ConditionObject
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this
synchronizer.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate. The elements of the
returned collection are in no particular order.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null"
      end

      classrelation 470299 // unsafe (<unidirectional association>)
	relation 470299 --->
	  a role_name "unsafe" init_value " Unsafe.getUnsafe()" class_relation const_relation private
	    comment "
Setup to support compareAndSet. We need to natively implement
this here: For the sake of permitting future enhancements, we
cannot explicitly subclass AtomicLong, which would be
efficient and useful otherwise. So, as the lesser of evils, we
natively implement using hotspot intrinsics API. And while we
are at it, we do the same for other CASable fields (which could
otherwise be done with atomic field updaters).

"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 470299 // unsafe (<unidirectional association>)
	  b parent class_ref 255899 // Unsafe
      end

      attribute 405659 "stateOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 405787 "headOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 405915 "tailOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 406043 "waitStatusOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 406171 "nextOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      extra_member 134939 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"state\"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"head\"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"tail\"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"waitStatus\"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"next\"));

        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
      end

      operation 1663259 "compareAndSetHead"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "update" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS head field. Used only by enq."
      end

      operation 1663387 "compareAndSetTail"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "expect" type class_ref 274971 // Node
	  param inout name "update" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS tail field. Used only by enq."
      end

      operation 1663515 "compareAndSetWaitStatus"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 274971 // Node
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS waitStatus field of a node."
      end

      operation 1663643 "compareAndSetNext"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 274971 // Node
	  param inout name "expect" type class_ref 274971 // Node
	  param inout name "update" type class_ref 274971 // Node
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS next field of a node."
      end
    end

    class 275227 "LockSupport"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "Basic thread blocking primitives for creating locks and other
synchronization classes.

<p>This class associates, with each thread that uses it, a permit
(in the sense of the {@link java.util.concurrent.Semaphore
Semaphore} class). A call to {@code park} will return immediately
if the permit is available, consuming it in the process; otherwise
it <em>may</em> block.  A call to {@code unpark} makes the permit
available, if it was not already available. (Unlike with Semaphores
though, permits do not accumulate. There is at most one.)

<p>Methods {@code park} and {@code unpark} provide efficient
means of blocking and unblocking threads that do not encounter the
problems that cause the deprecated methods {@code Thread.suspend}
and {@code Thread.resume} to be unusable for such purposes: Races
between one thread invoking {@code park} and another thread trying
to {@code unpark} it will preserve liveness, due to the
permit. Additionally, {@code park} will return if the caller's
thread was interrupted, and timeout versions are supported. The
{@code park} method may also return at any other time, for \"no
reason\", so in general must be invoked within a loop that rechecks
conditions upon return. In this sense {@code park} serves as an
optimization of a \"busy wait\" that does not waste as much time
spinning, but must be paired with an {@code unpark} to be
effective.

<p>The three forms of {@code park} each also support a
{@code blocker} object parameter. This object is recorded while
the thread is blocked to permit monitoring and diagnostic tools to
identify the reasons that threads are blocked. (Such tools may
access blockers using method {@link #getBlocker}.) The use of these
forms rather than the original forms without this parameter is
strongly encouraged. The normal argument to supply as a
{@code blocker} within a lock implementation is {@code this}.

<p>These methods are designed to be used as tools for creating
higher-level synchronization utilities, and are not in themselves
useful for most concurrency control applications.  The {@code park}
method is designed for use only in constructions of the form:

 <pre> {@code
while (!canProceed()) { ... LockSupport.park(this); }}</pre>

where neither {@code canProceed} nor any other actions prior to the
call to {@code park} entail locking or blocking.  Because only one
permit is associated with each thread, any intermediary uses of
{@code park} could interfere with its intended effects.

<p><b>Sample Usage.</b> Here is a sketch of a first-in-first-out
non-reentrant lock class:
 <pre> {@code
class FIFOMutex {
  private final AtomicBoolean locked = new AtomicBoolean(false);
  private final Queue<Thread> waiters
    = new ConcurrentLinkedQueue<Thread>();

  public void lock() {
    boolean wasInterrupted = false;
    Thread current = Thread.currentThread();
    waiters.add(current);

    // Block while not first in queue or cannot acquire lock
    while (waiters.peek() != current ||
           !locked.compareAndSet(false, true)) {
       LockSupport.park(this);
       if (Thread.interrupted()) // ignore interrupts while waiting
         wasInterrupted = true;
    }

    waiters.remove();
    if (wasInterrupted)          // reassert interrupt status on exit
       current.interrupt();
  }

  public void unlock() {
    locked.set(false);
    LockSupport.unpark(waiters.peek());
  }
}}</pre>"
      operation 1663771 "LockSupport"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      classrelation 470427 // unsafe (<unidirectional association>)
	relation 470427 --->
	  a role_name "unsafe" init_value " Unsafe.getUnsafe()" class_relation const_relation private
	    comment " Cannot be instantiated.
 Hotspot implementation via intrinsics API
"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 470427 // unsafe (<unidirectional association>)
	  b parent class_ref 255899 // Unsafe
      end

      attribute 406299 "parkBlockerOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      extra_member 135067 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            parkBlockerOffset = unsafe.objectFieldOffset
                (java.lang.Thread.class.getDeclaredField(\"parkBlocker\"));
        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
      end

      operation 1663899 "setBlocker"
	class_operation private explicit_return_type "void"
	nparams 2
	  param inout name "t" type class_ref 1201420 // Thread
	  param inout name "arg" type class_ref 3401484 // Object
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 1664027 "unpark"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "thread" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Makes available the permit for the given thread, if it
was not already available.  If the thread was blocked on
{@code park} then it will unblock.  Otherwise, its next call
to {@code park} is guaranteed not to block. This operation
is not guaranteed to have any effect at all if the given
thread has not been started.

@param thread the thread to unpark, or {@code null}, in which case
       this operation has no effect"
      end

      operation 1664155 "park"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "blocker" type class_ref 3401484 // Object
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes unless the
permit is available.

<p>If the permit is available then it is consumed and the call returns
immediately; otherwise
the current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread upon return.

@param blocker the synchronization object responsible for this
       thread parking
@since 1.6"
      end

      operation 1664283 "parkNanos"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "blocker" type class_ref 3401484 // Object
	  param in name "nanos" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, for up to
the specified waiting time, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the elapsed time
upon return.

@param blocker the synchronization object responsible for this
       thread parking
@param nanos the maximum number of nanoseconds to wait
@since 1.6"
      end

      operation 1664411 "parkUntil"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "blocker" type class_ref 3401484 // Object
	  param in name "deadline" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, until
the specified deadline, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread; or

<li>The specified deadline passes; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the current time
upon return.

@param blocker the synchronization object responsible for this
       thread parking
@param deadline the absolute time, in milliseconds from the Epoch,
       to wait until
@since 1.6"
      end

      operation 1664539 "getBlocker"
	class_operation public return_type class_ref 3401484 // Object
	nparams 1
	  param inout name "t" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the blocker object supplied to the most recent
invocation of a park method that has not yet unblocked, or null
if not blocked.  The value returned is just a momentary
snapshot -- the thread may have since unblocked or blocked on a
different blocker object.

@param t the thread
@return the blocker
@throws NullPointerException if argument is null
@since 1.6"
      end

      operation 1664667 "park"
	class_operation public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes unless the
permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of three
things happens:

<ul>

<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread upon return."
      end

      operation 1664795 "parkNanos"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "nanos" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, for up to
the specified waiting time, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the elapsed time
upon return.

@param nanos the maximum number of nanoseconds to wait"
      end

      operation 1664923 "parkUntil"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "deadline" explicit_type "long"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, until
the specified deadline, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified deadline passes; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the current time
upon return.

@param deadline the absolute time, in milliseconds from the Epoch,
       to wait until"
      end
    end

    class 275355 "ReadWriteLock"
      visibility public stereotype "interface"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A <tt>ReadWriteLock</tt> maintains a pair of associated {@link
Lock locks}, one for read-only operations and one for writing.
The {@link #readLock read lock} may be held simultaneously by
multiple reader threads, so long as there are no writers.  The
{@link #writeLock write lock} is exclusive.

<p>All <tt>ReadWriteLock</tt> implementations must guarantee that
the memory synchronization effects of <tt>writeLock</tt> operations
(as specified in the {@link Lock} interface) also hold with respect
to the associated <tt>readLock</tt>. That is, a thread successfully
acquiring the read lock will see all updates made upon previous
release of the write lock.

<p>A read-write lock allows for a greater level of concurrency in
accessing shared data than that permitted by a mutual exclusion lock.
It exploits the fact that while only a single thread at a time (a
<em>writer</em> thread) can modify the shared data, in many cases any
number of threads can concurrently read the data (hence <em>reader</em>
threads).
In theory, the increase in concurrency permitted by the use of a read-write
lock will lead to performance improvements over the use of a mutual
exclusion lock. In practice this increase in concurrency will only be fully
realized on a multi-processor, and then only if the access patterns for
the shared data are suitable.

<p>Whether or not a read-write lock will improve performance over the use
of a mutual exclusion lock depends on the frequency that the data is
read compared to being modified, the duration of the read and write
operations, and the contention for the data - that is, the number of
threads that will try to read or write the data at the same time.
For example, a collection that is initially populated with data and
thereafter infrequently modified, while being frequently searched
(such as a directory of some kind) is an ideal candidate for the use of
a read-write lock. However, if updates become frequent then the data
spends most of its time being exclusively locked and there is little, if any
increase in concurrency. Further, if the read operations are too short
the overhead of the read-write lock implementation (which is inherently
more complex than a mutual exclusion lock) can dominate the execution
cost, particularly as many read-write lock implementations still serialize
all threads through a small section of code. Ultimately, only profiling
and measurement will establish whether the use of a read-write lock is
suitable for your application.


<p>Although the basic operation of a read-write lock is straight-forward,
there are many policy decisions that an implementation must make, which
may affect the effectiveness of the read-write lock in a given application.
Examples of these policies include:
<ul>
<li>Determining whether to grant the read lock or the write lock, when
both readers and writers are waiting, at the time that a writer releases
the write lock. Writer preference is common, as writes are expected to be
short and infrequent. Reader preference is less common as it can lead to
lengthy delays for a write if the readers are frequent and long-lived as
expected. Fair, or &quot;in-order&quot; implementations are also possible.

<li>Determining whether readers that request the read lock while a
reader is active and a writer is waiting, are granted the read lock.
Preference to the reader can delay the writer indefinitely, while
preference to the writer can reduce the potential for concurrency.

<li>Determining whether the locks are reentrant: can a thread with the
write lock reacquire it? Can it acquire a read lock while holding the
write lock? Is the read lock itself reentrant?

<li>Can the write lock be downgraded to a read lock without allowing
an intervening writer? Can a read lock be upgraded to a write lock,
in preference to other waiting readers or writers?

</ul>
You should consider all of these things when evaluating the suitability
of a given implementation for your application.

@see ReentrantReadWriteLock
@see Lock
@see ReentrantLock

@since 1.5
@author Doug Lea"
      operation 1665051 "readLock"
	public return_type class_ref 256027 // Lock
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for reading.

@return the lock used for reading."
      end

      operation 1665179 "writeLock"
	public return_type class_ref 256027 // Lock
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for writing.

@return the lock used for writing."
      end
    end

    class 275483 "ReentrantReadWriteLock"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "An implementation of {@link ReadWriteLock} supporting similar
semantics to {@link ReentrantLock}.
<p>This class has the following properties:

<ul>
<li><b>Acquisition order</b>

<p> This class does not impose a reader or writer preference
ordering for lock access.  However, it does support an optional
<em>fairness</em> policy.

<dl>
<dt><b><i>Non-fair mode (default)</i></b>
<dd>When constructed as non-fair (the default), the order of entry
to the read and write lock is unspecified, subject to reentrancy
constraints.  A nonfair lock that is continuously contended may
indefinitely postpone one or more reader or writer threads, but
will normally have higher throughput than a fair lock.
<p>

<dt><b><i>Fair mode</i></b>
<dd> When constructed as fair, threads contend for entry using an
approximately arrival-order policy. When the currently held lock
is released, either the longest-waiting single writer thread will
be assigned the write lock, or if there is a group of reader threads
waiting longer than all waiting writer threads, that group will be
assigned the read lock.

<p>A thread that tries to acquire a fair read lock (non-reentrantly)
will block if either the write lock is held, or there is a waiting
writer thread. The thread will not acquire the read lock until
after the oldest currently waiting writer thread has acquired and
released the write lock. Of course, if a waiting writer abandons
its wait, leaving one or more reader threads as the longest waiters
in the queue with the write lock free, then those readers will be
assigned the read lock.

<p>A thread that tries to acquire a fair write lock (non-reentrantly)
will block unless both the read lock and write lock are free (which
implies there are no waiting threads).  (Note that the non-blocking
{@link ReadLock#tryLock()} and {@link WriteLock#tryLock()} methods
do not honor this fair setting and will immediately acquire the lock
if it is possible, regardless of waiting threads.)
<p>
</dl>

<li><b>Reentrancy</b>

<p>This lock allows both readers and writers to reacquire read or
write locks in the style of a {@link ReentrantLock}. Non-reentrant
readers are not allowed until all write locks held by the writing
thread have been released.

<p>Additionally, a writer can acquire the read lock, but not
vice-versa.  Among other applications, reentrancy can be useful
when write locks are held during calls or callbacks to methods that
perform reads under read locks.  If a reader tries to acquire the
write lock it will never succeed.

<li><b>Lock downgrading</b>
<p>Reentrancy also allows downgrading from the write lock to a read lock,
by acquiring the write lock, then the read lock and then releasing the
write lock. However, upgrading from a read lock to the write lock is
<b>not</b> possible.

<li><b>Interruption of lock acquisition</b>
<p>The read lock and write lock both support interruption during lock
acquisition.

<li><b>{@link Condition} support</b>
<p>The write lock provides a {@link Condition} implementation that
behaves in the same way, with respect to the write lock, as the
{@link Condition} implementation provided by
{@link ReentrantLock#newCondition} does for {@link ReentrantLock}.
This {@link Condition} can, of course, only be used with the write lock.

<p>The read lock does not support a {@link Condition} and
{@code readLock().newCondition()} throws
{@code UnsupportedOperationException}.

<li><b>Instrumentation</b>
<p>This class supports methods to determine whether locks
are held or contended. These methods are designed for monitoring
system state, not for synchronization control.
</ul>

<p>Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p><b>Sample usages</b>. Here is a code sketch showing how to perform
lock downgrading after updating a cache (exception handling is
particularly tricky when handling multiple locks in a non-nested
fashion):

<pre> {@code
class CachedData {
  Object data;
  volatile boolean cacheValid;
  final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

  void processCachedData() {
    rwl.readLock().lock();
    if (!cacheValid) {
      // Must release read lock before acquiring write lock
      rwl.readLock().unlock();
      rwl.writeLock().lock();
      try {
        // Recheck state because another thread might have
        // acquired write lock and changed state before we did.
        if (!cacheValid) {
          data = ...
          cacheValid = true;
        }
        // Downgrade by acquiring read lock before releasing write lock
        rwl.readLock().lock();
      } finally {
        rwl.writeLock().unlock(); // Unlock write, still hold read
      }
    }

    try {
      use(data);
    } finally {
      rwl.readLock().unlock();
    }
  }
}}</pre>

ReentrantReadWriteLocks can be used to improve concurrency in some
uses of some kinds of Collections. This is typically worthwhile
only when the collections are expected to be large, accessed by
more reader threads than writer threads, and entail operations with
overhead that outweighs synchronization overhead. For example, here
is a class using a TreeMap that is expected to be large and
concurrently accessed.

 <pre> {@code
class RWDictionary {
  private final Map<String, Data> m = new TreeMap<String, Data>();
  private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
  private final Lock r = rwl.readLock();
  private final Lock w = rwl.writeLock();

  public Data get(String key) {
    r.lock();
    try { return m.get(key); }
    finally { r.unlock(); }
  }
  public String[] allKeys() {
    r.lock();
    try { return m.keySet().toArray(); }
    finally { r.unlock(); }
  }
  public Data put(String key, Data value) {
    w.lock();
    try { return m.put(key, value); }
    finally { w.unlock(); }
  }
  public void clear() {
    w.lock();
    try { m.clear(); }
    finally { w.unlock(); }
  }
}}</pre>

<h3>Implementation Notes</h3>

<p>This lock supports a maximum of 65535 recursive write locks
and 65535 read locks. Attempts to exceed these limits result in
{@link Error} throws from locking methods.

@since 1.5
@author Doug Lea
"
      classrelation 470555 // <realization>
	relation 470555 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 470555 // <realization>
	  b parent class_ref 275355 // ReadWriteLock
      end

      classrelation 470683 // <realization>
	relation 470683 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 470683 // <realization>
	  b parent class_ref 128155 // Serializable
      end

      attribute 406427 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -6992448646407690164L"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      class 275611 "ReadLock"
	visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 472091 // <realization>
	  relation 472091 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 472091 // <realization>
	    b parent class_ref 256027 // Lock
	end

	classrelation 472219 // <realization>
	  relation 472219 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 472219 // <realization>
	    b parent class_ref 128155 // Serializable
	end

	attribute 407835 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -5992448646407690164L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 472347 // sync (<unidirectional association>)
	  relation 472347 --->
	    a role_name "sync" const_relation private
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 472347 // sync (<unidirectional association>)
	    b parent class_ref 275867 // Sync
	end

	operation 1669275 "ReadLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 275483 // ReentrantReadWriteLock
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses

@param lock the outer lock object
@throws NullPointerException if the lock is null"
	end

	operation 1669403 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately.

<p>If the write lock is held by another thread then
the current thread becomes disabled for thread scheduling
purposes and lies dormant until the read lock has been acquired."
	end

	operation 1669531 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the read lock if the write lock is not held
by another thread and returns immediately.

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of two things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the read lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted"
	end

	operation 1669659 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock only if the write lock is not held by
another thread at the time of invocation.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
{@code true}. Even when this lock has been set to use a
fair ordering policy, a call to {@code tryLock()}
<em>will</em> immediately acquire the read lock if it is
available, whether or not other threads are currently
waiting for the read lock.  This &quot;barging&quot; behavior
can be useful in certain circumstances, even though it
breaks fairness. If you want to honor the fairness setting
for this lock, then use {@link #tryLock(long, TimeUnit)
tryLock(0, TimeUnit.SECONDS) } which is almost equivalent
(it also detects interruption).

<p>If the write lock is held by another thread then
this method will return immediately with the value
{@code false}.

@return {@code true} if the read lock was acquired"
	end

	operation 1669787 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 253211 // TimeUnit
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock if the write lock is not held by
another thread within the given waiting time and the
current thread has not been {@linkplain Thread#interrupt
interrupted}.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
{@code true}. If this lock has been set to use a fair
ordering policy then an available lock <em>will not</em> be
acquired if any other threads are waiting for the
lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed {@code tryLock} that does
permit barging on a fair lock then combine the timed and
un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses.

</ul>

<p>If the read lock is acquired then the value {@code true} is
returned.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the read lock,

</ul> then {@link InterruptedException} is thrown and the
current thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
{@code false} is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the read lock
@param unit the time unit of the timeout argument
@return {@code true} if the read lock was acquired
@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
	end

	operation 1669915 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.

<p> If the number of readers is now zero then the lock
is made available for write lock attempts."
	end

	operation 1670043 "newCondition"
	  public return_type class_ref 254363 // Condition
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws {@code UnsupportedOperationException} because
{@code ReadLocks} do not support conditions.

@throws UnsupportedOperationException always"
	end

	operation 1670171 "toString"
	  public return_type class_ref 3399692 // String
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String {@code \"Read locks =\"}
followed by the number of held read locks.

@return a string identifying this lock, as well as its lock state"
	end
      end

      classrelation 470811 // readerLock (<unidirectional association>)
	relation 470811 --->
	  a role_name "readerLock" const_relation private
	    comment " Inner class providing readlock 
"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 470811 // readerLock (<unidirectional association>)
	  b parent class_ref 275611 // ReadLock
      end

      class 275739 "WriteLock"
	visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 472475 // <realization>
	  relation 472475 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 472475 // <realization>
	    b parent class_ref 256027 // Lock
	end

	classrelation 472603 // <realization>
	  relation 472603 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 472603 // <realization>
	    b parent class_ref 128155 // Serializable
	end

	attribute 407963 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -4992448646407690164L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 472731 // sync (<unidirectional association>)
	  relation 472731 --->
	    a role_name "sync" const_relation private
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 472731 // sync (<unidirectional association>)
	    b parent class_ref 275867 // Sync
	end

	operation 1670299 "WriteLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 275483 // ReentrantReadWriteLock
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses

@param lock the outer lock object
@throws NullPointerException if the lock is null"
	end

	operation 1670427 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds the write lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until the write lock has been acquired, at which
time the write lock hold count is set to one."
	end

	operation 1670555 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of two things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the write lock is acquired by the current thread then the
lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the write lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted"
	end

	operation 1670683 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock only if it is not held by another thread
at the time of invocation.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value {@code true},
setting the write lock hold count to one. Even when this lock has
been set to use a fair ordering policy, a call to
{@code tryLock()} <em>will</em> immediately acquire the
lock if it is available, whether or not other threads are
currently waiting for the write lock.  This &quot;barging&quot;
behavior can be useful in certain circumstances, even
though it breaks fairness. If you want to honor the
fairness setting for this lock, then use {@link
#tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p> If the current thread already holds this lock then the
hold count is incremented by one and the method returns
{@code true}.

<p>If the lock is held by another thread then this method
will return immediately with the value {@code false}.

@return {@code true} if the lock was free and was acquired
by the current thread, or the write lock was already held
by the current thread; and {@code false} otherwise."
	end

	operation 1670811 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 253211 // TimeUnit
	  nexceptions 1
	    exception class_ref 155547 // InterruptedException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock if it is not held by another thread
within the given waiting time and the current thread has
not been {@linkplain Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value {@code true},
setting the write lock hold count to one. If this lock has been
set to use a fair ordering policy then an available lock
<em>will not</em> be acquired if any other threads are
waiting for the write lock. This is in contrast to the {@link
#tryLock()} method. If you want a timed {@code tryLock}
that does permit barging on a fair lock then combine the
timed and un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
{@code true}.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of three things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses

</ul>

<p>If the write lock is acquired then the value {@code true} is
returned and the write lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the write lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
{@code false} is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the write lock
@param unit the time unit of the timeout argument

@return {@code true} if the lock was free and was acquired
by the current thread, or the write lock was already held by the
current thread; and {@code false} if the waiting time
elapsed before the lock could be acquired.

@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
	end

	operation 1670939 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.

<p>If the current thread is the holder of this lock then
the hold count is decremented. If the hold count is now
zero then the lock is released.  If the current thread is
not the holder of this lock then {@link
IllegalMonitorStateException} is thrown.

@throws IllegalMonitorStateException if the current thread does not
hold this lock."
	end

	operation 1671067 "newCondition"
	  public return_type class_ref 254363 // Condition
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a {@link Condition} instance for use with this
{@link Lock} instance.
<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this write lock is not held when any {@link
Condition} method is called then an {@link
IllegalMonitorStateException} is thrown.  (Read locks are
held independently of write locks, so are not checked or
affected. However it is essentially always an error to
invoke a condition waiting method when the current thread
has also acquired read locks, since other threads that
could unblock it will not be able to acquire the write
lock.)

<li>When the condition {@linkplain Condition#await() waiting}
methods are called the write lock is released and, before
they return, the write lock is reacquired and the lock hold
count restored to what it was when the method was called.

<li>If a thread is {@linkplain Thread#interrupt interrupted} while
waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order.

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>

@return the Condition object"
	end

	operation 1671195 "toString"
	  public return_type class_ref 3399692 // String
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock
state.  The state, in brackets includes either the String
{@code \"Unlocked\"} or the String {@code \"Locked by\"}
followed by the {@linkplain Thread#getName name} of the owning thread.

@return a string identifying this lock, as well as its lock state"
	end

	operation 1671323 "isHeldByCurrentThread"
	  public explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries if this write lock is held by the current thread.
Identical in effect to {@link
ReentrantReadWriteLock#isWriteLockedByCurrentThread}.

@return {@code true} if the current thread holds this lock and
        {@code false} otherwise
@since 1.6"
	end

	operation 1671451 "getHoldCount"
	  public explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries the number of holds on this write lock by the current
thread.  A thread has a hold on a lock for each lock action
that is not matched by an unlock action.  Identical in effect
to {@link ReentrantReadWriteLock#getWriteHoldCount}.

@return the number of holds on this lock by the current thread,
        or zero if this lock is not held by the current thread
@since 1.6"
	end
      end

      classrelation 470939 // writerLock (<unidirectional association>)
	relation 470939 --->
	  a role_name "writerLock" const_relation private
	    comment " Inner class providing writelock 
"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 470939 // writerLock (<unidirectional association>)
	  b parent class_ref 275739 // WriteLock
      end

      class 275867 "Sync"
	abstract visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 471195 // <generalisation>
	  relation 471195 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 471195 // <generalisation>
	    b parent class_ref 256283 // AbstractQueuedSynchronizer
	end

	attribute 406555 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 6317671515068378041L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 406683 "SHARED_SHIFT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " 16"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "Read vs write count extraction constants and functions.
Lock state is logically divided into two unsigned shorts:
The lower one representing the exclusive (writer) lock hold count,
and the upper the shared (reader) hold count.
"
	end

	attribute 406811 "SHARED_UNIT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT)"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 406939 "MAX_COUNT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT) - 1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 407067 "EXCLUSIVE_MASK"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT) - 1"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1665819 "sharedCount"
	  class_operation package explicit_return_type "int"
	  nparams 1
	    param in name "c" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Returns the number of shared holds represented in count  "
	end

	operation 1665947 "exclusiveCount"
	  class_operation package explicit_return_type "int"
	  nparams 1
	    param in name "c" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Returns the number of exclusive holds represented in count  "
	end

	class 275995 "HoldCounter"
	  visibility package 
	  cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	  final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  
	  attribute 407195 "count"
	    package explicit_type "int"
	    init_value " 0"
	    cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    php_decl ""
	    python_decl ""
	    idl_decl ""
	  end

	  attribute 407323 "tid"
	    const_attribute package explicit_type "long"
	    init_value " Thread.currentThread().getId()"
	    cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    php_decl ""
	    python_decl ""
	    idl_decl ""
	    comment " Use id, not reference, to avoid garbage retention"
	  end
	end

	class 276123 "ThreadLocalHoldCounter"
	  visibility package 
	  nactuals 1
	  actual class class_ref 144539 // ThreadLocal
	    rank 0 explicit_value ""
	  cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	  final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  
	  classrelation 471323 // <realization>
	    relation 471323 -_-|>
	      stereotype "bind"
	      a public
		cpp default "${type}"
		java "${type}"
		classrelation_ref 471323 // <realization>
	      b parent class_ref 144539 // ThreadLocal
	  end

	  operation 1666075 "initialValue"
	    public return_type class_ref 275995 // HoldCounter
	    nparams 0
	    cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	    cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	    preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	    
	    
	    
	  end
	end

	classrelation 471451 // readHolds (<unidirectional association>)
	  relation 471451 --->
	    a role_name "readHolds" private
	      comment "
The number of reentrant read locks held by current thread.
Initialized only in constructor and readObject.
Removed whenever a thread's read hold count drops to 0.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 471451 // readHolds (<unidirectional association>)
	    b parent class_ref 276123 // ThreadLocalHoldCounter
	end

	classrelation 471579 // cachedHoldCounter (<unidirectional association>)
	  relation 471579 --->
	    a role_name "cachedHoldCounter" private
	      comment "
The hold count of the last thread to successfully acquire
readLock. This saves ThreadLocal lookup in the common case
where the next thread to release is the last one to
acquire. This is non-volatile since it is just used
as a heuristic, and would be great for threads to cache.

<p>Can outlive the Thread for which it is caching the read
hold count, but avoids garbage retention by not retaining a
reference to the Thread.

<p>Accessed via a benign data race; relies on the memory
model's final field and out-of-thin-air guarantees.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 471579 // cachedHoldCounter (<unidirectional association>)
	    b parent class_ref 275995 // HoldCounter
	end

	classrelation 471707 // firstReader (<unidirectional association>)
	  relation 471707 --->
	    a role_name "firstReader" init_value " null" private
	      comment "
firstReader is the first thread to have acquired the read lock.
firstReaderHoldCount is firstReader's hold count.

<p>More precisely, firstReader is the unique thread that last
changed the shared count from 0 to 1, and has not released the
read lock since then; null if there is no such thread.

<p>Cannot cause garbage retention unless the thread terminated
without relinquishing its read locks, since tryReleaseShared
sets it to null.

<p>Accessed via a benign data race; relies on the memory
model's out-of-thin-air guarantees for references.

<p>This allows tracking of read holds for uncontended read
locks to be very cheap.

"
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 471707 // firstReader (<unidirectional association>)
	    b parent class_ref 1201420 // Thread
	end

	attribute 407451 "firstReaderHoldCount"
	  private explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  transient java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1666203 "Sync"
	  package explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1666331 "readerShouldBlock"
	  abstract package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires and releases use the same code for fair and
nonfair locks, but differ in whether/how they allow barging
when queues are non-empty.


Returns true if the current thread, when trying to acquire
the read lock, and otherwise eligible to do so, should block
because of policy for overtaking other waiting threads."
	end

	operation 1666459 "writerShouldBlock"
	  abstract package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if the current thread, when trying to acquire
the write lock, and otherwise eligible to do so, should block
because of policy for overtaking other waiting threads."
	end

	operation 1666587 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Note that tryRelease and tryAcquire can be called by
Conditions. So it is possible that their arguments contain
both read and write holds that are all released during a
condition wait and re-established in tryAcquire."
	end

	operation 1666715 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1666843 "tryReleaseShared"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "unused" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1666971 "unmatchedUnlockException"
	  private return_type class_ref 154139 // IllegalMonitorStateException
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1667099 "tryAcquireShared"
	  protected explicit_return_type "int"
	  nparams 1
	    param in name "unused" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1667227 "fullTryAcquireShared"
	  package explicit_return_type "int"
	  nparams 1
	    param inout name "current" type class_ref 1201420 // Thread
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Full version of acquire for reads, that handles CAS misses
and reentrant reads not dealt with in tryAcquireShared."
	end

	operation 1667355 "tryWriteLock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs tryLock for write, enabling barging in both modes.
This is identical in effect to tryAcquire except for lack
of calls to writerShouldBlock."
	end

	operation 1667483 "tryReadLock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs tryLock for read, enabling barging in both modes.
This is identical in effect to tryAcquireShared except for
lack of calls to readerShouldBlock."
	end

	operation 1667611 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1667739 "newCondition"
	  package return_type class_ref 256667 // ConditionObject
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed to outer class"
	end

	operation 1667867 "getOwner"
	  package return_type class_ref 1201420 // Thread
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1667995 "getReadLockCount"
	  package explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1668123 "isWriteLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1668251 "getWriteHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1668379 "getReadHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1668507 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 128667 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 128539 // IOException
	    exception class_ref 128795 // ClassNotFoundException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitutes this lock instance from a stream (that is,
deserializes it).

@param s the stream"
	end

	operation 1668635 "getCount"
	  package explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 471067 // sync (<unidirectional association>)
	relation 471067 --->
	  a role_name "sync" const_relation package
	    comment " Performs all synchronization mechanics 
"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 471067 // sync (<unidirectional association>)
	  b parent class_ref 275867 // Sync
      end

      operation 1665307 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new {@code ReentrantReadWriteLock} with
default (nonfair) ordering properties."
      end

      operation 1665435 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new {@code ReentrantReadWriteLock} with
the given fairness policy.

@param fair {@code true} if this lock should use a fair ordering policy"
      end

      operation 1665563 "writeLock"
	public return_type class_ref 275739 // WriteLock
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 1665691 "readLock"
	public return_type class_ref 275611 // ReadLock
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      class 276251 "NonfairSync"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 471835 // <generalisation>
	  relation 471835 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 471835 // <generalisation>
	    b parent class_ref 275867 // Sync
	end

	attribute 407579 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -8159625535654395037L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1668763 "writerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1668891 "readerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      class 276379 "FairSync"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 471963 // <generalisation>
	  relation 471963 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 471963 // <generalisation>
	    b parent class_ref 275867 // Sync
	end

	attribute 407707 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -2274990926593161451L"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 1669019 "writerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 1669147 "readerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      operation 1671579 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and status

Returns {@code true} if this lock has fairness set true.

@return {@code true} if this lock has fairness set true"
      end

      operation 1671707 "getOwner"
	protected return_type class_ref 1201420 // Thread
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns the write lock, or
{@code null} if not owned. When this method is called by a
thread that is not the owner, the return value reflects a
best-effort approximation of current lock status. For example,
the owner may be momentarily {@code null} even if there are
threads trying to acquire the lock but have not yet done so.
This method is designed to facilitate construction of
subclasses that provide more extensive lock monitoring
facilities.

@return the owner, or {@code null} if not owned"
      end

      operation 1671835 "getReadLockCount"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of read locks held for this lock. This
method is designed for use in monitoring system state, not for
synchronization control.
@return the number of read locks held."
      end

      operation 1671963 "isWriteLocked"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by any thread. This method is
designed for use in monitoring system state, not for
synchronization control.

@return {@code true} if any thread holds the write lock and
        {@code false} otherwise"
      end

      operation 1672091 "isWriteLockedByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by the current thread.

@return {@code true} if the current thread holds the write lock and
        {@code false} otherwise"
      end

      operation 1672219 "getWriteHoldCount"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of reentrant write holds on this lock by the
current thread.  A writer thread has a hold on a lock for
each lock action that is not matched by an unlock action.

@return the number of holds on the write lock by the current thread,
        or zero if the write lock is not held by the current thread"
      end

      operation 1672347 "getReadHoldCount"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of reentrant read holds on this lock by the
current thread.  A reader thread has a hold on a lock for
each lock action that is not matched by an unlock action.

@return the number of holds on the read lock by the current thread,
        or zero if the read lock is not held by the current thread
@since 1.6"
      end

      operation 1672475 "getQueuedWriterThreads"
	protected return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the write lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.

@return the collection of threads"
      end

      operation 1672603 "getQueuedReaderThreads"
	protected return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the read lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.

@return the collection of threads"
      end

      operation 1672731 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire the read or
write lock. Note that because cancellations may occur at any
time, a {@code true} return does not guarantee that any other
thread will ever acquire a lock.  This method is designed
primarily for use in monitoring of the system state.

@return {@code true} if there may be other threads waiting to
        acquire the lock"
      end

      operation 1672859 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 1201420 // Thread
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire either
the read or write lock. Note that because cancellations may
occur at any time, a {@code true} return does not guarantee
that this thread will ever acquire a lock.  This method is
designed primarily for use in monitoring of the system state.

@param thread the thread
@return {@code true} if the given thread is queued waiting for this lock
@throws NullPointerException if the thread is null"
      end

      operation 1672987 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to acquire
either the read or write lock.  The value is only an estimate
because the number of threads may change dynamically while this
method traverses internal data structures.  This method is
designed for use in monitoring of the system state, not for
synchronization control.

@return the estimated number of threads waiting for this lock"
      end

      operation 1673115 "getQueuedThreads"
	protected return_type class_ref 160667 // Collection
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire either the read or write lock.  Because the actual set
of threads may change dynamically while constructing this
result, the returned collection is only a best-effort estimate.
The elements of the returned collection are in no particular
order.  This method is designed to facilitate construction of
subclasses that provide more extensive monitoring facilities.

@return the collection of threads"
      end

      operation 1673243 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with the write lock. Note that because timeouts and
interrupts may occur at any time, a {@code true} return does
not guarantee that a future {@code signal} will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1673371 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with the write lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1673499 "getWaitingThreads"
	protected return_type class_ref 160667 // Collection
	nparams 1
	  param inout name "condition" type class_ref 254363 // Condition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with the write lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null"
      end

      operation 1673627 "toString"
	public return_type class_ref 3399692 // String
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String {@code \"Write locks =\"}
followed by the number of reentrantly held write locks, and the
String {@code \"Read locks =\"} followed by the number of held
read locks.

@return a string identifying this lock, as well as its lock state"
      end
    end
  end

  deploymentview 131483 "locks"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 224795 "Lock"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
${definition}"
      associated_classes
	class_ref 256027 // Lock
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 224923 "AbstractOwnableSynchronizer"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 256411 // AbstractOwnableSynchronizer
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 225051 "Condition"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.*;
import java.util.Date;
${definition}"
      associated_classes
	class_ref 254363 // Condition
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 225179 "AbstractQueuedSynchronizer"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.*;
import java.util.concurrent.*;
import sun.misc.Unsafe;
${definition}"
      associated_classes
	class_ref 256283 // AbstractQueuedSynchronizer
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 225307 "ReentrantLock"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.*;
import java.util.concurrent.*;
${definition}"
      associated_classes
	class_ref 254235 // ReentrantLock
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 232603 "AbstractQueuedLongSynchronizer"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.*;
import java.util.concurrent.*;
import sun.misc.Unsafe;
${definition}"
      associated_classes
	class_ref 274843 // AbstractQueuedLongSynchronizer
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 232731 "LockSupport"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import sun.misc.Unsafe;
${definition}"
      associated_classes
	class_ref 275227 // LockSupport
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 232859 "ReadWriteLock"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 275355 // ReadWriteLock
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end

    artifact 232987 "ReentrantReadWriteLock"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.*;
import java.util.*;
${definition}"
      associated_classes
	class_ref 275483 // ReentrantReadWriteLock
      end
      comment "Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/"
    end
  end
end
