class OmxAmpAudioRenderer
!!!11104012.cpp!!!	OmxAmpAudioRenderer()
  OMX_LOGD("Default constructor.");
!!!11104140.cpp!!!	OmxAmpAudioRenderer(in name : OMX_STRING)
  OMX_LOGD("ENTER");
  kdMemset(mSndSrvTunnel, 0x0, AREN_PASSTHRU_OUTPUT_PORT_NUM * sizeof(mSndSrvTunnel));
  strncpy(mName, name, OMX_MAX_STRINGNAME_SIZE);

  mVolume.nValue = 100;
  mVolume.nMax = 100;
  mVolume.nMin = 0;
  mSourceControl = NULL;
  mOutputControl = NULL;
  mSourceId = -1;
  mAudioChannel = -1;
  mPhySourceGain = -1;
  mIsSnsConnect = OMX_FALSE;
  mPool = NULL;
  mPushedBdNum = 0;
  mReturnedBdNum = 0;
  mCachedhead = NULL;
  mEOS = OMX_FALSE;
  OMX_LOGD("EXIT");
!!!11104268.cpp!!!	~OmxAmpAudioRenderer()
  OMX_LOGD("%s() line %d", __FUNCTION__, __LINE__);
!!!11104524.cpp!!!	setParameter(in index : OMX_INDEXTYPE, in params : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;
  OMX_AUDIO_PARAM_PCMMODETYPE *pcm_type = NULL;
  OmxPortImpl *port = NULL;

  switch (index) {
    case OMX_IndexParamAudioPortFormat: {
      OMX_AUDIO_PARAM_PORTFORMATTYPE* audio_param =
          reinterpret_cast<OMX_AUDIO_PARAM_PORTFORMATTYPE*>(params);
      err = CheckOmxHeader(audio_param);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("invalid parameter");
        break;
      }
      OmxPortImpl* port = getPort(audio_param->nPortIndex);
      if (NULL == port) {
        OMX_LOGE("invalid port");
        err = OMX_ErrorBadPortIndex;
        break;
      }
      if (port->getDomain() == OMX_PortDomainAudio) {
        port->setAudioParam(audio_param);
        port->updateDomainDefinition();
      }

      break;
    }

    case OMX_IndexParamAudioPcm: {
      OMX_LOGD("OMX_IndexParamAudioPcm");
      pcm_type = reinterpret_cast<OMX_AUDIO_PARAM_PCMMODETYPE *>(params);

      // There is only one port.
      if (pcm_type->nPortIndex > 1) {
        return OMX_ErrorUndefined;
      }

      port = getPort(pcm_type->nPortIndex);
      if(NULL == port) {
        OMX_LOGE("invalid port");
        err =  OMX_ErrorBadPortIndex;
        break;
      }
      mNumChannels = pcm_type->nChannels;
      mSamplingRate = pcm_type->nSamplingRate;
      mNumData = pcm_type->eNumData;;
      mBitPerSample = pcm_type->nBitPerSample;
      mEndian = pcm_type->eEndian;
      OMX_LOGD("set PCM parameters: mNumChannels = %d, mSamplingRate = %d \
          mNumData %d, mBitPerSample %d, mEndian %d\n",
          mNumChannels, mSamplingRate, mNumData, mBitPerSample, mEndian);

      break;
    }

    default:
      return OmxComponentImpl::setParameter(index, params);
  }

  return err;
!!!11104652.cpp!!!	getConfig(in index : OMX_INDEXTYPE, in config : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;

  switch(index) {
    case OMX_IndexConfigAudioVolume: {
      OMX_LOGD("OMX_IndexConfigAudioVolume");
      OMX_AUDIO_CONFIG_VOLUMETYPE *volume_conf =
          reinterpret_cast<OMX_AUDIO_CONFIG_VOLUMETYPE *>(config);
      err = CheckOmxHeader(volume_conf);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("invalid config");
        err = OMX_ErrorUndefined;
        break;
      }

      // There is only one port.
      if (volume_conf->nPortIndex > 1) {
        OMX_LOGE("invalid port index");
        err = OMX_ErrorUndefined;
        break;
      }

      volume_conf->bLinear = OMX_TRUE;
      volume_conf->sVolume.nValue = mVolume.nValue;
      volume_conf->sVolume.nMax = mVolume.nMax;
      volume_conf->sVolume.nMin = mVolume.nMin;

      break;
    }

    case OMX_IndexConfigAudioMute: {
      OMX_LOGD("OMX_IndexConfigAudioMute");
      OMX_AUDIO_CONFIG_MUTETYPE b;

      break;
    }

    default:
      return OmxComponentImpl::getConfig(index, config);
  }

  return err;
!!!11104780.cpp!!!	setConfig(in index : OMX_INDEXTYPE, in config : OMX_PTR) : OMX_ERRORTYPE
  OMX_ERRORTYPE err = OMX_ErrorNone;

  switch(index) {
    case OMX_IndexConfigAudioVolume: {
      OMX_LOGD("OMX_IndexConfigAudioVolume");
      OMX_AUDIO_CONFIG_VOLUMETYPE *volume_conf =
          reinterpret_cast<OMX_AUDIO_CONFIG_VOLUMETYPE *>(config);
      err = CheckOmxHeader(volume_conf);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("invalid config");
        err = OMX_ErrorUndefined;
        break;
      }

      if (mInputPort->getPortIndex() != volume_conf->nPortIndex) {
        OMX_LOGE("bad port index");
        err = OMX_ErrorBadPortIndex;
        break;
      }

      mVolume.nValue = volume_conf->sVolume.nValue;
      mVolume.nMax = volume_conf->sVolume.nMax;
      mVolume.nMin = volume_conf->sVolume.nMin;
      OMX_LOGD("set volume to %d", mVolume.nValue);

      float volumePercent =
        (float)(mVolume.nValue - mVolume.nMin) / (mVolume.nMax -mVolume.nMin);
      UINT32 ampVolume = (UINT32)(volumePercent * 100);

      HRESULT rc = AMP_SND_SetStreamVolume(mSndSrvTunnel[0], ampVolume);
      if (rc != SUCCESS) {
        OMX_LOGE("set volume failed, rc=0x%x", rc);
        err = OMX_ErrorUndefined;
      }

      break;
    }
    case OMX_IndexConfigAudioMute:
      OMX_LOGD("OMX_IndexConfigAudioMute");
      break;
    case OMX_IndexConfigAudioChannelVolume: {
      OMX_LOGD("OMX_IndexConfigAudioChannelVolume");
      OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE *configVolume =
          reinterpret_cast<OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE *>(config);

      err = CheckOmxHeader(configVolume);
      if (OMX_ErrorNone != err) {
        OMX_LOGE("invalid config");
        err = OMX_ErrorUndefined;
        break;
      }

      if (mInputPort->getPortIndex() != configVolume->nPortIndex) {
        OMX_LOGE("bad port index");
        err = OMX_ErrorBadPortIndex;
        break;
      }

      mVolume.nValue = configVolume->sVolume.nValue;
      mVolume.nMax = configVolume->sVolume.nMax;
      mVolume.nMin = configVolume->sVolume.nMin;
      OMX_LOGD("set volume to %d", mVolume.nValue);

      float volumePercent =
        (float)(mVolume.nValue - mVolume.nMin) / (mVolume.nMax -mVolume.nMin);
      UINT32 ampVolume = (UINT32)(volumePercent * 0x7fffffff);

      AMP_APP_PARAMIXGAIN mixerGain;
      HRESULT rc;
      rc = AMP_SND_GetMixerGain(mSndSrvTunnel[0], &mixerGain);
      if (rc != S_OK) {
        OMX_LOGE("failed to get mixer gain, rc=%d", rc);
        mixerGain.uiLeftGain = 0x7fffffff;
        mixerGain.uiRghtGain = 0x7fffffff;
      }
      OMX_LOGD("uiLeftGain=0x%x, uiRightgain=0x%x",
          mixerGain.uiLeftGain, mixerGain.uiRghtGain);

      if (configVolume->nChannel == OMX_AUDIO_ChannelLHS) {
        mixerGain.uiLeftGain = ampVolume;
      } else if (configVolume->nChannel == OMX_AUDIO_ChannelRHS) {
        mixerGain.uiRghtGain = ampVolume;
      } else {
        OMX_LOGW("unsupported channel(%d)", configVolume->nChannel);
      }

      rc = AMP_SND_SetMixerGain(mSndSrvTunnel[0], &mixerGain);
      if (rc != S_OK) {
        OMX_LOGE("failed to set mixer gain, rc=%d", rc);
      }

      break;
    }
    default:
      return OmxComponentImpl::setConfig(index, config);
  }

  return err;
!!!11104908.cpp!!!	componentDeInit(in hComponent : OMX_HANDLETYPE) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OmxComponent *comp = reinterpret_cast<OmxComponent *>(
      reinterpret_cast<OMX_COMPONENTTYPE *>(hComponent)->pComponentPrivate);
  OmxAmpAudioRenderer *aren = static_cast<OmxAmpAudioRenderer *>(comp);
  delete aren;
  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11105036.cpp!!!	initRole() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  if (strncmp(mName, kCompNamePrefix, kCompNamePrefixLength)) {
    OMX_LOGE("Not a Marvell component role %s.", mName);
    return OMX_ErrorInvalidComponentName;
  }

  char * role_name = mName + kCompNamePrefixLength;
  if (!strncmp(role_name, OMX_ROLE_AUDIO_RENDERER_PCM, 18)) {
    addRole(OMX_ROLE_AUDIO_RENDERER_PCM);
  } else {
    OMX_LOGE("%s is not a role of OmxAmpAudioRenderer", mName);
    return OMX_ErrorInvalidComponentName;
  }

  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11105164.cpp!!!	initPort() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;

  if (!strncmp(mActiveRole, OMX_ROLE_AUDIO_RENDERER_PCM, 18)) {
    mInputPort = new OmxAmpAudioPort(kAudioPortStartNumber, OMX_DirInput);
    // Set port definition.
    OMX_PARAM_PORTDEFINITIONTYPE def;
    mInputPort->getDefinition(&def);
    def.nBufferSize = 4096 * AMP_AUD_MAX_BUF_NR; // 4k * 8
    def.nBufferCountActual = 4;
    mInputPort->setDefinition(&def);
    // Add port.
    addPort(mInputPort);
  }

  mClockPort = new OmxAmpClockPort(kClockPortStartNumber, OMX_DirInput);
  addPort(mClockPort);

  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11105292.cpp!!!	prepare() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  // mediahelper init
  if (mediainfo_buildup()) {
    OMX_LOGD("Media helper build success");
  } else {
    OMX_LOGE("Media helper build fail");
  }
  // remove the dumped data
  mediainfo_remove_dumped_data(MEDIA_AUDIO);

  HRESULT err = SUCCESS;
  OMX_ERRORTYPE res = OMX_ErrorNone;
  AMP_COMPONENT_CONFIG mConfig;
  AMP_COMPONENT_INFO cmp_info;

  initAQ();

  // Get AMP factory.
  err = AMP_GetFactory(&mFactory);
  CHECK_AMP_RETURN_VAL(err, "get AMP factory");

  // Create AMP ARen component.
  AMP_RPC(err, AMP_FACTORY_CreateComponent, mFactory, AMP_COMPONENT_AREN,
      1, &mAmpHandle);
  CHECK_AMP_RETURN_VAL(err, "create AREN component");

  // Set configs for ARen.
  kdMemset(&mConfig, 0x00, sizeof(AMP_COMPONENT_CONFIG));
  mConfig._d = AMP_COMPONENT_AREN;
  if (mPassthru == OMX_TRUE && mInputPort->isTunneled()) {
    OMX_LOGD("aren is passthru and tunneled");
    // if passthru mode, open three clock port and three input and three output port
    mConfig._u.pAREN.uiInClkPortNum = AREN_PASSTHRU_OUTPUT_PORT_NUM;
    mConfig._u.pAREN.uiInPcmPortNum  = 1;
    mConfig._u.pAREN.uiInSpdifPortNum  = 1;
    mConfig._u.pAREN.uiInHdmiPortNum  = 1;
    mConfig._u.pAREN.uiOutPcmPortNum = 1;
    mConfig._u.pAREN.uiOutSpdifPortNum = 1;
    mConfig._u.pAREN.uiOutHdmiPortNum = 1;
  } else {
    mConfig._u.pAREN.uiInClkPortNum = 1;
    mConfig._u.pAREN.uiInPcmPortNum = 1;
    mConfig._u.pAREN.uiOutPcmPortNum = 1;
  }

  if (mInputPort->isTunneled()) {
    mConfig._u.pAREN.mode = AMP_TUNNEL;
  } else {
    mConfig._u.pAREN.mode = AMP_NON_TUNNEL;
#if 1
    OMX_LOGD("AREN create cbuf");
    OMX_U32 ret = AMP_CBUFCreate(stream_in_buf_size, 0, stream_in_bd_num,
        stream_in_align_size, true, &mPool, true, 64 * 1024);
    if (AMPCBUF_SUCCESS != ret) {
      OMX_LOGW("AREN Cbuf Create Error %u.", ret);
      // create cbuf fail, use omx bd
      OMX_PARAM_PORTDEFINITIONTYPE def;
      mInputPort->getDefinition(&def);
      def.nBufferSize = 4096 * AMP_AUD_MAX_BUF_NR; // 4k * 8
      def.nBufferCountActual = 64;
      mInputPort->setDefinition(&def);
    }
#else
    OMX_PARAM_PORTDEFINITIONTYPE def;
    mInputPort->getDefinition(&def);
    def.nBufferSize = 4096 * AMP_AUD_MAX_BUF_NR; // 4k * 8
    def.nBufferCountActual = 64;
    mInputPort->setDefinition(&def);
#endif
  }
  // Open ARen with configs.
  AMP_RPC(err, AMP_AREN_Open, mAmpHandle, &mConfig);
  CHECK_AMP_RETURN_VAL(err, "open AREN handle");

  AMP_RPC(err, AMP_AREN_SetState, mAmpHandle, AMP_IDLE);
  CHECK_AMP_RETURN_VAL(err, "set AREN state to idle");

  kdMemset(&cmp_info, 0x00, sizeof(AMP_COMPONENT_INFO));
  AMP_RPC(err, AMP_AREN_QueryInfo, mAmpHandle, &cmp_info);
  CHECK_AMP_RETURN_VAL(err, "query AREN's info");

  OMX_LOGV("cmp_info.uiInputPortNum = %d, cmp_info.uiOutputPortNum = %d",
      cmp_info.uiInputPortNum, cmp_info.uiOutputPortNum);

  // Connect ARen's clock port.
  if (mClockPort && mClockPort->isTunneled()) {
    res = connectClockPort(OMX_TRUE);
    if (OMX_ErrorNone != res) {
      OMX_LOGE("Connect clock port failed 0x%x", res);
      goto FAILED_EXIT;
    }
  }

  // Connect ARen's input port.
  if (mInputPort->isTunneled()) {
    // Tunnel mode.
    res = connectADecAudioPort(OMX_TRUE);
    if (OMX_ErrorNone != res) {
      OMX_LOGE("Connect ADec output port failed 0x%x", res);
      goto FAILED_EXIT;
    }
  } else {
    // Non-Tunnel mode.
    err = AMP_ConnectApp(mAmpHandle, AMP_PORT_INPUT,
        1, pushBufferDone, static_cast<void *>(this));
    CHECK_AMP_RETURN_VAL(err, "connect with AREN input port");
  }

  res = connectSoundService();
  if (OMX_ErrorNone != res) {
    OMX_LOGE("Connect sound service failed 0x%x", res);
    mIsSnsConnect = OMX_FALSE;
    return res;
  } else {
    mIsSnsConnect = OMX_TRUE;
    // Set Source gain
    setMixGain();
  }

  // Register a callback so that it can receive event - for example EOS -from ARen.
  mListener = AMP_Event_CreateListener(AMP_EVENT_TYPE_MAX, 0);
  if (mListener) {
    registerEvent(AMP_EVENT_API_AREN_CALLBACK);
  }

FAILED_EXIT:
  OMX_LOG_FUNCTION_EXIT;
  return res;
!!!11105420.cpp!!!	preroll() : OMX_ERRORTYPE
  OMX_LOGD("%s() line %d", __FUNCTION__, __LINE__);
  return OMX_ErrorNone;
!!!11105548.cpp!!!	start() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;

  if (!mInputPort->isTunneled()) {
    err = registerBds(static_cast<OmxAmpAudioPort *>(mInputPort));
    CHECK_AMP_RETURN_VAL(err, "register BDs in AREN input port");
  }

  err = setAmpState(AMP_EXECUTING);

  // Create data thread only for non-tunnel mode, because in tunnel mode there is no data flow.
  if (!mInputPort->isTunneled()) {
    OMX_LOGD("Create data thread");
    mPauseLock = kdThreadMutexCreate(KD_NULL);
    mPauseCond = kdThreadCondCreate(KD_NULL);
    mThread = kdThreadCreate(mThreadAttr, threadEntry,(void *)this);
  }

  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11105676.cpp!!!	pause() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;

  OMX_ERRORTYPE err = OMX_ErrorNone;
  // Pause data thread firstly.
  if (mThread) {
    mShouldExit = OMX_TRUE;
    mPaused = OMX_TRUE;
  }
  // Pause AMP ARen.
  err = setAmpState(AMP_PAUSED);

  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11105804.cpp!!!	resume() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;

  OMX_ERRORTYPE err = OMX_ErrorNone;
  // Resume AMP ARen firstly.
  err = setAmpState(AMP_EXECUTING);

  // Resume data thread.
  if (mThread) {
    if (mInputPort->getCachedBuffer() != NULL) {
      returnBuffer(mInputPort, mInputPort->getCachedBuffer());
    }
    mShouldExit = OMX_FALSE;
    mPaused = OMX_FALSE;
    kdThreadMutexLock(mPauseLock);
    kdThreadCondSignal(mPauseCond);
    kdThreadMutexUnlock(mPauseLock);
  }

  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11105932.cpp!!!	stop() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  OMX_ERRORTYPE err = OMX_ErrorNone;
  HRESULT result = SUCCESS;

  mShouldExit = OMX_TRUE;
  mPaused = OMX_FALSE;
  if (mPauseLock) {
    kdThreadMutexLock(mPauseLock);
    kdThreadCondSignal(mPauseCond);
    kdThreadMutexUnlock(mPauseLock);
  }
  if (mThread) {
    void *retval;
    KDint ret;
    ret = kdThreadJoin(mThread, &retval);
    OMX_LOGD("%s() line %d, now thread has been joined", __FUNCTION__, __LINE__);
    mThread = NULL;
  }
  if (mPauseLock) {
    kdThreadMutexFree(mPauseLock);
    mPauseLock = NULL;
  }
  if (mPauseCond) {
    kdThreadCondFree(mPauseCond);
    mPauseCond = NULL;
  }
  if (mCachedhead) {
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  // Set State.
  AMP_RPC(result, AMP_AREN_SetState, mAmpHandle, AMP_IDLE);
  if (result != SUCCESS) {
    OMX_LOGE("AMP_AREN_SetState(AMP_IDLE) failed with error 0x%x", result);
  }
  OMX_LOGD("AMP state changed to AMP_IDLE", AMP_IDLE);

  if (!mInputPort->isTunneled()) {
    // Waiting for input/output buffers back
    OMX_U32 wait_count = 100;
    while ((mInputFrameNum > mInBDBackNum) && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    OMX_LOGD("inputframe %d inbackbd %d wait %d\n",
      mInputFrameNum, mInBDBackNum, wait_count);

    if (mPool) {
      wait_count = 150;
      while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
        usleep(5000);
        wait_count --;
      }
      if (!wait_count) {
        OMX_LOGE("There are %d pushed BD not returned.",
            mPushedBdNum - mReturnedBdNum);
      }
      if (AMPCBUF_SUCCESS != AMP_CBUFDestroy(mPool)) {
        OMX_LOGE("Cbuf destroy pool error.");
      }
    }

    returnCachedBuffers(mInputPort);

    err = unregisterBds(static_cast<OmxAmpAudioPort *>(mInputPort));
    CHECK_AMP_RETURN_VAL(err, "unregister BDs in input port");
  }

  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11106060.cpp!!!	release() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  // deinit mediahelper
  mediainfo_teardown();
  HRESULT result = SUCCESS;
  OMX_ERRORTYPE res = OMX_ErrorNone;

  if (mListener) {
    unRegisterEvent(AMP_EVENT_API_AREN_CALLBACK);
    AMP_Event_DestroyListener(mListener);
    mListener = NULL;
  }

  // Disconnect ARen's input port.
  if (!mInputPort->isTunneled()) {
    result = AMP_DisconnectApp(mAmpHandle, AMP_PORT_INPUT, 0, pushBufferDone);
    CHECK_AMP_RETURN_VAL(result, "disconnect AREN's input port");
  } else {
    // Tunnel mode.
    res = connectADecAudioPort(OMX_FALSE);
    OMX_LOGD("Disconnect ADec output port return 0x%x", res);
  }

#ifdef DISCONNECT_CLOCK_PORT
  // Disconnect ARen's clock port.
  res = connectClockPort(OMX_FALSE);
  OMX_LOGD("Disconnect clock port return 0x%x", res);
#endif

  // Disconnect ARen from sound service.
  if (mPassthru == OMX_TRUE) {
    for (OMX_U32 app_index = 0; app_index < AREN_PASSTHRU_OUTPUT_PORT_NUM;
        app_index++) {
      result = AMP_SND_RemoveTunnel(mSndSrvTunnel[app_index]);
      CHECK_AMP_RETURN_VAL(result, "AMP_SND_RemoveTunnel()");
      mSndSrvTunnel[app_index] = NULL;
    }
  } else {
    result = AMP_SND_RemoveTunnel(mSndSrvTunnel[0]);
    CHECKAMPERRLOG(result, "AMP_SND_RemoveTunnel()");
    mSndSrvTunnel[0] = NULL;
  }
  result = AMP_SND_Deinit();
  CHECK_AMP_RETURN_VAL(result, "AREN disconnected from sound service");

  // Close.
  AMP_RPC(result, AMP_AREN_Close, mAmpHandle);
  CHECKAMPERRLOG(result, "AMP_AREN_Close()");

  // Destory.
  AMP_RPC(result, AMP_AREN_Destroy, mAmpHandle);
  CHECKAMPERRLOG(result, "AMP_AREN_Destroy()");


  if (NULL != mOutputControl) {
    mOutputControl->removeObserver(mObserver);
    delete mOutputControl;
    mOutputControl = NULL;
  }
  if (NULL != mSourceControl) {
    if (-1 != mSourceId) {
      mSourceControl->exitSource(mSourceId);
    }
    delete mSourceControl;
    mSourceControl = NULL;
  }
  mAmpHandle = NULL;

  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11106188.cpp!!!	flush() : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;

  // clear dumped data
  MEDIA_S8 value[MEDIA_VALUE_LENGTH];
  if (mediainfo_get_property(
      reinterpret_cast<const MEDIA_S8 *>("mediainfo_clear_dump"), value) &&
      kdMemcmp(value, "1", 1) == 0) {
    mediainfo_remove_dumped_data(MEDIA_AUDIO);
  }
  OMX_U32 wait_count = 100;
  while (!mInputPort->isEmpty() && wait_count > 0) {
    usleep(5000);
    wait_count--;
  }
  if (!wait_count) {
    OMX_LOGE("The buffer queue have not been cleared.");
  }
  if (NULL != mCachedhead) {
    OMX_LOGD("return the cached buffer header.");
    returnBuffer(mInputPort, mCachedhead);
    mCachedhead = NULL;
  }
  // Set ARen to AMP_IDLE so that it can return all buffers.
  AMP_RPC(err, AMP_AREN_SetState, mAmpHandle, AMP_IDLE);
  CHECK_AMP_RETURN_VAL(err, "set AREN state to idle");

  // Waiting for input/output buffer back
  wait_count = 100;
  if (!mInputPort->isTunneled()) {
    wait_count = 100;
    while ((mInputFrameNum > mInBDBackNum) && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    OMX_LOGD("inputframe %d inbackbd %d wait %d\n",
      mInputFrameNum, mInBDBackNum, wait_count);
    returnCachedBuffers(mInputPort);
  }
  if (NULL != mPool) {
    wait_count = 200;
    while (mPushedBdNum > mReturnedBdNum && wait_count > 0) {
      usleep(5000);
      wait_count--;
    }
    if (!wait_count) {
      OMX_LOGE("There are %d pushed Bd not returned.",
          mPushedBdNum - mReturnedBdNum);
    }
    if (AMPCBUF_SUCCESS != AMP_CBUFReset(mPool)) {
      OMX_LOGE("Cbuf AMP_CBUFReSet error.");
    }
    mPushedBdNum = 0;
    mReturnedBdNum = 0;
  }
  if (getState() == OMX_StateExecuting) {
    AMP_RPC(err, AMP_AREN_SetState, mAmpHandle, AMP_EXECUTING);
    CHECK_AMP_RETURN_VAL(err, "set AREN state to executing");
  } else if (getState() == OMX_StatePause) {
    AMP_RPC(err, AMP_AREN_SetState, mAmpHandle, AMP_PAUSED);
    CHECK_AMP_RETURN_VAL(err, "set AREN state to pause");
  }
  mStreamPosition = 0;
  mEOS = OMX_FALSE;
  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11106316.cpp!!!	pushAmpBd(in port : AMP_PORT_IO, in portindex : UINT32, inout bd : AMP_BD_ST) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_RPC(err, AMP_AREN_PushBD, mAmpHandle, port, portindex, bd);
  CHECKAMPERRLOG(err, "push BD to AREN");
  return static_cast<OMX_ERRORTYPE>(err);
!!!11106444.cpp!!!	registerBds(inout port : OmxAmpAudioPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  UINT32 uiPortIdx = 0;
  AMP_BD_ST *bd;

  for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
    AmpBuffer *amp_buffer = port->getAmpBuffer(i);
    if (NULL != amp_buffer) {
      amp_buffer->addAudioFrameInfoTag(mNumChannels, mBitPerSample,
          mSamplingRate);
      amp_buffer->addAVSPtsTag();
      AMP_RPC(err, AMP_AREN_RegisterBD, mAmpHandle, AMP_PORT_INPUT,
          uiPortIdx, amp_buffer->getBD());
      CHECKAMPERRLOG(err, "register BD at AREN input port");
    }
  }

  OMX_LOG_FUNCTION_EXIT;
  return static_cast<OMX_ERRORTYPE>(err);
!!!11106572.cpp!!!	unregisterBds(inout port : OmxAmpAudioPort) : OMX_ERRORTYPE
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  AMP_BD_ST *bd;
  UINT32 uiPortIdx = 0;

  for (OMX_U32 i = 0; i < port->getBufferCount(); i++) {
    bd = port->getBD(i);
    if (NULL != bd) {
      AMP_RPC(err, AMP_AREN_UnregisterBD, mAmpHandle, AMP_PORT_INPUT,
          uiPortIdx, bd);
      CHECKAMPERRLOG(err, "unregsiter BDs at AREN input port");
    }
  }

  OMX_LOG_FUNCTION_EXIT;
  return OMX_ErrorNone;
!!!11106700.cpp!!!	pushBufferLoop() : void
  OMX_LOG_FUNCTION_ENTER;
  AMP_BD_ST *in_buf = NULL, *out_buf = NULL;
  OMX_BUFFERHEADERTYPE *in_head = NULL, *out_head = NULL;
  OMX_BOOL isCaching = OMX_FALSE;
Loop_start:
  while (!mShouldExit) {
    while (!mInputPort->isEmpty() || mCachedhead != NULL) {
      if (NULL != mCachedhead) {
        OMX_LOGV("Got input buffer %p", in_head);
        in_head = mCachedhead;
        isCaching = OMX_TRUE;
        OMX_LOGV("Use the cached input buffer %p", in_head);
      } else {
        in_head = mInputPort->popBuffer();
        if (mPool != NULL) {
          mCachedhead = in_head;
          isCaching = OMX_FALSE;
        }
        OMX_LOGV("Got input buffer %p", in_head);
      }
      if (NULL != in_head) {
        if (mInputPort->isFlushing()) {
          OMX_LOGD("Return input buffer when flushing");
          returnBuffer(mInputPort, in_head);
          in_head = NULL;
          mCachedhead = NULL;
          continue;
        }
        if (in_head->nFlags & OMX_BUFFERFLAG_EOS) {
          OMX_LOGD("Meet EOS Frame, wait for stop");
          mEOS = OMX_TRUE;
        }
        AmpBuffer *amp_buffer = static_cast<AmpBuffer *>(
            in_head->pPlatformPrivate);
        if (amp_buffer) {
          if (isCaching != OMX_TRUE && mEndian == 0) {
            OMX_U8 convert_endian;
            OMX_U32 convert_index = 0;
            OMX_U8 *pData = in_head->pBuffer + in_head->nOffset;
            for (; convert_index < in_head->nFilledLen; convert_index += 2) {
              convert_endian = pData[convert_index];
              pData[convert_index] = pData[convert_index + 1];
              pData[convert_index + 1] = convert_endian;
            }
          }
          // dump es data
          MEDIA_S8 value[MEDIA_VALUE_LENGTH];
          if (isCaching != OMX_TRUE && mediainfo_get_property(
              reinterpret_cast<const MEDIA_S8 *>(
              "mediainfo_dump_audio_es_data"), value) &&
              kdMemcmp(value, "1", 1) == 0) {
            mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_ES,
                in_head->pBuffer + in_head->nOffset, in_head->nFilledLen);
          }
          if (mPool != NULL) {
            UINT32 ret;
            ret = requestCbufBd();
            if (AMPCBUF_LACKBD == ret) {
              OMX_LOGV("Cbuf Lack of Bd, waitting.");
              usleep(kDefaultSleepTime);
              continue;
            }
            pushCbufBd(in_head);
            // request the EOS bd and push to ADEC
            if (mEOS == OMX_TRUE) {
              requestCbufBd();
            }
          } else {
            // Push BD to AMP.
            amp_buffer->updateAVSPts(in_head, mStreamPosition);
            amp_buffer->updateAudioFrameInfo(in_head);
            mInputFrameNum++;
          }
          if (isCaching != OMX_TRUE) {
            mStreamPosition += in_head->nFilledLen;
            OMX_LOGD("<In>, size = %d, pts = %lld, flag = 0x%x, total len = %d",
                in_head->nFilledLen, in_head->nTimeStamp, in_head->nFlags,
                mStreamPosition);
          }
          if (mPool == NULL) {
            pushAmpBd(AMP_PORT_INPUT, kAMPPortStartNumber + 1, amp_buffer->getBD());
          }
        }
      }
    }
    usleep(kDefaultSleepTime);
  }

  if (mPaused) {
    kdThreadMutexLock(mPauseLock);
    kdThreadCondWait(mPauseCond, mPauseLock);
    kdThreadMutexUnlock(mPauseLock);
    goto Loop_start;
  }

  OMX_LOG_FUNCTION_EXIT;
  return;
!!!11106828.cpp!!!	pushCbufBd(inout in_head : OMX_BUFFERHEADERTYPE) : void
  UINT32 ret, offset;
  OMX_U32 flag = (in_head->nFlags & OMX_BUFFERFLAG_EOS) ?
                AMP_MEMINFO_FLAG_EOS_MASK : 0;
  ret = AMP_CBUFWriteData(mPool, in_head->pBuffer + in_head->nOffset,
      in_head->nFilledLen, flag, &offset);
  if (AMPCBUF_SUCCESS == ret) {
    AMP_BDTAG_AVS_PTS pts_tag;
    kdMemset(&pts_tag, 0, sizeof(AMP_BDTAG_AVS_PTS));
    pts_tag.Header = {AMP_BDTAG_SYNC_PTS_META, sizeof(AMP_BDTAG_AVS_PTS)};
    convertUsto90K(in_head->nTimeStamp, &pts_tag.uPtsHigh, &pts_tag.uPtsLow);
    AMP_CBUFInsertTag(mPool, reinterpret_cast<UINT8 *>(&pts_tag), offset);
    AMP_SHM_HANDLE mShm;
    AMP_CBUFGetShm(mPool, &mShm);
    AMP_BDTAG_AUD_FRAME_INFO audio_frame_tag;
    kdMemset(&audio_frame_tag, 0, sizeof(AMP_BDTAG_AUD_FRAME_INFO));
    audio_frame_tag.Header = {AMP_BDTAG_AUD_FRAME_CTRL,
        sizeof(AMP_BDTAG_AUD_FRAME_INFO)};
    audio_frame_tag.uBufNr = mNumChannels;
    audio_frame_tag.uBitDepth = mBitPerSample;
    audio_frame_tag.uSampleRate = mSamplingRate;
    audio_frame_tag.uMemHandle = mShm;
    audio_frame_tag.uDataLength = in_head->nFilledLen;
    audio_frame_tag.uSize = in_head->nFilledLen;
    if (in_head->nFlags & OMX_BUFFERFLAG_EOS) {
      audio_frame_tag.uFlag |= AMP_MEMINFO_FLAG_EOS_MASK;
      OMX_LOGD("AREN meet EOS frame");
    }
    audio_frame_tag.uDataLength = in_head->nFilledLen;
    audio_frame_tag.uMemOffset[0] = offset;
    AMP_CBUFInsertTag(mPool, reinterpret_cast<UINT8 *>(
        &audio_frame_tag), offset);
    returnBuffer(mInputPort, in_head);
    mCachedhead = NULL;
    mInBDBackNum++;
  } else if (AMPCBUF_LACKSPACE == ret) {
    OMX_LOGV("Cbuf Lack of space.");
    mInputFrameNum--;
  } else {
    OMX_LOGE("Cbuf already Reached Eos!");
    returnBuffer(mInputPort, in_head);
    mCachedhead = NULL;
    mInBDBackNum++;
  }
!!!11106956.cpp!!!	requestCbufBd() : UINT32
  AMP_BD_ST *bd;
  UINT32 ret, offset, framesize;
  ret = AMP_CBUFRequest(mPool, &bd, &offset, &framesize);
  if (AMPCBUF_SUCCESS == ret) {
    mPushedBdNum++;
    OMX_LOGD("Cbuf <%u/%u> Push Bd to Amp: offset %u  size %u", mReturnedBdNum,
        mPushedBdNum, offset, framesize);
    pushAmpBd(AMP_PORT_INPUT, kAMPPortStartNumber + 1, bd);
    // dump cbuf es data
    MEDIA_S8 value[MEDIA_VALUE_LENGTH];
    if (mediainfo_get_property(
        reinterpret_cast<const MEDIA_S8 *>(
        "mediainfo_dump_audio_cbuf_es_data"), value) &&
        kdMemcmp(value, "1", 1) == 0) {
      AMP_SHM_HANDLE mshm;
      AMP_CBUFGetShm(mPool, &mshm);
      void *pVirAddr = NULL;
      AMP_SHM_GetVirtualAddress(mshm, 0, &pVirAddr);
      mediainfo_dump_data(MEDIA_AUDIO, MEDIA_DUMP_ES,
          reinterpret_cast<OMX_U8 *>(pVirAddr) + offset, framesize);
    }
  } else if (AMPCBUF_LACKBD == ret) {
    OMX_LOGV("Cbuf Lack of Bd, waitting.");
  } else if (AMPCBUF_LACKDATA == ret) {
    OMX_LOGV("Cbuf Lack of Data, waitting.");
  } else {
    OMX_LOGD("Cbuf Request Bd err %d.", ret);
  }
  return ret;
!!!11107084.cpp!!!	setPassThruMode() : void
  OMX_LOGD("set aren passthru");
  mPassthru = OMX_TRUE;
!!!11107212.cpp!!!	threadEntry(inout args : void) : void
  OmxAmpAudioRenderer *arender = (OmxAmpAudioRenderer *)args;
  if (arender) {
    arender->pushBufferLoop();
  }
  return NULL;
!!!11107340.cpp!!!	createComponent(inout handle : OMX_HANDLETYPE, in componentName : OMX_STRING, in appData : OMX_PTR, inout callBacks : OMX_CALLBACKTYPE) : OMX_ERRORTYPE
  OMX_LOGD("ENTER");
  OmxAmpAudioRenderer* comp = new OmxAmpAudioRenderer(componentName);
  *handle = comp->makeComponent(comp);
  comp->setCallbacks(callBacks, appData);
  comp->componentInit();
  OMX_LOGD("EXIT");
  return OMX_ErrorNone;
!!!11107468.cpp!!!	pushBufferDone(in component : AMP_COMPONENT, in port_Io : AMP_PORT_IO, in port_idx : UINT32, inout bd : AMP_BD_ST, inout context : void) : HRESULT
  HRESULT result;
  OMX_BUFFERHEADERTYPE *buf_header = NULL;
  OmxAmpAudioRenderer *renderer = static_cast<OmxAmpAudioRenderer *>(context);

  if (OMX_DirInput == port_Io) {
    if (NULL != renderer->mPool) {
      OMX_U32 ret;
      ret = AMP_CBUFRelease(renderer->mPool, bd);
      if (AMPCBUF_SUCCESS == ret) {
        renderer->mReturnedBdNum++;
        OMX_LOGD("Cbuf [%u/%u] Return Bd from Amp", renderer->mReturnedBdNum,
            renderer->mPushedBdNum);
      } else {
        OMX_LOGE("Cbuf Release Bd error %u.", ret);
      }
      return SUCCESS;
    }
    buf_header = (static_cast<OmxAmpAudioPort *>(renderer->mInputPort))
        ->getBufferHeader(bd);
    if (NULL != buf_header) {
      renderer->mInBDBackNum++;
      renderer->returnBuffer(renderer->mInputPort, buf_header);
    }
    OMX_LOGD("[In] done");
  }

  return SUCCESS;
!!!11107852.cpp!!!	setAmpState(in state : AMP_STATE) : OMX_ERRORTYPE
  OMX_LOGD("state = %s(%d)", AmpState2String(state), state);
  HRESULT err = SUCCESS;
  AMP_RPC(err, AMP_AREN_SetState, mAmpHandle, state);
  CHECK_AMP_RETURN_VAL(err, "set AREN state");
  return static_cast<OMX_ERRORTYPE>(err);
!!!11107980.cpp!!!	getAmpState(inout state : AMP_STATE) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_RPC(err, AMP_AREN_GetState, mAmpHandle, state);
  CHECK_AMP_RETURN_VAL(err, "get AREN state");
  OMX_LOGD("state = %s(%d)", AmpState2String(*state), *state);
  return static_cast<OMX_ERRORTYPE>(err);
!!!11108108.cpp!!!	connectSoundService() : OMX_ERRORTYPE
  HRESULT err = SUCCESS;

  // Init AMP sound service.
  err = AMP_SND_Init();
  CHECK_AMP_RETURN_VAL(err, "init amp sound service");

  // Connect ARen's output port and sound service.
  if (mPassthru == OMX_TRUE) {
    for (OMX_U32 app_index = 0; app_index < AREN_PASSTHRU_OUTPUT_PORT_NUM;
        app_index ++) {
      err = AMP_SND_SetupTunnel(mAmpHandle, app_index,
          &mSndSrvTunnel[app_index]);
      CHECK_AMP_RETURN_VAL(err, "connect ARen and sound service success");
    }
  } else {
    err = AMP_SND_SetupTunnel(mAmpHandle, kAMPPortStartNumber,
        &mSndSrvTunnel[0]);
    CHECK_AMP_RETURN_VAL(err, "connect ARen and sound service success");
  }
  return OMX_ErrorNone;
!!!11108236.cpp!!!	connectADecAudioPort(in connect : OMX_BOOL) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;

  if (NULL == mInputPort) {
    OMX_LOGE("The input port is not created.");
    return OMX_ErrorComponentNotFound;
  }
  OMX_HANDLETYPE handle = mInputPort->getTunnelComponent();
  if (NULL == handle) {
    OMX_LOGE("The Tunnel Component is not exist.");
    return OMX_ErrorComponentNotFound;
  }
  AMP_COMPONENT amp_ADec_handle = static_cast<OmxComponentImpl *>(
      reinterpret_cast<OMX_COMPONENTTYPE *>(handle)->pComponentPrivate)->getAmpHandle();
  if (NULL == amp_ADec_handle) {
    OMX_LOGE("Get tunnel amp component NULL.");
    return OMX_ErrorComponentNotFound;
  }
  if (mPassthru == OMX_TRUE) {
    // query information about ADEC component
    AMP_COMPONENT_INFO adec_cmp_info;
    kdMemset(&adec_cmp_info, 0, sizeof(adec_cmp_info));
    AMP_PORT_INFO adec_port_info;
    kdMemset(&adec_port_info, 0, sizeof(adec_port_info));
    AMP_RPC(err, AMP_ADEC_QueryInfo, amp_ADec_handle, &adec_cmp_info);
    CHECKAMPERRLOG(err, "AMP_ADEC_QueryInfo() failed!");

    // query information about AREN component
    AMP_COMPONENT_INFO aren_cmp_info;
    kdMemset(&aren_cmp_info, 0, sizeof(aren_cmp_info));
    AMP_PORT_INFO aren_port_info;
    kdMemset(&aren_port_info, 0, sizeof(aren_port_info));
    AMP_RPC(err, AMP_AREN_QueryInfo, mAmpHandle, &aren_cmp_info);
    CHECKAMPERRLOG(err, "AMP_AREN_QueryInfo() failed!");

    // connect adec and aren
    for (OMX_S32 adec_index = 0; adec_index < adec_cmp_info.uiOutputPortNum;
        adec_index++) {
      AMP_RPC(err, AMP_ADEC_QueryPort, amp_ADec_handle, AMP_PORT_OUTPUT, adec_index,
          &adec_port_info);
      CHECKAMPERRLOG(err, "AMP_ADEC_QueryPort() failed!");
      for (OMX_S32 aren_index = 0; aren_index < aren_cmp_info.uiInputPortNum;
          aren_index++) {
        AMP_RPC(err, AMP_AREN_QueryPort, mAmpHandle, AMP_PORT_INPUT, aren_index,
            &aren_port_info);
        CHECKAMPERRLOG(err, "AMP_AREN_QueryPort() failed!");
        if ((adec_port_info.ePortType == AMP_PORT_ADEC_OUT_PCM &&
            aren_port_info.ePortType == AMP_PORT_AREN_IN_PCM) ||
            ((adec_port_info.ePortType == AMP_PORT_ADEC_OUT_SPDIF &&
            aren_port_info.ePortType == AMP_PORT_AREN_IN_SPDIF)) ||
            ((adec_port_info.ePortType == AMP_PORT_ADEC_OUT_HDMI &&
            aren_port_info.ePortType == AMP_PORT_AREN_IN_HDMI))) {
          err = AMP_ConnectComp(amp_ADec_handle, adec_index, mAmpHandle, aren_index);
          CHECK_AMP_RETURN_VAL(err, "set up tunnel between ADec and ARen success");
        }
      }
    }
  } else {
    err = AMP_ConnectComp(amp_ADec_handle, kAMPPortStartNumber,
        mAmpHandle, kAMPPortStartNumber + 1);
    CHECK_AMP_RETURN_VAL(err, "set up tunnel between ADec and ARen success");
  }

  return OMX_ErrorNone;
!!!11108364.cpp!!!	connectClockPort(in connect : OMX_BOOL) : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_AREN_PARAST ArenParaSt;
  OMX_HANDLETYPE handle = NULL;

  if (NULL == mClockPort) {
    OMX_LOGE("The clock port is not created.");
    return OMX_ErrorComponentNotFound;
  }

  handle = mClockPort->getTunnelComponent();
  if (NULL == handle) {
    OMX_LOGE("The Tunnel Component is not exist.");
    return OMX_ErrorComponentNotFound;
  }
  AMP_COMPONENT amp_clock_handle = static_cast<OmxComponentImpl *>(
      reinterpret_cast<OMX_COMPONENTTYPE *>(handle)->pComponentPrivate)->getAmpHandle();
  if (NULL == amp_clock_handle) {
    OMX_LOGE("Get tunnel amp component NULL.");
    return OMX_ErrorComponentNotFound;
  }

  if (mPassthru == OMX_TRUE) {
    AMP_COMPONENT_INFO aren_cmp_info;
    kdMemset(&aren_cmp_info, 0, sizeof(aren_cmp_info));
    AMP_PORT_INFO aren_port_info;
    kdMemset(&aren_port_info, 0, sizeof(aren_port_info));
    AMP_RPC(err, AMP_AREN_QueryInfo, mAmpHandle, &aren_cmp_info);
    CHECKAMPERRLOG(err, "AMP_AREN_QueryInfo() failed!");

    OMX_U32 clk_output_idx = 0;
    for (OMX_S32 aren_index = 0; aren_index < AREN_PASSTHRU_OUTPUT_PORT_NUM;
        aren_index++) {
      AMP_RPC(err, AMP_AREN_QueryPort, mAmpHandle, AMP_PORT_INPUT, aren_index,
          &aren_port_info);
      CHECKAMPERRLOG(err, "AMP_AREN_QueryPort() failed!");

      if (aren_port_info.ePortType != AMP_PORT_AREN_IN_CLOCK) {
        OMX_LOGD("Ignore AREN input port %d ePortType:%d",
            aren_index, aren_port_info.ePortType);
        continue;
      }
      if (connect == OMX_TRUE) {
        err = AMP_ConnectComp(amp_clock_handle, clk_output_idx,
            mAmpHandle, aren_index);
        CHECK_AMP_RETURN_VAL(err, "connect CLK & AREN");
      } else {
        err = AMP_DisconnectComp(amp_clock_handle, clk_output_idx,
            mAmpHandle, aren_index);
        CHECK_AMP_RETURN_VAL(err, "disconnect CLK & AREN");
      }
      if (connect == OMX_TRUE) {
        // Associate ARen's data input port to clock port.
        kdMemset(&ArenParaSt, 0x00, sizeof(AMP_AREN_PARAST));
        ArenParaSt._d = AMP_AREN_PARAIDX_PORTASSOCCLK;
        ArenParaSt._u.PORTASSOCCLK.uiAssocIdx = clk_output_idx;
        AMP_RPC(err, AMP_AREN_SetPortParameter, mAmpHandle, AMP_PORT_INPUT,
            AREN_PASSTHRU_OUTPUT_PORT_NUM + aren_index,
            AMP_AREN_PARAIDX_PORTASSOCCLK, &ArenParaSt);
        CHECK_AMP_RETURN_VAL(err,
            "set AREN port parameter AMP_AREN_PARAIDX_PORTASSOCCLK");
      }
      clk_output_idx ++;
    }
  } else {
    if (connect == OMX_TRUE) {
      // ARen connect to AMP clock's first port
      err = AMP_ConnectComp(amp_clock_handle, kAMPPortStartNumber + 1,
          mAmpHandle, kAMPPortStartNumber);
      CHECK_AMP_RETURN_VAL(err, "connect CLK & AREN");

      // Associate ARen's data input port to clock port.
      kdMemset(&ArenParaSt, 0x00, sizeof(AMP_AREN_PARAST));
      ArenParaSt._d = AMP_AREN_PARAIDX_PORTASSOCCLK;
      ArenParaSt._u.PORTASSOCCLK.uiAssocIdx = 0;
      AMP_RPC(err, AMP_AREN_SetPortParameter, mAmpHandle, AMP_PORT_INPUT, 1,
              AMP_AREN_PARAIDX_PORTASSOCCLK, &ArenParaSt);
      CHECK_AMP_RETURN_VAL(err,
          "set AREN port parameter AMP_AREN_PARAIDX_PORTASSOCCLK");
    } else {
      err = AMP_DisconnectComp(amp_clock_handle, kAMPPortStartNumber + 1,
          mAmpHandle, kAMPPortStartNumber);
      CHECK_AMP_RETURN_VAL(err, "disconnect CLK & AREN");
    }
  }
  return OMX_ErrorNone;
!!!11108492.cpp!!!	registerEvent(in event : AMP_EVENT_CODE) : HRESULT
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }
  err = AMP_Event_RegisterCallback(mListener, event, eventHandle,
      static_cast<void *>(this));
  CHECK_AMP_RETURN_VAL(err, "register AREN notify");

  if (!err) {
    AMP_RPC(err, AMP_AREN_RegisterNotify, mAmpHandle,
        AMP_Event_GetServiceID(mListener), event);
    CHECK_AMP_RETURN_VAL(err, "register AREN callback");
  }
  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11108620.cpp!!!	unRegisterEvent(in event : AMP_EVENT_CODE) : HRESULT
  OMX_LOG_FUNCTION_ENTER;
  HRESULT err = SUCCESS;
  if (!mListener) {
    OMX_LOGE("mListener is not created yet.");
  }
  AMP_RPC(err, AMP_AREN_UnregisterNotify, mAmpHandle,
      AMP_Event_GetServiceID(mListener), event);
  CHECK_AMP_RETURN_VAL(err, "unregister AREN notify");

  if (!err) {
    err = AMP_Event_UnregisterCallback(mListener, event, eventHandle);
    CHECK_AMP_RETURN_VAL(err, "unregister AREN callback");
  }

  OMX_LOG_FUNCTION_EXIT;
  return err;
!!!11108748.cpp!!!	eventHandle(in hListener : HANDLE, inout pEvent : AMP_EVENT, inout pUserData : VOID) : HRESULT
  if (!pEvent) {
    OMX_LOGE("pEvent is NULL!");
    return !SUCCESS;
  }

  if (AMP_EVENT_API_AREN_CALLBACK == pEvent->stEventHead.eEventCode) {
      OmxAmpAudioRenderer *pComp = static_cast<OmxAmpAudioRenderer *>(pUserData);
      if (pComp) {
        OMX_LOGD("Receive EOS from audio render");
        pComp->postEvent(OMX_EventBufferFlag, kAudioPortStartNumber,
             OMX_BUFFERFLAG_EOS);
      }
  }

  return SUCCESS;
!!!11108876.cpp!!!	initAQ() : void
  OMX_LOG_FUNCTION_ENTER;
  String8 FILE_SOURCE_URI;
  char ktmp[80] ;
  status_t ret;
  static const char* const kAudioSourcePrefix = "audio://localhost?channel=";
  mAudioChannel = getAudioChannel();
  // TODO:some audio streams can't play by mooplayer but also use OMX.
  // In this case, it can't get RM and mAudioChannel = 0. AVSeting set the
  // audio channel is -0xff. it can use source_constants.h after chao's
  // code was merged: const int AUDIO_SOURCE_NONE_ID = -0xff;
  if ( 0 == mAudioChannel)
    mAudioChannel = - 0xff;

  mSourceControl = new SourceControl();
  if (NULL != mSourceControl) {
    sprintf(ktmp, "%s%d", kAudioSourcePrefix, mAudioChannel);
    FILE_SOURCE_URI = String8(ktmp);

    mSourceControl->getSourceByUri(FILE_SOURCE_URI, &mSourceId);
    OMX_LOGD("get sourceid :%d, sourceURL :%s", mSourceId, FILE_SOURCE_URI.string());
    if ( -1 != mSourceId) {
      mSourceControl->getSourceGain(mSourceId, &mPhySourceGain);
      OMX_LOGD("get sourGain = %0x", mPhySourceGain);
      mOutputControl = new OutputControl();
      // After being registered , when AVSeting  changes SoureGain value ,
      // OMX can get it by OnSettingUpdate() at once.
      if (NULL != mOutputControl) {
        mObserver = new AVSettingObserver(*this);
        ret = mOutputControl ->registerObserver("mrvl.output", mObserver);
        if (android::OK != ret) {
          OMX_LOGE("rigister Observer failed !!!");
        }
      }
    } else {
      OMX_LOGD("get source ID failed.");
    }
  }
  OMX_LOG_FUNCTION_EXIT;
!!!11109004.cpp!!!	getAudioChannel() : OMX_S32
#if (defined(OMX_IndexExt_h) && defined(_OMX_GTV_))
    if (mResourceInfo.nResourceSize > 0) {
      OMX_LOGD("Resouce size %d, value 0x%x",
          mResourceInfo.nResourceSize, mResourceInfo.nResource[0]);
      return mResourceInfo.nResource[0];
    }
#endif
    return 0;
!!!11109132.cpp!!!	setMixGain() : OMX_ERRORTYPE
  HRESULT err = SUCCESS;
  AMP_APP_PARAMIXGAIN stMixerGain;
  if ((mPhySourceGain > 0) && (OMX_TRUE == mIsSnsConnect)) {
    stMixerGain.uiLeftGain = mPhySourceGain;
    stMixerGain.uiRghtGain = mPhySourceGain;
    stMixerGain.uiCntrGain = mPhySourceGain;
    stMixerGain.uiLeftSndGain = mPhySourceGain;
    stMixerGain.uiRghtSndGain = mPhySourceGain;
    stMixerGain.uiLfeGain = mPhySourceGain;
    stMixerGain.uiLeftRearGain = mPhySourceGain;
    stMixerGain.uiRhgtRearGain = mPhySourceGain;
    OMX_LOGD("Set MixGain : %ld", mPhySourceGain);
    err = AMP_SND_SetMixerGain(mSndSrvTunnel[0], &stMixerGain);
    CHECK_AMP_RETURN_VAL(err,"set source service MixerGain");
  }
  return OMX_ErrorNone;
