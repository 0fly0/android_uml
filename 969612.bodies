class WebViewCore
!!!5083276.java!!!	WebViewCore(inout context : Context, inout w : WebViewClassic, inout proxy : CallbackProxy, inout javascriptInterfaces : Map<String, Object>)
        // No need to assign this in the WebCore thread.
        mCallbackProxy = proxy;
        mWebViewClassic = w;
        mJavascriptInterfaces = javascriptInterfaces;
        // This context object is used to initialize the WebViewCore during
        // subwindow creation.
        mContext = context;

        // We need to wait for the initial thread creation before sending
        // a message to the WebCore thread.
        // XXX: This is the only time the UI thread will wait for the WebCore
        // thread!
        synchronized (WebViewCore.class) {
            if (sWebCoreHandler == null) {
                // Create a global thread and start it.
                Thread t = new Thread(new WebCoreThread());
                t.setName(THREAD_NAME);
                t.start();
                try {
                    WebViewCore.class.wait();
                } catch (InterruptedException e) {
                    Log.e(LOGTAG, "Caught exception while waiting for thread " +
                           "creation.");
                    Log.e(LOGTAG, Log.getStackTraceString(e));
                }

                if (sShouldMonitorWebCoreThread) {
                    // Start the singleton watchdog which will monitor the WebCore thread
                    // to verify it's still processing messages. Note that this is the only
                    // time we need to check the value as all the other public methods on
                    // the WebCoreThreadWatchdog are no-ops if start() is not called.
                    WebCoreThreadWatchdog.start(sWebCoreHandler);
                }
            }
            // Make sure the Watchdog is aware of this new WebView.
            WebCoreThreadWatchdog.registerWebView(w);
        }
        // Create an EventHub to handle messages before and after the thread is
        // ready.
        mEventHub = new EventHub();
        // Create a WebSettings object for maintaining all settings
        mSettings = new WebSettingsClassic(mContext, mWebViewClassic);
        // The WebIconDatabase needs to be initialized within the UI thread so
        // just request the instance here.
        WebIconDatabase.getInstance();
        // Create the WebStorageClassic singleton and the UI handler
        WebStorageClassic.getInstance().createUIHandler();
        // Create the UI handler for GeolocationPermissions
        GeolocationPermissionsClassic.getInstance().createUIHandler();

        // Get the memory class of the current device. V8 will use these values
        // to GC more effectively.
        ActivityManager manager = (ActivityManager) mContext.getSystemService(
                Context.ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memInfo = new ActivityManager.MemoryInfo();
        manager.getMemoryInfo(memInfo);

        // Allow us to use up to our memory class value before V8's GC kicks in.
        // These values have been determined by experimentation.
        mLowMemoryUsageThresholdMb = manager.getLargeMemoryClass();
        mHighMemoryUsageThresholdMb = (int) (mLowMemoryUsageThresholdMb * 1.5);
        // Avoid constant V8 GC when memory usage equals to working set estimate.
        mHighUsageDeltaMb = mLowMemoryUsageThresholdMb / 32;

        // Send a message to initialize the WebViewCore.
        Message init = sWebCoreHandler.obtainMessage(
                WebCoreThread.INITIALIZE, this);
        sWebCoreHandler.sendMessage(init);
!!!5083404.java!!!	initialize() : void
        /* Initialize our private BrowserFrame class to handle all
         * frame-related functions. We need to create a new view which
         * in turn creates a C level FrameView and attaches it to the frame.
         */
        mBrowserFrame = new BrowserFrame(mContext, this, mCallbackProxy,
                mSettings, mJavascriptInterfaces);
        mJavascriptInterfaces = null;
        // Sync the native settings and also create the WebCore thread handler.
        mSettings.syncSettingsAndCreateHandler(mBrowserFrame);
        // Create the handler and transfer messages for the IconDatabase
        WebIconDatabaseClassic.getInstance().createHandler();
        // Create the handler for WebStorageClassic
        WebStorageClassic.getInstance().createHandler();
        // Create the handler for GeolocationPermissions.
        GeolocationPermissionsClassic.getInstance().createHandler();
        // The transferMessages call will transfer all pending messages to the
        // WebCore thread handler.
        mEventHub.transferMessages();

        // Send a message back to WebView to tell it that we have set up the
        // WebCore thread.
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.WEBCORE_INITIALIZED_MSG_ID,
                    mNativeClass, 0).sendToTarget();
        }

!!!5083532.java!!!	initializeSubwindow() : void
        // Go ahead and initialize the core components.
        initialize();
        // Remove the INITIALIZE method so we don't try to initialize twice.
        sWebCoreHandler.removeMessages(WebCoreThread.INITIALIZE, this);
!!!5083660.java!!!	getBrowserFrame() : BrowserFrame
        return mBrowserFrame;
!!!5083788.java!!!	getInputDispatcherCallbacks() : WebKitCallbacks
        return mEventHub;
!!!5083916.java!!!	pauseTimers() : void
        if (BrowserFrame.sJavaBridge == null) {
            throw new IllegalStateException(
                    "No WebView has been created in this process!");
        }
        BrowserFrame.sJavaBridge.pause();
!!!5084044.java!!!	resumeTimers() : void
        if (BrowserFrame.sJavaBridge == null) {
            throw new IllegalStateException(
                    "No WebView has been created in this process!");
        }
        BrowserFrame.sJavaBridge.resume();
!!!5084172.java!!!	getSettings() : WebSettingsClassic
        return mSettings;
!!!5084300.java!!!	isSupportedMediaMimeType(in mimeType : String) : boolean
        int fileType = MediaFile.getFileTypeForMimeType(mimeType);
        return MediaFile.isAudioFileType(fileType)
            || MediaFile.isVideoFileType(fileType)
            || MediaFile.isPlayListFileType(fileType)
            // The following is not in Media framework, but it's supported.
            || (mimeType != null && mimeType.startsWith("video/m4v"));
!!!5084428.java!!!	addMessageToConsole(in message : String, in lineNumber : int, in sourceID : String, in msgLevel : int) : void
        mCallbackProxy.addMessageToConsole(message, lineNumber, sourceID, msgLevel);
!!!5084556.java!!!	jsAlert(in url : String, in message : String) : void
        mCallbackProxy.onJsAlert(url, message);
!!!5084684.java!!!	focusNodeChanged(in nodePointer : int, inout hitTest : WebKitHitTest) : void
        if (mWebViewClassic == null) return;
        mWebViewClassic.mPrivateHandler.obtainMessage(WebViewClassic.FOCUS_NODE_CHANGED,
                nodePointer, 0, hitTest).sendToTarget();
!!!5084812.java!!!	chromeTakeFocus(in webkitDirection : int) : void
        if (mWebViewClassic == null) return;
        Message m = mWebViewClassic.mPrivateHandler.obtainMessage(
                WebViewClassic.TAKE_FOCUS);
        m.arg1 = mapDirection(webkitDirection);
        m.sendToTarget();
!!!5084940.java!!!	chromeCanTakeFocus(in webkitDirection : int) : boolean
        int direction = mapDirection(webkitDirection);
        return direction == mChromeCanFocusDirection && direction != 0;
!!!5085068.java!!!	mapDirection(in webkitDirection : int) : int
        /*
         * This is WebKit's FocusDirection enum (from FocusDirection.h)
        enum FocusDirection {
            FocusDirectionNone = 0,
            FocusDirectionForward,
            FocusDirectionBackward,
            FocusDirectionUp,
            FocusDirectionDown,
            FocusDirectionLeft,
            FocusDirectionRight
        };
         */
        switch (webkitDirection) {
        case 1:
            return View.FOCUS_FORWARD;
        case 2:
            return View.FOCUS_BACKWARD;
        case 3:
            return View.FOCUS_UP;
        case 4:
            return View.FOCUS_DOWN;
        case 5:
            return View.FOCUS_LEFT;
        case 6:
            return View.FOCUS_RIGHT;
        }
        return 0;
!!!5085196.java!!!	openFileChooser(in acceptType : String, in capture : String) : String
        Uri uri = mCallbackProxy.openFileChooser(acceptType, capture);
        if (uri != null) {
            String filePath = "";
            // Note - querying for MediaStore.Images.Media.DATA
            // seems to work for all content URIs, not just images
            Cursor cursor = mContext.getContentResolver().query(
                    uri,
                    new String[] { MediaStore.Images.Media.DATA },
                    null, null, null);
            if (cursor != null) {
                try {
                    if (cursor.moveToNext()) {
                        filePath = cursor.getString(0);
                    }
                } finally {
                    cursor.close();
                }
            } else {
                filePath = uri.getLastPathSegment();
            }
            String uriString = uri.toString();
            BrowserFrame.sJavaBridge.storeFilePathForContentUri(filePath, uriString);
            return uriString;
        }
        return "";
!!!5085324.java!!!	exceededDatabaseQuota(in url : String, in databaseIdentifier : String, in quota : long, in estimatedDatabaseSize : long) : void
        // Inform the callback proxy of the quota overflow. Send an object
        // that encapsulates a call to the nativeSetDatabaseQuota method to
        // awaken the sleeping webcore thread when a decision from the
        // client to allow or deny quota is available.
        mCallbackProxy.onExceededDatabaseQuota(url, databaseIdentifier,
                quota, estimatedDatabaseSize, getUsedQuota(),
                new WebStorage.QuotaUpdater() {
                        @Override
                        public void updateQuota(long newQuota) {
                            nativeSetNewStorageLimit(mNativeClass, newQuota);
                        }
                });
!!!5085452.java!!!	reachedMaxAppCacheSize(in requiredStorage : long, in maxSize : long) : void
        mCallbackProxy.onReachedMaxAppCacheSize(requiredStorage, maxSize,
                new WebStorage.QuotaUpdater() {
                    @Override
                    public void updateQuota(long newQuota) {
                        nativeSetNewStorageLimit(mNativeClass, newQuota);
                    }
                });
!!!5085580.java!!!	populateVisitedLinks() : void
        ValueCallback callback = new ValueCallback<String[]>() {
            @Override
            public void onReceiveValue(String[] value) {
                sendMessage(EventHub.POPULATE_VISITED_LINKS, (Object)value);
            }
        };
        mCallbackProxy.getVisitedHistory(callback);
!!!5085708.java!!!	geolocationPermissionsShowPrompt(in origin : String) : void
        mCallbackProxy.onGeolocationPermissionsShowPrompt(origin,
                new GeolocationPermissions.Callback() {
            @Override
            public void invoke(String origin, boolean allow, boolean remember) {
                GeolocationPermissionsData data = new GeolocationPermissionsData();
                data.mOrigin = origin;
                data.mAllow = allow;
                data.mRemember = remember;
                // Marshall to WebCore thread.
                sendMessage(EventHub.GEOLOCATION_PERMISSIONS_PROVIDE, data);
            }
        });
!!!5085836.java!!!	geolocationPermissionsHidePrompt() : void
        mCallbackProxy.onGeolocationPermissionsHidePrompt();
!!!5085964.java!!!	jsConfirm(in url : String, in message : String) : boolean
        return mCallbackProxy.onJsConfirm(url, message);
!!!5086092.java!!!	jsPrompt(in url : String, in message : String, in defaultValue : String) : String
        return mCallbackProxy.onJsPrompt(url, message, defaultValue);
!!!5086220.java!!!	jsUnload(in url : String, in message : String) : boolean
        return mCallbackProxy.onJsBeforeUnload(url, message);
!!!5086348.java!!!	jsInterrupt() : boolean
        return mCallbackProxy.onJsTimeout();
!!!5086476.java!!!	exitFullscreenVideo() : void
        if (mWebViewClassic == null) return;
        Message message = Message.obtain(mWebViewClassic.mPrivateHandler,
                       WebViewClassic.EXIT_FULLSCREEN_VIDEO);
        message.sendToTarget();
!!!5086604.java!!!	clearContent() : void
        nativeClearContent(mNativeClass);
!!!5093132.java!!!	stopLoading() : void
        if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "CORE stopLoading");
        if (mBrowserFrame != null) {
            mBrowserFrame.stopLoading();
        }
!!!5093260.java!!!	sendMessage(inout msg : Message) : void
        mEventHub.sendMessage(msg);
!!!5093388.java!!!	sendMessages(inout messages : ArrayList<Message>) : void
        synchronized (mEventHub) {
            for (int i = 0; i < messages.size(); i++) {
                mEventHub.sendMessage(messages.get(i));
            }
        }
!!!5093516.java!!!	sendMessage(in what : int) : void
        mEventHub.sendMessage(Message.obtain(null, what));
!!!5093644.java!!!	sendMessageAtFrontOfQueue(in what : int, in arg1 : int, in arg2 : int, inout obj : Object) : void
        mEventHub.sendMessageAtFrontOfQueue(Message.obtain(
                null, what, arg1, arg2, obj));
!!!5093772.java!!!	sendMessage(in what : int, inout obj : Object) : void
        mEventHub.sendMessage(Message.obtain(null, what, obj));
!!!5093900.java!!!	sendMessage(in what : int, in arg1 : int) : void
        // just ignore the second argument (make it 0)
        mEventHub.sendMessage(Message.obtain(null, what, arg1, 0));
!!!5094028.java!!!	sendMessage(in what : int, in arg1 : int, in arg2 : int) : void
        mEventHub.sendMessage(Message.obtain(null, what, arg1, arg2));
!!!5094156.java!!!	sendMessage(in what : int, in arg1 : int, inout obj : Object) : void
        // just ignore the second argument (make it 0)
        mEventHub.sendMessage(Message.obtain(null, what, arg1, 0, obj));
!!!5094284.java!!!	sendMessage(in what : int, in arg1 : int, in arg2 : int, inout obj : Object) : void
        mEventHub.sendMessage(Message.obtain(null, what, arg1, arg2, obj));
!!!5094412.java!!!	sendMessageAtFrontOfQueue(in what : int, inout obj : Object) : void
        mEventHub.sendMessageAtFrontOfQueue(Message.obtain(
                null, what, obj));
!!!5094540.java!!!	sendMessageDelayed(in what : int, inout obj : Object, in delay : long) : void
        mEventHub.sendMessageDelayed(Message.obtain(null, what, obj), delay);
!!!5094668.java!!!	removeMessages(in what : int) : void
        mEventHub.removeMessages(what);
!!!5094796.java!!!	removeMessages() : void
        mEventHub.removeMessages();
!!!5094924.java!!!	destroy() : void
        synchronized (mEventHub) {
            // send DESTROY to front of queue
            // PAUSE/RESUME timers will still be processed even if they get handled later
            mEventHub.mDestroying = true;
            mEventHub.sendMessageAtFrontOfQueue(
                    Message.obtain(null, EventHub.DESTROY));
            mEventHub.blockMessages();
            WebCoreThreadWatchdog.unregisterWebView(mWebViewClassic);
        }
!!!5095052.java!!!	performHitTest(in x : int, in y : int, in slop : int, inout moveMouse : boolean) : WebKitHitTest
        WebKitHitTest hit = nativeHitTest(mNativeClass, x, y, slop, moveMouse);
        hit.mHitTestX = x;
        hit.mHitTestY = y;
        hit.mHitTestSlop = slop;
        hit.mHitTestMovedMouse = moveMouse;
        return hit;
!!!5095180.java!!!	clearCache(inout includeDiskFiles : boolean) : void
        mBrowserFrame.clearCache();
        if (includeDiskFiles) {
            CacheManager.removeAllCacheFiles();
        }
!!!5095308.java!!!	loadUrl(in url : String, inout extraHeaders : Map<String, String>) : void
        if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, " CORE loadUrl " + url);
        mBrowserFrame.loadUrl(url, extraHeaders);
!!!5095436.java!!!	saveWebArchive(in filename : String, inout autoname : boolean) : String
        if (DebugFlags.WEB_VIEW_CORE) {
            Log.v(LOGTAG, " CORE saveWebArchive " + filename + " " + autoname);
        }
        return mBrowserFrame.saveWebArchive(filename, autoname);
!!!5095564.java!!!	key(inout evt : KeyEvent, in canTakeFocusDirection : int, inout isDown : boolean) : void
        if (DebugFlags.WEB_VIEW_CORE) {
            Log.v(LOGTAG, "CORE key at " + System.currentTimeMillis() + ", "
                    + evt);
        }
        mChromeCanFocusDirection = canTakeFocusDirection;
        int keyCode = evt.getKeyCode();
        int unicodeChar = evt.getUnicodeChar();

        if (keyCode == KeyEvent.KEYCODE_UNKNOWN && evt.getCharacters() != null
                && evt.getCharacters().length() > 0) {
            // we should only receive individual complex characters
            unicodeChar = evt.getCharacters().codePointAt(0);
        }

        boolean handled = nativeKey(mNativeClass, keyCode, unicodeChar, evt.getRepeatCount(),
                evt.isShiftPressed(), evt.isAltPressed(),
                evt.isSymPressed(), isDown);
        mChromeCanFocusDirection = 0;
        if (!handled && keyCode != KeyEvent.KEYCODE_ENTER) {
            if (keyCode >= KeyEvent.KEYCODE_DPAD_UP
                    && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
                if (canTakeFocusDirection != 0 && isDown) {
                    Message m = mWebViewClassic.mPrivateHandler.obtainMessage(
                            WebViewClassic.TAKE_FOCUS);
                    m.arg1 = canTakeFocusDirection;
                    m.sendToTarget();
                }
                return;
            }
            // bubble up the event handling
            // but do not bubble up the ENTER key, which would open the search
            // bar without any text.
            mCallbackProxy.onUnhandledKeyEvent(evt);
        }
!!!5095692.java!!!	keyPress(in unicodeChar : int) : void
        nativeKey(mNativeClass, 0, unicodeChar, 0, false, false, false, true);
        nativeKey(mNativeClass, 0, unicodeChar, 0, false, false, false, false);
!!!5095820.java!!!	viewSizeChanged(inout data : ViewSizeData) : void
        int w = data.mWidth;
        int h = data.mHeight;
        int textwrapWidth = data.mTextWrapWidth;
        float scale = data.mScale;
        if (DebugFlags.WEB_VIEW_CORE) {
            Log.v(LOGTAG, "viewSizeChanged w=" + w + "; h=" + h
                    + "; textwrapWidth=" + textwrapWidth + "; scale=" + scale);
        }
        if (w == 0) {
            Log.w(LOGTAG, "skip viewSizeChanged as w is 0");
            return;
        }
        int width = calculateWindowWidth(w);
        int height = h;
        if (width != w) {
            float heightWidthRatio = data.mHeightWidthRatio;
            float ratio = (heightWidthRatio > 0) ? heightWidthRatio : (float) h / w;
            height = Math.round(ratio * width);
        }
        int screenHeight = data.mActualViewHeight > 0 ? data.mActualViewHeight : h;
        nativeSetSize(mNativeClass, width, height, textwrapWidth, scale,
                w, screenHeight, data.mAnchorX, data.mAnchorY, data.mIgnoreHeight);
        // Remember the current width and height
        boolean needInvalidate = (mCurrentViewWidth == 0);
        mCurrentViewWidth = w;
        mCurrentViewHeight = h;
        mCurrentViewScale = scale;
        if (needInvalidate) {
            // ensure {@link #webkitDraw} is called as we were blocking in
            // {@link #contentDraw} when mCurrentViewWidth is 0
            if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "viewSizeChanged");
            contentDraw();
        }
!!!5095948.java!!!	calculateWindowWidth(in viewWidth : int) : int
        int width = viewWidth;
        if (mSettings.getUseWideViewPort()) {
            if (mViewportWidth == -1) {
                // Fixed viewport width.
                width = WebViewClassic.DEFAULT_VIEWPORT_WIDTH;
            } else if (mViewportWidth > 0) {
                // Use website specified or desired fixed viewport width.
                width = mViewportWidth;
            } else {
                // For mobile web site.
                width = Math.round(mWebViewClassic.getViewWidth() /
                        mWebViewClassic.getDefaultZoomScale());
            }
        }
        return width;
!!!5096076.java!!!	getUsedQuota() : long
        WebStorageClassic webStorage = WebStorageClassic.getInstance();
        Collection<WebStorage.Origin> origins = webStorage.getOriginsSync();

        if (origins == null) {
            return 0;
        }
        long usedQuota = 0;
        for (WebStorage.Origin website : origins) {
            usedQuota += website.getQuota();
        }
        return usedQuota;
!!!5096332.java!!!	pauseWebKitDraw() : void
        synchronized (m_skipDrawFlagLock) {
            if (!m_skipDrawFlag) {
                m_skipDrawFlag = true;
            }
        }
!!!5096460.java!!!	resumeWebKitDraw() : void
        synchronized (m_skipDrawFlagLock) {
            if (m_skipDrawFlag && m_drawWasSkipped) {
                // a draw was dropped, send a retry
                m_drawWasSkipped = false;
                mEventHub.sendMessage(Message.obtain(null, EventHub.WEBKIT_DRAW));
            }
            m_skipDrawFlag = false;
        }
!!!5096588.java!!!	webkitDraw() : void
        synchronized (m_skipDrawFlagLock) {
            if (m_skipDrawFlag) {
                m_drawWasSkipped = true;
                return;
            }
        }

        mDrawIsScheduled = false;
        DrawData draw = new DrawData();
        if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "webkitDraw start");
        draw.mBaseLayer = nativeRecordContent(mNativeClass, draw.mContentSize);
        if (draw.mBaseLayer == 0) {
            if (mWebViewClassic != null && !mWebViewClassic.isPaused()) {
                if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "webkitDraw abort, resending draw message");
                mEventHub.sendMessageDelayed(Message.obtain(null, EventHub.WEBKIT_DRAW), 10);
            } else {
                if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "webkitDraw abort, webview paused");
            }
            return;
        }
        mLastDrawData = draw;
        webkitDraw(draw);
!!!5096716.java!!!	webkitDraw(inout draw : DrawData) : void
        if (mWebViewClassic != null) {
            draw.mViewSize = new Point(mCurrentViewWidth, mCurrentViewHeight);
            if (mSettings.getUseWideViewPort()) {
                draw.mMinPrefWidth = Math.max(
                        mViewportWidth == -1 ? WebViewClassic.DEFAULT_VIEWPORT_WIDTH
                                : (mViewportWidth == 0 ? mCurrentViewWidth
                                        : mViewportWidth),
                        nativeGetContentMinPrefWidth(mNativeClass));
            }
            if (mInitialViewState != null) {
                draw.mViewState = mInitialViewState;
                mInitialViewState = null;
            }
            if (mFirstLayoutForNonStandardLoad) {
                draw.mFirstLayoutForNonStandardLoad = true;
                mFirstLayoutForNonStandardLoad = false;
            }
            if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "webkitDraw NEW_PICTURE_MSG_ID");
            pauseWebKitDraw();
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.NEW_PICTURE_MSG_ID, draw).sendToTarget();
        }
!!!5096844.java!!!	saveViewState(inout stream : OutputStream, inout callback : ValueCallback) : void
        // TODO: Create a native method to do this better without overloading
        // the draw path (and fix saving <canvas>)
        DrawData draw = new DrawData();
        if (DebugFlags.WEB_VIEW_CORE) Log.v(LOGTAG, "saveViewState start");
        draw.mBaseLayer = nativeRecordContent(mNativeClass, draw.mContentSize);
        boolean result = false;
        try {
            result = ViewStateSerializer.serializeViewState(stream, draw);
        } catch (Throwable t) {
            Log.w(LOGTAG, "Failed to save view state", t);
        }
        callback.onReceiveValue(result);
        if (draw.mBaseLayer != 0) {
            if (mDrawIsScheduled) {
                mDrawIsScheduled = false;
                mEventHub.removeMessages(EventHub.WEBKIT_DRAW);
            }
            mLastDrawData = draw;
            webkitDraw(draw);
        }
!!!5096972.java!!!	reducePriority() : void
        // remove the pending REDUCE_PRIORITY and RESUME_PRIORITY messages
        sWebCoreHandler.removeMessages(WebCoreThread.REDUCE_PRIORITY);
        sWebCoreHandler.removeMessages(WebCoreThread.RESUME_PRIORITY);
        sWebCoreHandler.sendMessageAtFrontOfQueue(sWebCoreHandler
                .obtainMessage(WebCoreThread.REDUCE_PRIORITY));
!!!5097100.java!!!	resumePriority() : void
        // remove the pending REDUCE_PRIORITY and RESUME_PRIORITY messages
        sWebCoreHandler.removeMessages(WebCoreThread.REDUCE_PRIORITY);
        sWebCoreHandler.removeMessages(WebCoreThread.RESUME_PRIORITY);
        sWebCoreHandler.sendMessageAtFrontOfQueue(sWebCoreHandler
                .obtainMessage(WebCoreThread.RESUME_PRIORITY));
!!!5097228.java!!!	sendStaticMessage(in messageType : int, inout argument : Object) : void
        if (sWebCoreHandler == null)
            return;

        sWebCoreHandler.sendMessage(sWebCoreHandler.obtainMessage(messageType, argument));
!!!5097356.java!!!	pauseUpdatePicture(inout core : WebViewCore) : void
        // Note: there is one possible failure mode. If pauseUpdatePicture() is
        // called from UI thread while WEBKIT_DRAW is just pulled out of the
        // queue in WebCore thread to be executed. Then update won't be blocked.
        if (core != null) {
            if (!core.getSettings().enableSmoothTransition()) return;

            synchronized (core) {
                if (core.mNativeClass == 0) {
                    Log.w(LOGTAG, "Cannot pauseUpdatePicture, core destroyed or not initialized!");
                    return;
                }
                core.mDrawIsPaused = true;
            }
        }

!!!5097484.java!!!	resumeUpdatePicture(inout core : WebViewCore) : void
        if (core != null) {
            // if mDrawIsPaused is true, ignore the setting, continue to resume
            if (!core.mDrawIsPaused)
                return;

            synchronized (core) {
                if (core.mNativeClass == 0) {
                    Log.w(LOGTAG, "Cannot resumeUpdatePicture, core destroyed!");
                    return;
                }
                core.mDrawIsPaused = false;
                // always redraw on resume to reenable gif animations
                core.mDrawIsScheduled = false;
            }
        }
!!!5097612.java!!!	isUpdatePicturePaused(inout core : WebViewCore) : boolean
        return core != null ? core.mDrawIsPaused : false;
!!!5097740.java!!!	restoreState(in index : int) : void
        WebBackForwardListClassic list = mCallbackProxy.getBackForwardList();
        int size = list.getSize();
        for (int i = 0; i < size; i++) {
            list.getItemAtIndex(i).inflate(mBrowserFrame.mNativeFrame);
        }
        mBrowserFrame.mLoadInitFromJava = true;
        WebBackForwardListClassic.restoreIndex(mBrowserFrame.mNativeFrame, index);
        mBrowserFrame.mLoadInitFromJava = false;
!!!5097868.java!!!	contentDraw() : void
        synchronized (this) {
            if (mWebViewClassic == null || mBrowserFrame == null) {
                // We were destroyed
                return;
            }
            // don't update the Picture until we have an initial width and finish
            // the first layout
            if (mCurrentViewWidth == 0 || !mBrowserFrame.firstLayoutDone()) {
                return;
            }
            // only fire an event if this is our first request
            if (mDrawIsScheduled) return;
            mDrawIsScheduled = true;
            mEventHub.sendMessage(Message.obtain(null, EventHub.WEBKIT_DRAW));
        }
!!!5097996.java!!!	contentScrollTo(in x : int, in y : int, inout animate : boolean, inout onlyIfImeIsShowing : boolean) : void
        if (!mBrowserFrame.firstLayoutDone()) {
            /*
             * WebKit restore state will be called before didFirstLayout(),
             * remember the position as it has to be applied after restoring
             * zoom factor which is controlled by screenWidth.
             */
            mRestoredX = x;
            mRestoredY = y;
            return;
        }
        if (mWebViewClassic != null) {
            Message msg = Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.SCROLL_TO_MSG_ID, animate ? 1 : 0,
                    onlyIfImeIsShowing ? 1 : 0, new Point(x, y));
            if (mDrawIsScheduled) {
                mEventHub.sendMessage(Message.obtain(null,
                        EventHub.MESSAGE_RELAY, msg));
            } else {
                msg.sendToTarget();
            }
        }
!!!5098124.java!!!	sendNotifyProgressFinished() : void
        contentDraw();
!!!5098252.java!!!	sendViewInvalidate(in left : int, in top : int, in right : int, in bottom : int) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                           WebViewClassic.INVAL_RECT_MSG_ID,
                           new Rect(left, top, right, bottom)).sendToTarget();
        }
!!!5098380.java!!!	signalRepaintDone() : void
        mRepaintScheduled = false;
!!!5098508.java!!!	getWebViewClassic() : WebViewClassic
        return mWebViewClassic;
!!!5098636.java!!!	getWebView() : WebView
        return mWebViewClassic.getWebView();
!!!5098764.java!!!	sendPluginDrawMsg() : void
        sendMessage(EventHub.PLUGIN_SURFACE_READY);
!!!5099020.java!!!	didFirstLayout(inout standardLoad : boolean) : void
        if (DebugFlags.WEB_VIEW_CORE) {
            Log.v(LOGTAG, "didFirstLayout standardLoad =" + standardLoad);
        }

        mBrowserFrame.didFirstLayout();

        if (mWebViewClassic == null) return;

        boolean updateViewState = standardLoad || mIsRestored;
        setupViewport(updateViewState);
        // if updateRestoreState is true, ViewManager.postReadyToDrawAll() will
        // be called after the WebView updates its state. If updateRestoreState
        // is false, start to draw now as it is ready.
        if (!updateViewState) {
            mWebViewClassic.mViewManager.postReadyToDrawAll();
        }

        // remove the touch highlight when moving to a new page
        mWebViewClassic.mPrivateHandler.sendEmptyMessage(
                WebViewClassic.HIT_TEST_RESULT);

        // reset the scroll position, the restored offset and scales
        mRestoredX = mRestoredY = 0;
        mIsRestored = false;
        mRestoredScale = mRestoredTextWrapScale = 0;
!!!5099148.java!!!	updateViewport() : void
        // Update viewport asap to make sure we get correct one.
        setupViewport(true);
!!!5099276.java!!!	getFixedDisplayDensity(inout context : Context) : float
        // We make bad assumptions about multiplying and dividing density by 100,
        // force them to be true with this hack
        float density = context.getResources().getDisplayMetrics().density;
        return ((int) (density * 100)) / 100.0f;
!!!5099404.java!!!	setupViewport(inout updateViewState : boolean) : void
        if (mWebViewClassic == null || mSettings == null) {
            // We've been destroyed or are being destroyed, return early
            return;
        }
        // set the viewport settings from WebKit
        setViewportSettingsFromNative(mNativeClass);

        // clamp initial scale
        if (mViewportInitialScale > 0) {
            if (mViewportMinimumScale > 0) {
                mViewportInitialScale = Math.max(mViewportInitialScale,
                        mViewportMinimumScale);
            }
            if (mViewportMaximumScale > 0) {
                mViewportInitialScale = Math.min(mViewportInitialScale,
                        mViewportMaximumScale);
            }
        }

        if (mSettings.forceUserScalable()) {
            mViewportUserScalable = true;
            if (mViewportInitialScale > 0) {
                if (mViewportMinimumScale > 0) {
                    mViewportMinimumScale = Math.min(mViewportMinimumScale,
                            mViewportInitialScale / 2);
                }
                if (mViewportMaximumScale > 0) {
                    mViewportMaximumScale = Math.max(mViewportMaximumScale,
                            mViewportInitialScale * 2);
                }
            } else {
                if (mViewportMinimumScale > 0) {
                    mViewportMinimumScale = Math.min(mViewportMinimumScale, 50);
                }
                if (mViewportMaximumScale > 0) {
                    mViewportMaximumScale = Math.max(mViewportMaximumScale, 200);
                }
            }
        }

        // adjust the default scale to match the densityDpi
        float adjust = 1.0f;
        if (mViewportDensityDpi == -1) {
            adjust = getFixedDisplayDensity(mContext);
        } else if (mViewportDensityDpi > 0) {
            adjust = (float) mContext.getResources().getDisplayMetrics().densityDpi
                    / mViewportDensityDpi;
            adjust = ((int) (adjust * 100)) / 100.0f;
        }

        // Remove any update density messages in flight.
        // If the density is indeed different from WebView's default scale,
        // a new message will be queued.
        mWebViewClassic.mPrivateHandler.removeMessages(
                WebViewClassic.UPDATE_ZOOM_DENSITY);
        if (adjust != mWebViewClassic.getDefaultZoomScale()) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.UPDATE_ZOOM_DENSITY, adjust).sendToTarget();
        }
        int defaultScale = (int) (adjust * 100);

        if (mViewportInitialScale > 0) {
            mViewportInitialScale *= adjust;
        }
        if (mViewportMinimumScale > 0) {
            mViewportMinimumScale *= adjust;
        }
        if (mViewportMaximumScale > 0) {
            mViewportMaximumScale *= adjust;
        }

        // infer the values if they are not defined.
        if (mViewportWidth == 0) {
            if (mViewportInitialScale == 0) {
                mViewportInitialScale = defaultScale;
            }
        }
        if (mViewportUserScalable == false) {
            mViewportInitialScale = defaultScale;
            mViewportMinimumScale = defaultScale;
            mViewportMaximumScale = defaultScale;
        }
        if (mViewportMinimumScale > mViewportInitialScale
                && mViewportInitialScale != 0) {
            mViewportMinimumScale = mViewportInitialScale;
        }
        if (mViewportMaximumScale > 0
                && mViewportMaximumScale < mViewportInitialScale) {
            mViewportMaximumScale = mViewportInitialScale;
        }
        if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
            mViewportWidth = 0;
        }

        // if mViewportWidth is 0, it means device-width, always update.
        if (mViewportWidth != 0 && !updateViewState) {
            // For non standard load, since updateViewState will be false.
            mFirstLayoutForNonStandardLoad = true;
            ViewState viewState = new ViewState();
            viewState.mMinScale = mViewportMinimumScale / 100.0f;
            viewState.mMaxScale = mViewportMaximumScale / 100.0f;
            viewState.mDefaultScale = adjust;
            // as mViewportWidth is not 0, it is not mobile site.
            viewState.mMobileSite = false;
            // for non-mobile site, we don't need minPrefWidth, set it as 0
            viewState.mScrollX = 0;
            viewState.mShouldStartScrolledRight = false;
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.UPDATE_ZOOM_RANGE, viewState).sendToTarget();
            return;
        }

        // now notify webview
        // webViewWidth refers to the width in the view system
        int webViewWidth;
        // viewportWidth refers to the width in the document system
        int viewportWidth = mCurrentViewWidth;
        if (viewportWidth == 0) {
            // this may happen when WebView just starts. This is not perfect as
            // we call WebView method from WebCore thread. But not perfect
            // reference is better than no reference.
            webViewWidth = mWebViewClassic.getViewWidth();
            viewportWidth = (int) (webViewWidth / adjust);
            if (viewportWidth == 0) {
                if (DebugFlags.WEB_VIEW_CORE) {
                    Log.v(LOGTAG, "Can't get the viewWidth yet");
                }
            }
        } else {
            webViewWidth = Math.round(viewportWidth * mCurrentViewScale);
        }
        mInitialViewState = new ViewState();
        mInitialViewState.mMinScale = mViewportMinimumScale / 100.0f;
        mInitialViewState.mMaxScale = mViewportMaximumScale / 100.0f;
        mInitialViewState.mDefaultScale = adjust;
        mInitialViewState.mScrollX = mRestoredX;
        mInitialViewState.mScrollY = mRestoredY;
        mInitialViewState.mShouldStartScrolledRight = (mRestoredX == 0)
                && (mRestoredY == 0)
                && (mBrowserFrame != null)
                && mBrowserFrame.getShouldStartScrolledRight();

        mInitialViewState.mMobileSite = (0 == mViewportWidth);
        if (mIsRestored) {
            mInitialViewState.mIsRestored = true;
            mInitialViewState.mViewScale = mRestoredScale;
            if (mRestoredTextWrapScale > 0) {
                mInitialViewState.mTextWrapScale = mRestoredTextWrapScale;
            } else {
                mInitialViewState.mTextWrapScale = mInitialViewState.mViewScale;
            }
        } else {
            if (mViewportInitialScale > 0) {
                mInitialViewState.mViewScale = mInitialViewState.mTextWrapScale =
                        mViewportInitialScale / 100.0f;
            } else if (mViewportWidth > 0 && mViewportWidth < webViewWidth &&
                !getSettings().getUseFixedViewport()) {
                mInitialViewState.mViewScale = mInitialViewState.mTextWrapScale =
                        (float) webViewWidth / mViewportWidth;
            } else {
                mInitialViewState.mTextWrapScale = adjust;
                if (mSettings.getUseWideViewPort()) {
                    // 0 will trigger WebView to turn on zoom overview mode
                    mInitialViewState.mViewScale = 0;
                } else {
                    mInitialViewState.mViewScale = adjust;
                }
            }
        }

        if (mWebViewClassic.mHeightCanMeasure) {
            // Trick to ensure that the Picture has the exact height for the
            // content by forcing to layout with 0 height after the page is
            // ready, which is indicated by didFirstLayout. This is essential to
            // get rid of the white space in the GMail which uses WebView for
            // message view.
            mWebViewClassic.mLastHeightSent = 0;
            // Send a negative scale to indicate that WebCore should reuse
            // the current scale
            WebViewClassic.ViewSizeData data = new WebViewClassic.ViewSizeData();
            data.mWidth = mWebViewClassic.mLastWidthSent;
            data.mHeight = 0;
            // if mHeightCanMeasure is true, getUseWideViewPort() can't be
            // true. It is safe to use mWidth for mTextWrapWidth.
            data.mTextWrapWidth = data.mWidth;
            data.mScale = -1.0f;
            data.mIgnoreHeight = false;
            data.mAnchorX = data.mAnchorY = 0;
            // send VIEW_SIZE_CHANGED to the front of the queue so that we can
            // avoid pushing the wrong picture to the WebView side. If there is
            // a VIEW_SIZE_CHANGED in the queue, probably from WebView side,
            // ignore it as we have a new size. If we leave VIEW_SIZE_CHANGED
            // in the queue, as mLastHeightSent has been updated here, we may
            // miss the requestLayout in WebView side after the new picture.
            mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
            mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,
                    EventHub.VIEW_SIZE_CHANGED, data));
        } else {
            if (viewportWidth == 0) {
                // Trick to ensure VIEW_SIZE_CHANGED will be sent from WebView
                // to WebViewCore
                mWebViewClassic.mLastWidthSent = 0;
            } else {
                WebViewClassic.ViewSizeData data = new WebViewClassic.ViewSizeData();
                // mViewScale as 0 means it is in zoom overview mode. So we don't
                // know the exact scale. If mRestoredScale is non-zero, use it;
                // otherwise just use mTextWrapScale as the initial scale.
                float tentativeScale = mInitialViewState.mViewScale;
                if (tentativeScale == 0) {
                    // The following tries to figure out more correct view scale
                    // and text wrap scale to be sent to webkit, by using some
                    // knowledge from web settings and zoom manager.

                    // Calculated window width will be used to guess the scale
                    // in zoom overview mode.
                    tentativeScale = mInitialViewState.mTextWrapScale;
                    int tentativeViewWidth = Math.round(webViewWidth / tentativeScale);
                    int windowWidth = calculateWindowWidth(tentativeViewWidth);
                    // In viewport setup time, since no content width is known, we assume
                    // the windowWidth will be the content width, to get a more likely
                    // zoom overview scale.
                    data.mScale = (float) webViewWidth / windowWidth;
                    if (!mSettings.getLoadWithOverviewMode()) {
                        // If user choose non-overview mode.
                        data.mScale = Math.max(data.mScale, tentativeScale);
                    }
                    if (mSettings.isNarrowColumnLayout()) {
                        // In case of automatic text reflow in fixed view port mode.
                        mInitialViewState.mTextWrapScale =
                                mWebViewClassic.computeReadingLevelScale(data.mScale);
                    }
                } else {
                    // Scale is given such as when page is restored, use it.
                    data.mScale = tentativeScale;
                }
                if (DebugFlags.WEB_VIEW_CORE) {
                    Log.v(LOGTAG, "setupViewport"
                             + " mRestoredScale=" + mRestoredScale
                             + " mViewScale=" + mInitialViewState.mViewScale
                             + " mTextWrapScale=" + mInitialViewState.mTextWrapScale
                             + " data.mScale= " + data.mScale
                             );
                }
                data.mWidth = Math.round(webViewWidth / data.mScale);
                // We may get a call here when mCurrentViewHeight == 0 if webcore completes the
                // first layout before we sync our webview dimensions to it. In that case, we
                // request the real height of the webview. This is not a perfect solution as we
                // are calling a WebView method from the WebCore thread. But this is preferable
                // to syncing an incorrect height.
                data.mHeight = mCurrentViewHeight == 0 ?
                        Math.round(mWebViewClassic.getViewHeight() / data.mScale)
                        : Math.round((float) mCurrentViewHeight * data.mWidth / viewportWidth);
                data.mTextWrapWidth = Math.round(webViewWidth
                        / mInitialViewState.mTextWrapScale);
                data.mIgnoreHeight = false;
                data.mAnchorX = data.mAnchorY = 0;
                // send VIEW_SIZE_CHANGED to the front of the queue so that we
                // can avoid pushing the wrong picture to the WebView side.
                mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
                // Let webkit know the scale and inner width/height immediately
                // in viewport setup time to avoid wrong information.
                viewSizeChanged(data);
            }
        }
!!!5099532.java!!!	restoreScale(in scale : float, in textWrapScale : float) : void
        if (mBrowserFrame.firstLayoutDone() == false) {
            mIsRestored = true;
            mRestoredScale = scale;
            if (mSettings.getUseWideViewPort()) {
                mRestoredTextWrapScale = textWrapScale;
            }
        }
!!!5099660.java!!!	needTouchEvents(inout need : boolean) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.WEBCORE_NEED_TOUCH_EVENTS, need ? 1 : 0, 0)
                    .sendToTarget();
        }
!!!5099788.java!!!	updateTextfield(in ptr : int, in text : String, in textGeneration : int) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.UPDATE_TEXTFIELD_TEXT_MSG_ID, ptr,
                    textGeneration, text).sendToTarget();
        }
!!!5099916.java!!!	createTextSelection(in start : int, in end : int, in selPtr : int) : TextSelectionData
        TextSelectionData data = new TextSelectionData(start, end, selPtr);
        data.mSelectionReason = mTextSelectionChangeReason;
        return data;
!!!5100044.java!!!	updateTextSelection(in pointer : int, in start : int, in end : int, in textGeneration : int, in selectionPtr : int) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                WebViewClassic.UPDATE_TEXT_SELECTION_MSG_ID, pointer, textGeneration,
                createTextSelection(start, end, selectionPtr)).sendToTarget();
        }
!!!5100172.java!!!	updateTextSizeAndScroll(in pointer : int, in width : int, in height : int, in scrollX : int, in scrollY : int) : void
        if (mWebViewClassic != null) {
            Rect rect = new Rect(-scrollX, -scrollY, width - scrollX,
                    height - scrollY);
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.EDIT_TEXT_SIZE_CHANGED, pointer, 0, rect)
                    .sendToTarget();
        }
!!!5100300.java!!!	clearTextEntry() : void
        if (mWebViewClassic == null) return;
        Message.obtain(mWebViewClassic.mPrivateHandler,
                WebViewClassic.CLEAR_TEXT_ENTRY).sendToTarget();
!!!5100428.java!!!	initEditField(in start : int, in end : int, in selectionPtr : int, inout initData : TextFieldInitData) : void
        if (mWebViewClassic == null) {
            return;
        }
        Message.obtain(mWebViewClassic.mPrivateHandler,
                WebViewClassic.INIT_EDIT_FIELD, initData).sendToTarget();
        Message.obtain(mWebViewClassic.mPrivateHandler,
                WebViewClassic.UPDATE_TEXT_SELECTION_MSG_ID,
                initData.mFieldPointer, 0,
                createTextSelection(start, end, selectionPtr))
                .sendToTarget();
!!!5101196.java!!!	requestListBox(inout array : String, inout enabledArray : int, inout selectedArray : int) : void
        if (mWebViewClassic != null) {
            mWebViewClassic.requestListBox(array, enabledArray, selectedArray);
        }
!!!5101324.java!!!	requestListBox(inout array : String, inout enabledArray : int, in selection : int) : void
        if (mWebViewClassic != null) {
            mWebViewClassic.requestListBox(array, enabledArray, selection);
        }

!!!5101452.java!!!	requestKeyboard(inout showKeyboard : boolean) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler,
                    WebViewClassic.REQUEST_KEYBOARD, showKeyboard ? 1 : 0, 0)
                    .sendToTarget();
        }
!!!5101580.java!!!	setWebTextViewAutoFillable(in queryId : int, in preview : String) : void
        if (mWebViewClassic != null) {
            Message.obtain(mWebViewClassic.mPrivateHandler, WebViewClassic.SET_AUTOFILLABLE,
                    new AutoFillData(queryId, preview))
                    .sendToTarget();
        }
!!!5101708.java!!!	getContext() : Context
        return mContext;
!!!5101836.java!!!	keepScreenOn(inout screenOn : boolean) : void
        if (mWebViewClassic != null) {
            Message message = mWebViewClassic.mPrivateHandler.obtainMessage(
                    WebViewClassic.SCREEN_ON);
            message.arg1 = screenOn ? 1 : 0;
            message.sendToTarget();
        }
!!!5101964.java!!!	getPluginClass(in libName : String, in clsName : String) : Class<?>

        if (mWebViewClassic == null) {
            return null;
        }

        PluginManager pluginManager = PluginManager.getInstance(null);

        String pkgName = pluginManager.getPluginsAPKName(libName);
        if (pkgName == null) {
            Log.w(LOGTAG, "Unable to resolve " + libName + " to a plugin APK");
            return null;
        }

        try {
            return pluginManager.getPluginClass(pkgName, clsName);
        } catch (NameNotFoundException e) {
            Log.e(LOGTAG, "Unable to find plugin classloader for the apk (" + pkgName + ")");
        } catch (ClassNotFoundException e) {
            Log.e(LOGTAG, "Unable to find plugin class (" + clsName +
                    ") in the apk (" + pkgName + ")");
        }

        return null;
!!!5102092.java!!!	showFullScreenPlugin(inout childView : ChildView, in orientation : int, in npp : int) : void
        if (mWebViewClassic == null) {
            return;
        }

        Message message = mWebViewClassic.mPrivateHandler.obtainMessage(
                WebViewClassic.SHOW_FULLSCREEN);
        message.obj = childView.mView;
        message.arg1 = orientation;
        message.arg2 = npp;
        message.sendToTarget();
!!!5102220.java!!!	hideFullScreenPlugin() : void
        if (mWebViewClassic == null) {
            return;
        }
        mWebViewClassic.mPrivateHandler.obtainMessage(WebViewClassic.HIDE_FULLSCREEN)
                .sendToTarget();
!!!5102348.java!!!	createSurface(inout pluginView : View) : ChildView
        if (mWebViewClassic == null) {
            return null;
        }

        if (pluginView == null) {
            Log.e(LOGTAG, "Attempted to add an empty plugin view to the view hierarchy");
            return null;
        }

        // ensures the view system knows the view can redraw itself
        pluginView.setWillNotDraw(false);

        if(pluginView instanceof SurfaceView)
            ((SurfaceView)pluginView).setZOrderOnTop(true);

        ViewManager.ChildView view = mWebViewClassic.mViewManager.createView();
        view.mView = pluginView;
        return view;
!!!5102476.java!!!	addSurface(inout pluginView : View, in x : int, in y : int, in width : int, in height : int) : ChildView
        ViewManager.ChildView view = createSurface(pluginView);
        view.attachView(x, y, width, height);
        return view;
!!!5102604.java!!!	updateSurface(inout childView : ChildView, in x : int, in y : int, in width : int, in height : int) : void
        childView.attachView(x, y, width, height);
!!!5102732.java!!!	destroySurface(inout childView : ChildView) : void
        childView.removeView();
!!!5102860.java!!!	showRect(in left : int, in top : int, in width : int, in height : int, in contentWidth : int, in contentHeight : int, in xPercentInDoc : float, in xPercentInView : float, in yPercentInDoc : float, in yPercentInView : float) : void
        if (mWebViewClassic != null) {
            ShowRectData data = new ShowRectData();
            data.mLeft = left;
            data.mTop = top;
            data.mWidth = width;
            data.mHeight = height;
            data.mContentWidth = contentWidth;
            data.mContentHeight = contentHeight;
            data.mXPercentInDoc = xPercentInDoc;
            data.mXPercentInView = xPercentInView;
            data.mYPercentInDoc = yPercentInDoc;
            data.mYPercentInView = yPercentInView;
            Message.obtain(mWebViewClassic.mPrivateHandler, WebViewClassic.SHOW_RECT_MSG_ID,
                    data).sendToTarget();
        }
!!!5102988.java!!!	centerFitRect(in x : int, in y : int, in width : int, in height : int) : void
        if (mWebViewClassic == null) {
            return;
        }
        mWebViewClassic.mPrivateHandler.obtainMessage(WebViewClassic.CENTER_FIT_RECT,
                new Rect(x, y, x + width, y + height)).sendToTarget();
!!!5103116.java!!!	setScrollbarModes(in hMode : int, in vMode : int) : void
        if (mWebViewClassic == null) {
            return;
        }
        mWebViewClassic.mPrivateHandler.obtainMessage(WebViewClassic.SET_SCROLLBAR_MODES,
                hMode, vMode).sendToTarget();
!!!5103244.java!!!	selectAt(in x : int, in y : int) : void
        // TODO: Figure out what to do with this (b/6111818)
!!!5103372.java!!!	setUseMockDeviceOrientation() : void
        mDeviceMotionAndOrientationManager.setUseMock();
!!!5103500.java!!!	setUseMockGeolocation() : void
        mMockGeolocation.setUseMock();
!!!5103628.java!!!	setMockGeolocationPosition(in latitude : double, in longitude : double, in accuracy : double) : void
        mMockGeolocation.setPosition(latitude, longitude, accuracy);
!!!5103756.java!!!	setMockGeolocationError(in code : int, in message : String) : void
        mMockGeolocation.setError(code, message);
!!!5103884.java!!!	setMockGeolocationPermission(inout allow : boolean) : void
        mMockGeolocation.setPermission(allow);
!!!5104012.java!!!	setMockDeviceOrientation(inout canProvideAlpha : boolean, in alpha : double, inout canProvideBeta : boolean, in beta : double, inout canProvideGamma : boolean, in gamma : double) : void
        mDeviceMotionAndOrientationManager.setMockOrientation(canProvideAlpha, alpha,
                canProvideBeta, beta, canProvideGamma, gamma);
!!!5104140.java!!!	getDeviceMotionService() : DeviceMotionService
        if (mDeviceMotionService == null) {
            mDeviceMotionService =
                    new DeviceMotionService(mDeviceMotionAndOrientationManager, mContext);
        }
        return mDeviceMotionService;
!!!5104268.java!!!	getDeviceOrientationService() : DeviceOrientationService
        if (mDeviceOrientationService == null) {
            mDeviceOrientationService =
                    new DeviceOrientationService(mDeviceMotionAndOrientationManager, mContext);
        }
        return mDeviceOrientationService;
!!!5104396.java!!!	setShouldMonitorWebCoreThread() : void
        sShouldMonitorWebCoreThread = true;
