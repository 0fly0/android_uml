class WebViewClassic
!!!5020684.java!!!	incrementTextGeneration() : void
 mTextGeneration++;
!!!5020812.java!!!	WebViewClassic(inout webView : WebView, inout privateAccess : PrivateAccess)
        mWebView = webView;
        mWebViewPrivate = privateAccess;
        mContext = webView.getContext();
!!!5020940.java!!!	init(inout javaScriptInterfaces : Map<String, Object>, inout privateBrowsing : boolean) : void
        Context context = mContext;

        // Used by the chrome stack to find application paths
        JniUtil.setContext(context);

        mCallbackProxy = new CallbackProxy(context, this);
        mViewManager = new ViewManager(this);
        L10nUtils.setApplicationContext(context.getApplicationContext());
        mWebViewCore = new WebViewCore(context, this, mCallbackProxy, javaScriptInterfaces);
        mDatabase = WebViewDatabaseClassic.getInstance(context);
        mScroller = new OverScroller(context, null, 0, 0, false); //TODO Use OverScroller's flywheel
        mZoomManager = new ZoomManager(this, mCallbackProxy);

        /* The init method must follow the creation of certain member variables,
         * such as the mZoomManager.
         */
        init();
        setupPackageListener(context);
        setupProxyListener(context);
        setupTrustStorageListener(context);
        updateMultiTouchSupport(context);

        if (privateBrowsing) {
            startPrivateBrowsing();
        }

        mAutoFillData = new WebViewCore.AutoFillData();
        mEditTextScroller = new Scroller(context);
!!!5023628.java!!!	onHandleUiEvent(inout event : MotionEvent, in eventType : int, in flags : int) : void
        switch (eventType) {
        case WebViewInputDispatcher.EVENT_TYPE_LONG_PRESS:
            HitTestResult hitTest = getHitTestResult();
            if (hitTest != null) {
                mWebView.performLongClick();
            }
            break;
        case WebViewInputDispatcher.EVENT_TYPE_DOUBLE_TAP:
            mZoomManager.handleDoubleTap(event.getX(), event.getY());
            break;
        case WebViewInputDispatcher.EVENT_TYPE_TOUCH:
            onHandleUiTouchEvent(event);
            break;
        case WebViewInputDispatcher.EVENT_TYPE_CLICK:
            if (mFocusedNode != null && mFocusedNode.mIntentUrl != null) {
                mWebView.playSoundEffect(SoundEffectConstants.CLICK);
                overrideLoading(mFocusedNode.mIntentUrl);
            }
            break;
        }
!!!5023756.java!!!	onHandleUiTouchEvent(inout ev : MotionEvent) : void
        final ScaleGestureDetector detector =
                mZoomManager.getScaleGestureDetector();

        int action = ev.getActionMasked();
        final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
        final boolean configChanged =
            action == MotionEvent.ACTION_POINTER_UP ||
            action == MotionEvent.ACTION_POINTER_DOWN;
        final int skipIndex = pointerUp ? ev.getActionIndex() : -1;

        // Determine focal point
        float sumX = 0, sumY = 0;
        final int count = ev.getPointerCount();
        for (int i = 0; i < count; i++) {
            if (skipIndex == i) continue;
            sumX += ev.getX(i);
            sumY += ev.getY(i);
        }
        final int div = pointerUp ? count - 1 : count;
        float x = sumX / div;
        float y = sumY / div;

        if (configChanged) {
            mLastTouchX = Math.round(x);
            mLastTouchY = Math.round(y);
            mLastTouchTime = ev.getEventTime();
            mWebView.cancelLongPress();
            mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
        }

        if (detector != null) {
            detector.onTouchEvent(ev);
            if (detector.isInProgress()) {
                mLastTouchTime = ev.getEventTime();

                if (!mZoomManager.supportsPanDuringZoom()) {
                    return;
                }
                mTouchMode = TOUCH_DRAG_MODE;
                if (mVelocityTracker == null) {
                    mVelocityTracker = VelocityTracker.obtain();
                }
            }
        }

        if (action == MotionEvent.ACTION_POINTER_DOWN) {
            cancelTouch();
            action = MotionEvent.ACTION_DOWN;
        } else if (action == MotionEvent.ACTION_MOVE) {
            // negative x or y indicate it is on the edge, skip it.
            if (x < 0 || y < 0) {
                return;
            }
        }

        handleTouchEventCommon(ev, action, Math.round(x), Math.round(y));
!!!5023884.java!!!	getWebView() : WebView
        return mWebView;
!!!5024012.java!!!	getViewDelegate() : ViewDelegate
        return this;
!!!5024140.java!!!	getScrollDelegate() : ScrollDelegate
        return this;
!!!5024268.java!!!	fromWebView(inout webView : WebView) : WebViewClassic
        return webView == null ? null : (WebViewClassic) webView.getWebViewProvider();
!!!5024396.java!!!	getScrollX() : int
        return mWebView.getScrollX();
!!!5024524.java!!!	getScrollY() : int
        return mWebView.getScrollY();
!!!5024652.java!!!	getWidth() : int
        return mWebView.getWidth();
!!!5024780.java!!!	getHeight() : int
        return mWebView.getHeight();
!!!5024908.java!!!	getContext() : Context
        return mContext;
!!!5025036.java!!!	invalidate() : void
        mWebView.invalidate();
!!!5025164.java!!!	setScrollXRaw(in mScrollX : int) : void
        mWebViewPrivate.setScrollXRaw(mScrollX);
!!!5025292.java!!!	setScrollYRaw(in mScrollY : int) : void
        mWebViewPrivate.setScrollYRaw(mScrollY);
!!!5025548.java!!!	handleCertTrustChanged() : void
        // send a message for indicating trust storage change
        WebViewCore.sendStaticMessage(EventHub.TRUST_STORAGE_UPDATED, null);
!!!5025676.java!!!	setupTrustStorageListener(inout context : Context) : void
        if (sTrustStorageListener != null ) {
            return;
        }
        IntentFilter filter = new IntentFilter();
        filter.addAction(KeyChain.ACTION_STORAGE_CHANGED);
        sTrustStorageListener = new TrustStorageListener();
        Intent current =
            context.getApplicationContext().registerReceiver(sTrustStorageListener, filter);
        if (current != null) {
            handleCertTrustChanged();
        }
!!!5025932.java!!!	setupProxyListener(inout context : Context) : void
        if (sProxyReceiver != null || sNotificationsEnabled == false) {
            return;
        }
        IntentFilter filter = new IntentFilter();
        filter.addAction(Proxy.PROXY_CHANGE_ACTION);
        sProxyReceiver = new ProxyReceiver();
        Intent currentProxy = context.getApplicationContext().registerReceiver(
                sProxyReceiver, filter);
        if (currentProxy != null) {
            handleProxyBroadcast(currentProxy);
        }
!!!5026060.java!!!	disableProxyListener(inout context : Context) : void
        if (sProxyReceiver == null)
            return;

        context.getApplicationContext().unregisterReceiver(sProxyReceiver);
        sProxyReceiver = null;
!!!5026188.java!!!	handleProxyBroadcast(inout intent : Intent) : void
        ProxyProperties proxyProperties = (ProxyProperties)intent.getExtra(Proxy.EXTRA_PROXY_INFO);
        if (proxyProperties == null || proxyProperties.getHost() == null) {
            WebViewCore.sendStaticMessage(EventHub.PROXY_CHANGED, null);
            return;
        }
        WebViewCore.sendStaticMessage(EventHub.PROXY_CHANGED, proxyProperties);
!!!5026444.java!!!	setupPackageListener(inout context : Context) : void

        /*
         * we must synchronize the instance check and the creation of the
         * receiver to ensure that only ONE receiver exists for all WebView
         * instances.
         */
        synchronized (WebViewClassic.class) {

            // if the receiver already exists then we do not need to register it
            // again
            if (sPackageInstallationReceiverAdded) {
                return;
            }

            IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
            filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
            filter.addDataScheme("package");
            BroadcastReceiver packageListener = new PackageListener();
            context.getApplicationContext().registerReceiver(packageListener, filter);
            sPackageInstallationReceiverAdded = true;
        }

        // check if any of the monitored apps are already installed
        AsyncTask<Void, Void, Set<String>> task = new AsyncTask<Void, Void, Set<String>>() {

            @Override
            protected Set<String> doInBackground(Void... unused) {
                Set<String> installedPackages = new HashSet<String>();
                PackageManager pm = mContext.getPackageManager();
                for (String name : sGoogleApps) {
                    try {
                        pm.getPackageInfo(name,
                                PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES);
                        installedPackages.add(name);
                    } catch (PackageManager.NameNotFoundException e) {
                        // package not found
                    }
                }
                return installedPackages;
            }

            // Executes on the UI thread
            @Override
            protected void onPostExecute(Set<String> installedPackages) {
                if (mWebViewCore != null) {
                    mWebViewCore.sendMessage(EventHub.ADD_PACKAGE_NAMES, installedPackages);
                }
            }
        };
        task.execute();
!!!5026572.java!!!	updateMultiTouchSupport(inout context : Context) : void
        mZoomManager.updateMultiTouchSupport(context);
!!!5026700.java!!!	updateJavaScriptEnabled(inout enabled : boolean) : void
        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().updateJavaScriptEnabled(enabled);
        }
!!!5026828.java!!!	init() : void
        OnTrimMemoryListener.init(mContext);
        mWebView.setWillNotDraw(false);
        mWebView.setClickable(true);
        mWebView.setLongClickable(true);

        final ViewConfiguration configuration = ViewConfiguration.get(mContext);
        int slop = configuration.getScaledTouchSlop();
        mTouchSlopSquare = slop * slop;
        slop = configuration.getScaledDoubleTapSlop();
        mDoubleTapSlopSquare = slop * slop;
        final float density = WebViewCore.getFixedDisplayDensity(mContext);
        // use one line height, 16 based on our current default font, for how
        // far we allow a touch be away from the edge of a link
        mNavSlop = (int) (16 * density);
        mZoomManager.init(density);
        mMaximumFling = configuration.getScaledMaximumFlingVelocity();

        // Compute the inverse of the density squared.
        DRAG_LAYER_INVERSE_DENSITY_SQUARED = 1 / (density * density);

        mOverscrollDistance = configuration.getScaledOverscrollDistance();
        mOverflingDistance = configuration.getScaledOverflingDistance();

        setScrollBarStyle(mWebViewPrivate.super_getScrollBarStyle());
        // Initially use a size of two, since the user is likely to only hold
        // down two keys at a time (shift + another key)
        mKeysPressed = new Vector<Integer>(2);
        mHTML5VideoViewProxy = null ;
!!!5026956.java!!!	shouldDelayChildPressedState() : boolean
        return true;
!!!5027084.java!!!	performAccessibilityAction(in action : int, inout arguments : Bundle) : boolean
        if (!mWebView.isEnabled()) {
            // Only default actions are supported while disabled.
            return mWebViewPrivate.super_performAccessibilityAction(action, arguments);
        }

        if (getAccessibilityInjector().supportsAccessibilityAction(action)) {
            return getAccessibilityInjector().performAccessibilityAction(action, arguments);
        }

        switch (action) {
            case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
                final int convertedContentHeight = contentToViewY(getContentHeight());
                final int adjustedViewHeight = getHeight() - mWebView.getPaddingTop()
                        - mWebView.getPaddingBottom();
                final int maxScrollY = Math.max(convertedContentHeight - adjustedViewHeight, 0);
                final boolean canScrollBackward = (getScrollY() > 0);
                final boolean canScrollForward = ((getScrollY() - maxScrollY) > 0);
                if ((action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) && canScrollBackward) {
                    mWebView.scrollBy(0, adjustedViewHeight);
                    return true;
                }
                if ((action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) && canScrollForward) {
                    mWebView.scrollBy(0, -adjustedViewHeight);
                    return true;
                }
                return false;
            }
        }

        return mWebViewPrivate.super_performAccessibilityAction(action, arguments);
!!!5027212.java!!!	onInitializeAccessibilityNodeInfo(inout info : AccessibilityNodeInfo) : void
        if (!mWebView.isEnabled()) {
            // Only default actions are supported while disabled.
            return;
        }

        info.setScrollable(isScrollableForAccessibility());

        final int convertedContentHeight = contentToViewY(getContentHeight());
        final int adjustedViewHeight = getHeight() - mWebView.getPaddingTop()
                - mWebView.getPaddingBottom();
        final int maxScrollY = Math.max(convertedContentHeight - adjustedViewHeight, 0);
        final boolean canScrollBackward = (getScrollY() > 0);
        final boolean canScrollForward = ((getScrollY() - maxScrollY) > 0);

        if (canScrollForward) {
            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
        }

        if (canScrollForward) {
            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
        }

        getAccessibilityInjector().onInitializeAccessibilityNodeInfo(info);
!!!5027340.java!!!	onInitializeAccessibilityEvent(inout event : AccessibilityEvent) : void
        event.setScrollable(isScrollableForAccessibility());
        event.setScrollX(getScrollX());
        event.setScrollY(getScrollY());
        final int convertedContentWidth = contentToViewX(getContentWidth());
        final int adjustedViewWidth = getWidth() - mWebView.getPaddingLeft()
                - mWebView.getPaddingLeft();
        event.setMaxScrollX(Math.max(convertedContentWidth - adjustedViewWidth, 0));
        final int convertedContentHeight = contentToViewY(getContentHeight());
        final int adjustedViewHeight = getHeight() - mWebView.getPaddingTop()
                - mWebView.getPaddingBottom();
        event.setMaxScrollY(Math.max(convertedContentHeight - adjustedViewHeight, 0));
!!!5027468.java!!!	isAccessibilityInjectionEnabled() : boolean
        final AccessibilityManager manager = AccessibilityManager.getInstance(mContext);
        if (!manager.isEnabled()) {
            return false;
        }

        // Accessibility scripts should be injected only when a speaking service
        // is enabled. This may need to change later to accommodate Braille.
        final List<AccessibilityServiceInfo> services = manager.getEnabledAccessibilityServiceList(
                AccessibilityServiceInfo.FEEDBACK_SPOKEN);
        if (services.isEmpty()) {
            return false;
        }

        return true;
!!!5027596.java!!!	getAccessibilityInjector() : AccessibilityInjector
        if (mAccessibilityInjector == null) {
            mAccessibilityInjector = new AccessibilityInjector(this);
        }
        return mAccessibilityInjector;
!!!5027724.java!!!	isScrollableForAccessibility() : boolean
        return (contentToViewX(getContentWidth()) > getWidth() - mWebView.getPaddingLeft()
                - mWebView.getPaddingRight()
                || contentToViewY(getContentHeight()) > getHeight() - mWebView.getPaddingTop()
                - mWebView.getPaddingBottom());
!!!5027852.java!!!	setOverScrollMode(in mode : int) : void
        if (mode != View.OVER_SCROLL_NEVER) {
            if (mOverScrollGlow == null) {
                mOverScrollGlow = new OverScrollGlow(this);
            }
        } else {
            mOverScrollGlow = null;
        }
!!!5027980.java!!!	adjustDefaultZoomDensity(in zoomDensity : int) : void
        final float density = WebViewCore.getFixedDisplayDensity(mContext)
                * 100 / zoomDensity;
        updateDefaultZoomDensity(density);
!!!5028108.java!!!	updateDefaultZoomDensity(in density : float) : void
        mNavSlop = (int) (16 * density);
        mZoomManager.updateDefaultZoomDensity(density);
!!!5028236.java!!!	getScaledNavSlop() : int
        return viewToContentDimension(mNavSlop);
!!!5028364.java!!!	onSavePassword(in schemePlusHost : String, in username : String, in password : String, in resumeMsg : Message) : boolean
        boolean rVal = false;
        if (resumeMsg == null) {
            // null resumeMsg implies saving password silently
            mDatabase.setUsernamePassword(schemePlusHost, username, password);
        } else {
            if (mResumeMsg != null) {
                Log.w(LOGTAG, "onSavePassword should not be called while dialog is up");
                resumeMsg.sendToTarget();
                return true;
            }
            mResumeMsg = resumeMsg;
            final Message remember = mPrivateHandler.obtainMessage(
                    REMEMBER_PASSWORD);
            remember.getData().putString("host", schemePlusHost);
            remember.getData().putString("username", username);
            remember.getData().putString("password", password);
            remember.obj = resumeMsg;

            final Message neverRemember = mPrivateHandler.obtainMessage(
                    NEVER_REMEMBER_PASSWORD);
            neverRemember.getData().putString("host", schemePlusHost);
            neverRemember.getData().putString("username", username);
            neverRemember.getData().putString("password", password);
            neverRemember.obj = resumeMsg;

            mSavePasswordDialog = new AlertDialog.Builder(mContext)
                    .setTitle(com.android.internal.R.string.save_password_label)
                    .setMessage(com.android.internal.R.string.save_password_message)
                    .setPositiveButton(com.android.internal.R.string.save_password_notnow,
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            if (mResumeMsg != null) {
                                resumeMsg.sendToTarget();
                                mResumeMsg = null;
                            }
                            mSavePasswordDialog = null;
                        }
                    })
                    .setNeutralButton(com.android.internal.R.string.save_password_remember,
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            if (mResumeMsg != null) {
                                remember.sendToTarget();
                                mResumeMsg = null;
                            }
                            mSavePasswordDialog = null;
                        }
                    })
                    .setNegativeButton(com.android.internal.R.string.save_password_never,
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            if (mResumeMsg != null) {
                                neverRemember.sendToTarget();
                                mResumeMsg = null;
                            }
                            mSavePasswordDialog = null;
                        }
                    })
                    .setOnDismissListener(new DialogInterface.OnDismissListener() {
                        @Override
                        public void onDismiss(DialogInterface dialog) {
                            if (mResumeMsg != null) {
                                resumeMsg.sendToTarget();
                                mResumeMsg = null;
                            }
                            mSavePasswordDialog = null;
                        }
                    }).show();
            // Return true so that WebViewCore will pause while the dialog is
            // up.
            rVal = true;
        }
        return rVal;
!!!5028492.java!!!	setScrollBarStyle(in style : int) : void
        if (style == View.SCROLLBARS_INSIDE_INSET
                || style == View.SCROLLBARS_OUTSIDE_INSET) {
            mOverlayHorizontalScrollbar = mOverlayVerticalScrollbar = false;
        } else {
            mOverlayHorizontalScrollbar = mOverlayVerticalScrollbar = true;
        }
!!!5028620.java!!!	setHorizontalScrollbarOverlay(inout overlay : boolean) : void
        mOverlayHorizontalScrollbar = overlay;
!!!5028748.java!!!	setVerticalScrollbarOverlay(inout overlay : boolean) : void
        mOverlayVerticalScrollbar = overlay;
!!!5028876.java!!!	overlayHorizontalScrollbar() : boolean
        return mOverlayHorizontalScrollbar;
!!!5029004.java!!!	overlayVerticalScrollbar() : boolean
        return mOverlayVerticalScrollbar;
!!!5029132.java!!!	getViewWidth() : int
        if (!mWebView.isVerticalScrollBarEnabled() || mOverlayVerticalScrollbar) {
            return getWidth();
        } else {
            return Math.max(0, getWidth() - mWebView.getVerticalScrollbarWidth());
        }
!!!5029516.java!!!	getTitleHeight() : int
        if (mWebView instanceof TitleBarDelegate) {
            return ((TitleBarDelegate) mWebView).getTitleHeight();
        }
        return 0;
!!!5029644.java!!!	getVisibleTitleHeight() : int
        // Actually, this method returns the height of the embedded title bar if one is set via the
        // hidden setEmbeddedTitleBar method.
        return getVisibleTitleHeightImpl();
!!!5029772.java!!!	getVisibleTitleHeightImpl() : int
        // need to restrict mScrollY due to over scroll
        return Math.max(getTitleHeight() - Math.max(0, getScrollY()),
                getOverlappingActionModeHeight());
!!!5029900.java!!!	getOverlappingActionModeHeight() : int
        if (mFindCallback == null) {
            return 0;
        }
        if (mCachedOverlappingActionModeHeight < 0) {
            mWebView.getGlobalVisibleRect(mGlobalVisibleRect, mGlobalVisibleOffset);
            mCachedOverlappingActionModeHeight = Math.max(0,
                    mFindCallback.getActionModeGlobalBottom() - mGlobalVisibleRect.top);
        }
        return mCachedOverlappingActionModeHeight;
!!!5030028.java!!!	getViewHeight() : int
        return getViewHeightWithTitle() - getVisibleTitleHeightImpl();
!!!5030156.java!!!	getViewHeightWithTitle() : int
        int height = getHeight();
        if (mWebView.isHorizontalScrollBarEnabled() && !mOverlayHorizontalScrollbar) {
            height -= mWebViewPrivate.getHorizontalScrollbarHeight();
        }
        return height;
!!!5030284.java!!!	getCertificate() : SslCertificate
        return mCertificate;
!!!5030412.java!!!	setCertificate(inout certificate : SslCertificate) : void
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "setCertificate=" + certificate);
        }
        // here, the certificate can be null (if the site is not secure)
        mCertificate = certificate;
!!!5030540.java!!!	savePassword(in host : String, in username : String, in password : String) : void
        mDatabase.setUsernamePassword(host, username, password);
!!!5030668.java!!!	setHttpAuthUsernamePassword(in host : String, in realm : String, in username : String, in password : String) : void
        mDatabase.setHttpAuthUsernamePassword(host, realm, username, password);
!!!5030796.java!!!	getHttpAuthUsernamePassword(in host : String, in realm : String) : String
        return mDatabase.getHttpAuthUsernamePassword(host, realm);
!!!5030924.java!!!	clearActionModes() : void
        if (mSelectCallback != null) {
            mSelectCallback.finish();
        }
        if (mFindCallback != null) {
            mFindCallback.finish();
        }
!!!5031052.java!!!	clearHelpers() : void
        hideSoftKeyboard();
        clearActionModes();
        dismissFullScreenMode();
        cancelDialogs();
!!!5031180.java!!!	cancelDialogs() : void
        if (mListBoxDialog != null) {
            mListBoxDialog.cancel();
            mListBoxDialog = null;
        }
        if (mSavePasswordDialog != null) {
            mSavePasswordDialog.dismiss();
            mSavePasswordDialog = null;
        }
!!!5031308.java!!!	destroy() : void
        if (mWebView.getViewRootImpl() != null) {
            Log.e(LOGTAG, "Error: WebView.destroy() called while still attached!");
        }
        ensureFunctorDetached();
        destroyJava();
        destroyNative();
!!!5031436.java!!!	ensureFunctorDetached() : void
        if (mWebView.isHardwareAccelerated()) {
            int drawGLFunction = nativeGetDrawGLFunction(mNativeClass);
            ViewRootImpl viewRoot = mWebView.getViewRootImpl();
            if (drawGLFunction != 0 && viewRoot != null) {
                viewRoot.detachFunctor(drawGLFunction);
            }
        }
!!!5031564.java!!!	destroyJava() : void
        mCallbackProxy.blockMessages();
        if (mAccessibilityInjector != null) {
            mAccessibilityInjector.destroy();
            mAccessibilityInjector = null;
        }
        if (mWebViewCore != null) {
            // Tell WebViewCore to destroy itself
            synchronized (this) {
                WebViewCore webViewCore = mWebViewCore;
                mWebViewCore = null; // prevent using partial webViewCore
                webViewCore.destroy();
            }
            // Remove any pending messages that might not be serviced yet.
            mPrivateHandler.removeCallbacksAndMessages(null);
        }
!!!5031692.java!!!	destroyNative() : void
        if (mNativeClass == 0) return;
        int nptr = mNativeClass;
        mNativeClass = 0;
        if (Thread.currentThread() == mPrivateHandler.getLooper().getThread()) {
            // We are on the main thread and can safely delete
            nativeDestroy(nptr);
        } else {
            mPrivateHandler.post(new DestroyNativeRunnable(nptr));
        }
!!!5032076.java!!!	enablePlatformNotifications() : void
        synchronized (WebViewClassic.class) {
            sNotificationsEnabled = true;
            Context context = JniUtil.getContext();
            if (context != null)
                setupProxyListener(context);
        }
!!!5032204.java!!!	disablePlatformNotifications() : void
        synchronized (WebViewClassic.class) {
            sNotificationsEnabled = false;
            Context context = JniUtil.getContext();
            if (context != null)
                disableProxyListener(context);
        }
!!!5032332.java!!!	setJsFlags(in flags : String) : void
        mWebViewCore.sendMessage(EventHub.SET_JS_FLAGS, flags);
!!!5032460.java!!!	setNetworkAvailable(inout networkUp : boolean) : void
        mWebViewCore.sendMessage(EventHub.SET_NETWORK_STATE,
                networkUp ? 1 : 0, 0);
!!!5032588.java!!!	setNetworkType(in type : String, in subtype : String) : void
        Map<String, String> map = new HashMap<String, String>();
        map.put("type", type);
        map.put("subtype", subtype);
        mWebViewCore.sendMessage(EventHub.SET_NETWORK_TYPE, map);
!!!5032716.java!!!	saveState(inout outState : Bundle) : WebBackForwardList
        if (outState == null) {
            return null;
        }
        // We grab a copy of the back/forward list because a client of WebView
        // may have invalidated the history list by calling clearHistory.
        WebBackForwardListClassic list = copyBackForwardList();
        final int currentIndex = list.getCurrentIndex();
        final int size = list.getSize();
        // We should fail saving the state if the list is empty or the index is
        // not in a valid range.
        if (currentIndex < 0 || currentIndex >= size || size == 0) {
            return null;
        }
        outState.putInt("index", currentIndex);
        // FIXME: This should just be a byte[][] instead of ArrayList but
        // Parcel.java does not have the code to handle multi-dimensional
        // arrays.
        ArrayList<byte[]> history = new ArrayList<byte[]>(size);
        for (int i = 0; i < size; i++) {
            WebHistoryItemClassic item = list.getItemAtIndex(i);
            if (null == item) {
                // FIXME: this shouldn't happen
                // need to determine how item got set to null
                Log.w(LOGTAG, "saveState: Unexpected null history item.");
                return null;
            }
            byte[] data = item.getFlattenedData();
            if (data == null) {
                // It would be very odd to not have any data for a given history
                // item. And we will fail to rebuild the history list without
                // flattened data.
                return null;
            }
            history.add(data);
        }
        outState.putSerializable("history", history);
        if (mCertificate != null) {
            outState.putBundle("certificate",
                               SslCertificate.saveState(mCertificate));
        }
        outState.putBoolean("privateBrowsingEnabled", isPrivateBrowsingEnabled());
        mZoomManager.saveZoomState(outState);
        return list;
!!!5032844.java!!!	savePicture(inout b : Bundle, in dest : File) : boolean
        if (dest == null || b == null) {
            return false;
        }
        final Picture p = capturePicture();
        // Use a temporary file while writing to ensure the destination file
        // contains valid data.
        final File temp = new File(dest.getPath() + ".writing");
        new Thread(new Runnable() {
            @Override
            public void run() {
                FileOutputStream out = null;
                try {
                    out = new FileOutputStream(temp);
                    p.writeToStream(out);
                    // Writing the picture succeeded, rename the temporary file
                    // to the destination.
                    temp.renameTo(dest);
                } catch (Exception e) {
                    // too late to do anything about it.
                } finally {
                    if (out != null) {
                        try {
                            out.close();
                        } catch (Exception e) {
                            // Can't do anything about that
                        }
                    }
                    temp.delete();
                }
            }
        }).start();
        // now update the bundle
        b.putInt("scrollX", getScrollX());
        b.putInt("scrollY", getScrollY());
        mZoomManager.saveZoomState(b);
        return true;
!!!5032972.java!!!	restoreHistoryPictureFields(inout p : Picture, inout b : Bundle) : void
        int sx = b.getInt("scrollX", 0);
        int sy = b.getInt("scrollY", 0);

        mDrawHistory = true;
        mHistoryPicture = p;

        setScrollXRaw(sx);
        setScrollYRaw(sy);
        mZoomManager.restoreZoomState(b);
        final float scale = mZoomManager.getScale();
        mHistoryWidth = Math.round(p.getWidth() * scale);
        mHistoryHeight = Math.round(p.getHeight() * scale);

        invalidate();
!!!5033100.java!!!	restorePicture(inout b : Bundle, inout src : File) : boolean
        if (src == null || b == null) {
            return false;
        }
        if (!src.exists()) {
            return false;
        }
        try {
            final FileInputStream in = new FileInputStream(src);
            final Bundle copy = new Bundle(b);
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        final Picture p = Picture.createFromStream(in);
                        if (p != null) {
                            // Post a runnable on the main thread to update the
                            // history picture fields.
                            mPrivateHandler.post(new Runnable() {
                                @Override
                                public void run() {
                                    restoreHistoryPictureFields(p, copy);
                                }
                            });
                        }
                    } finally {
                        try {
                            in.close();
                        } catch (Exception e) {
                            // Nothing we can do now.
                        }
                    }
                }
            }).start();
        } catch (FileNotFoundException e){
            e.printStackTrace();
        }
        return true;
!!!5033228.java!!!	saveViewState(inout stream : OutputStream, inout callback : ValueCallback) : void
        if (mWebViewCore == null) {
            callback.onReceiveValue(false);
            return;
        }
        mWebViewCore.sendMessageAtFrontOfQueue(EventHub.SAVE_VIEW_STATE,
                new WebViewCore.SaveViewStateRequest(stream, callback));
!!!5033356.java!!!	loadViewState(inout stream : InputStream) : void
        mBlockWebkitViewMessages = true;
        new AsyncTask<InputStream, Void, DrawData>() {

            @Override
            protected DrawData doInBackground(InputStream... params) {
                try {
                    return ViewStateSerializer.deserializeViewState(params[0]);
                } catch (IOException e) {
                    return null;
                }
            }

            @Override
            protected void onPostExecute(DrawData draw) {
                if (draw == null) {
                    Log.e(LOGTAG, "Failed to load view state!");
                    return;
                }
                int viewWidth = getViewWidth();
                int viewHeight = getViewHeightWithTitle() - getTitleHeight();
                draw.mViewSize = new Point(viewWidth, viewHeight);
                draw.mViewState.mDefaultScale = getDefaultZoomScale();
                mLoadedPicture = draw;
                setNewPicture(mLoadedPicture, true);
                mLoadedPicture.mViewState = null;
            }

        }.execute(stream);
!!!5033484.java!!!	clearViewState() : void
        mBlockWebkitViewMessages = false;
        mLoadedPicture = null;
        invalidate();
!!!5033612.java!!!	restoreState(inout inState : Bundle) : WebBackForwardList
        WebBackForwardListClassic returnList = null;
        if (inState == null) {
            return returnList;
        }
        if (inState.containsKey("index") && inState.containsKey("history")) {
            mCertificate = SslCertificate.restoreState(
                inState.getBundle("certificate"));

            final WebBackForwardListClassic list = mCallbackProxy.getBackForwardList();
            final int index = inState.getInt("index");
            // We can't use a clone of the list because we need to modify the
            // shared copy, so synchronize instead to prevent concurrent
            // modifications.
            synchronized (list) {
                final List<byte[]> history =
                        (List<byte[]>) inState.getSerializable("history");
                final int size = history.size();
                // Check the index bounds so we don't crash in native code while
                // restoring the history index.
                if (index < 0 || index >= size) {
                    return null;
                }
                for (int i = 0; i < size; i++) {
                    byte[] data = history.remove(0);
                    if (data == null) {
                        // If we somehow have null data, we cannot reconstruct
                        // the item and thus our history list cannot be rebuilt.
                        return null;
                    }
                    WebHistoryItem item = new WebHistoryItemClassic(data);
                    list.addHistoryItem(item);
                }
                // Grab the most recent copy to return to the caller.
                returnList = copyBackForwardList();
                // Update the copy to have the correct index.
                returnList.setCurrentIndex(index);
            }
            // Restore private browsing setting.
            if (inState.getBoolean("privateBrowsingEnabled")) {
                getSettings().setPrivateBrowsingEnabled(true);
            }
            mZoomManager.restoreZoomState(inState);
            // Remove all pending messages because we are restoring previous
            // state.
            mWebViewCore.removeMessages();
            if (isAccessibilityInjectionEnabled()) {
                getAccessibilityInjector().addAccessibilityApisIfNecessary();
            }
            // Send a restore state message.
            mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
        }
        return returnList;
!!!5033740.java!!!	loadUrl(in url : String, inout additionalHttpHeaders : Map<String, String>) : void
        loadUrlImpl(url, additionalHttpHeaders);
!!!5033868.java!!!	loadUrlImpl(in url : String, inout extraHeaders : Map<String, String>) : void
        switchOutDrawHistory();
        WebViewCore.GetUrlData arg = new WebViewCore.GetUrlData();
        arg.mUrl = url;
        arg.mExtraHeaders = extraHeaders;
        mWebViewCore.sendMessage(EventHub.LOAD_URL, arg);
        clearHelpers();
!!!5033996.java!!!	loadUrl(in url : String) : void
        loadUrlImpl(url);
!!!5034124.java!!!	loadUrlImpl(in url : String) : void
        if (url == null) {
            return;
        }
        loadUrlImpl(url, null);
!!!5034252.java!!!	postUrl(in url : String, inout postData : byte) : void
        if (URLUtil.isNetworkUrl(url)) {
            switchOutDrawHistory();
            WebViewCore.PostUrlData arg = new WebViewCore.PostUrlData();
            arg.mUrl = url;
            arg.mPostData = postData;
            mWebViewCore.sendMessage(EventHub.POST_URL, arg);
            clearHelpers();
        } else {
            loadUrlImpl(url);
        }
!!!5034380.java!!!	loadData(in data : String, in mimeType : String, in encoding : String) : void
        loadDataImpl(data, mimeType, encoding);
!!!5034508.java!!!	loadDataImpl(in data : String, in mimeType : String, in encoding : String) : void
        StringBuilder dataUrl = new StringBuilder("data:");
        dataUrl.append(mimeType);
        if ("base64".equals(encoding)) {
            dataUrl.append(";base64");
        }
        dataUrl.append(",");
        dataUrl.append(data);
        loadUrlImpl(dataUrl.toString());
!!!5034636.java!!!	loadDataWithBaseURL(in baseUrl : String, in data : String, in mimeType : String, in encoding : String, in historyUrl : String) : void

        if (baseUrl != null && baseUrl.toLowerCase().startsWith("data:")) {
            loadDataImpl(data, mimeType, encoding);
            return;
        }
        switchOutDrawHistory();
        WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
        arg.mBaseUrl = baseUrl;
        arg.mData = data;
        arg.mMimeType = mimeType;
        arg.mEncoding = encoding;
        arg.mHistoryUrl = historyUrl;
        mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
        clearHelpers();
!!!5034764.java!!!	saveWebArchive(in filename : String) : void
        saveWebArchiveImpl(filename, false, null);
!!!5035020.java!!!	saveWebArchive(in basename : String, inout autoname : boolean, inout callback : ValueCallback) : void
        saveWebArchiveImpl(basename, autoname, callback);
!!!5035148.java!!!	saveWebArchiveImpl(in basename : String, inout autoname : boolean, inout callback : ValueCallback) : void
        mWebViewCore.sendMessage(EventHub.SAVE_WEBARCHIVE,
            new SaveWebArchiveMessage(basename, autoname, callback));
!!!5035276.java!!!	stopLoading() : void
        // TODO: should we clear all the messages in the queue before sending
        // STOP_LOADING?
        switchOutDrawHistory();
        mWebViewCore.sendMessage(EventHub.STOP_LOADING);
!!!5035404.java!!!	reload() : void
        clearHelpers();
        switchOutDrawHistory();
        mWebViewCore.sendMessage(EventHub.RELOAD);
!!!5035532.java!!!	canGoBack() : boolean
        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
        synchronized (l) {
            if (l.getClearPending()) {
                return false;
            } else {
                return l.getCurrentIndex() > 0;
            }
        }
!!!5035660.java!!!	goBack() : void
        goBackOrForwardImpl(-1);
!!!5035788.java!!!	canGoForward() : boolean
        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
        synchronized (l) {
            if (l.getClearPending()) {
                return false;
            } else {
                return l.getCurrentIndex() < l.getSize() - 1;
            }
        }
!!!5035916.java!!!	goForward() : void
        goBackOrForwardImpl(1);
!!!5036044.java!!!	canGoBackOrForward(in steps : int) : boolean
        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
        synchronized (l) {
            if (l.getClearPending()) {
                return false;
            } else {
                int newIndex = l.getCurrentIndex() + steps;
                return newIndex >= 0 && newIndex < l.getSize();
            }
        }
!!!5036172.java!!!	goBackOrForward(in steps : int) : void
        goBackOrForwardImpl(steps);
!!!5036300.java!!!	goBackOrForwardImpl(in steps : int) : void
        goBackOrForward(steps, false);
!!!5036428.java!!!	goBackOrForward(in steps : int, inout ignoreSnapshot : boolean) : void
        if (steps != 0) {
            clearHelpers();
            mWebViewCore.sendMessage(EventHub.GO_BACK_FORWARD, steps,
                    ignoreSnapshot ? 1 : 0);
        }
!!!5036556.java!!!	isPrivateBrowsingEnabled() : boolean
        WebSettingsClassic settings = getSettings();
        return (settings != null) ? settings.isPrivateBrowsingEnabled() : false;
!!!5036684.java!!!	startPrivateBrowsing() : void
        getSettings().setPrivateBrowsingEnabled(true);
!!!5036812.java!!!	extendScroll(in y : int) : boolean
        int finalY = mScroller.getFinalY();
        int newY = pinLocY(finalY + y);
        if (newY == finalY) return false;
        mScroller.setFinalY(newY);
        mScroller.extendDuration(computeDuration(0, y));
        return true;
!!!5036940.java!!!	pageUp(inout top : boolean) : boolean
        if (mNativeClass == 0) {
            return false;
        }
        if (top) {
            // go to the top of the document
            return pinScrollTo(getScrollX(), 0, true, 0);
        }
        // Page up
        int h = getHeight();
        int y;
        if (h > 2 * PAGE_SCROLL_OVERLAP) {
            y = -h + PAGE_SCROLL_OVERLAP;
        } else {
            y = -h / 2;
        }
        return mScroller.isFinished() ? pinScrollBy(0, y, true, 0)
                : extendScroll(y);
!!!5037068.java!!!	pageDown(inout bottom : boolean) : boolean
        if (mNativeClass == 0) {
            return false;
        }
        if (bottom) {
            return pinScrollTo(getScrollX(), computeRealVerticalScrollRange(), true, 0);
        }
        // Page down.
        int h = getHeight();
        int y;
        if (h > 2 * PAGE_SCROLL_OVERLAP) {
            y = h - PAGE_SCROLL_OVERLAP;
        } else {
            y = h / 2;
        }
        return mScroller.isFinished() ? pinScrollBy(0, y, true, 0)
                : extendScroll(y);
!!!5037196.java!!!	clearView() : void
        mContentWidth = 0;
        mContentHeight = 0;
        setBaseLayer(0, false, false);
        mWebViewCore.sendMessage(EventHub.CLEAR_CONTENT);
!!!5037324.java!!!	capturePicture() : Picture
        if (mNativeClass == 0) return null;
        Picture result = new Picture();
        nativeCopyBaseContentToPicture(result);
        return result;
!!!5037452.java!!!	getScale() : float
        return mZoomManager.getScale();
!!!5037580.java!!!	computeReadingLevelScale(in scale : float) : float
        return mZoomManager.computeReadingLevelScale(scale);
!!!5037708.java!!!	setInitialScale(in scaleInPercent : int) : void
        mZoomManager.setInitialScaleInPercent(scaleInPercent);
!!!5037836.java!!!	invokeZoomPicker() : void
        if (!getSettings().supportZoom()) {
            Log.w(LOGTAG, "This WebView doesn't support zoom.");
            return;
        }
        clearHelpers();
        mZoomManager.invokeZoomPicker();
!!!5037964.java!!!	getHitTestResult() : HitTestResult
        return mInitialHitTestResult;
!!!5038092.java!!!	getBlockLeftEdge(in x : int, in y : int, in readingScale : float) : int
        float invReadingScale = 1.0f / readingScale;
        int readingWidth = (int) (getViewWidth() * invReadingScale);
        int left = NO_LEFTEDGE;
        if (mFocusedNode != null) {
            final int length = mFocusedNode.mEnclosingParentRects.length;
            for (int i = 0; i < length; i++) {
                Rect rect = mFocusedNode.mEnclosingParentRects[i];
                if (rect.width() < mFocusedNode.mHitTestSlop) {
                    // ignore bounding boxes that are too small
                    continue;
                } else if (rect.width() > readingWidth) {
                    // stop when bounding box doesn't fit the screen width
                    // at reading scale
                    break;
                }

                left = rect.left;
            }
        }

        return left;
!!!5038220.java!!!	requestFocusNodeHref(inout hrefMsg : Message) : void
        if (hrefMsg == null) {
            return;
        }
        int contentX = viewToContentX(mLastTouchX + getScrollX());
        int contentY = viewToContentY(mLastTouchY + getScrollY());
        if (mFocusedNode != null && mFocusedNode.mHitTestX == contentX
                && mFocusedNode.mHitTestY == contentY) {
            hrefMsg.getData().putString(FocusNodeHref.URL, mFocusedNode.mLinkUrl);
            hrefMsg.getData().putString(FocusNodeHref.TITLE, mFocusedNode.mAnchorText);
            hrefMsg.getData().putString(FocusNodeHref.SRC, mFocusedNode.mImageUrl);
            hrefMsg.sendToTarget();
            return;
        }
        mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF,
                contentX, contentY, hrefMsg);
!!!5038348.java!!!	requestImageRef(inout msg : Message) : void
        if (0 == mNativeClass) return; // client isn't initialized
        String url = mFocusedNode != null ? mFocusedNode.mImageUrl : null;
        Bundle data = msg.getData();
        data.putString("url", url);
        msg.setData(data);
        msg.sendToTarget();
!!!5038476.java!!!	pinLoc(in x : int, in viewMax : int, in docMax : int) : int
//        Log.d(LOGTAG, "-- pinLoc " + x + " " + viewMax + " " + docMax);
        if (docMax < viewMax) {   // the doc has room on the sides for "blank"
            // pin the short document to the top/left of the screen
            x = 0;
//            Log.d(LOGTAG, "--- center " + x);
        } else if (x < 0) {
            x = 0;
//            Log.d(LOGTAG, "--- zero");
        } else if (x + viewMax > docMax) {
            x = docMax - viewMax;
//            Log.d(LOGTAG, "--- pin " + x);
        }
        return x;
!!!5038604.java!!!	pinLocX(in x : int) : int
        if (mInOverScrollMode) return x;
        return pinLoc(x, getViewWidth(), computeRealHorizontalScrollRange());
!!!5038732.java!!!	pinLocY(in y : int) : int
        if (mInOverScrollMode) return y;
        return pinLoc(y, getViewHeightWithTitle(),
                      computeRealVerticalScrollRange() + getTitleHeight());
!!!5038860.java!!!	viewToContentDimension(in d : int) : int
        return Math.round(d * mZoomManager.getInvScale());
!!!5038988.java!!!	viewToContentX(in x : int) : int
        return viewToContentDimension(x);
!!!5039116.java!!!	viewToContentY(in y : int) : int
        return viewToContentDimension(y - getTitleHeight());
!!!5039244.java!!!	viewToContentXf(in x : int) : float
        return x * mZoomManager.getInvScale();
!!!5039372.java!!!	viewToContentYf(in y : int) : float
        return (y - getTitleHeight()) * mZoomManager.getInvScale();
!!!5039500.java!!!	contentToViewDimension(in d : int) : int
        return Math.round(d * mZoomManager.getScale());
!!!5039628.java!!!	contentToViewX(in x : int) : int
        return contentToViewDimension(x);
!!!5039756.java!!!	contentToViewY(in y : int) : int
        return contentToViewDimension(y) + getTitleHeight();
!!!5039884.java!!!	contentToViewRect(inout x : Rect) : Rect
        return new Rect(contentToViewX(x.left), contentToViewY(x.top),
                        contentToViewX(x.right), contentToViewY(x.bottom));
!!!5040012.java!!!	viewInvalidate(in l : int, in t : int, in r : int, in b : int) : void
        final float scale = mZoomManager.getScale();
        final int dy = getTitleHeight();
        mWebView.invalidate((int)Math.floor(l * scale),
                (int)Math.floor(t * scale) + dy,
                (int)Math.ceil(r * scale),
                (int)Math.ceil(b * scale) + dy);
!!!5040140.java!!!	viewInvalidateDelayed(in delay : long, in l : int, in t : int, in r : int, in b : int) : void
        final float scale = mZoomManager.getScale();
        final int dy = getTitleHeight();
        mWebView.postInvalidateDelayed(delay,
                (int)Math.floor(l * scale),
                (int)Math.floor(t * scale) + dy,
                (int)Math.ceil(r * scale),
                (int)Math.ceil(b * scale) + dy);
!!!5040268.java!!!	invalidateContentRect(inout r : Rect) : void
        viewInvalidate(r.left, r.top, r.right, r.bottom);
!!!5040396.java!!!	abortAnimation() : void
        mScroller.abortAnimation();
        mLastVelocity = 0;
!!!5040524.java!!!	recordNewContentSize(in w : int, in h : int, inout updateLayout : boolean) : void

        // premature data from webkit, ignore
        if ((w | h) == 0) {
            invalidate();
            return;
        }

        // don't abort a scroll animation if we didn't change anything
        if (mContentWidth != w || mContentHeight != h) {
            // record new dimensions
            mContentWidth = w;
            mContentHeight = h;
            // If history Picture is drawn, don't update scroll. They will be
            // updated when we get out of that mode.
            if (!mDrawHistory) {
                // repin our scroll, taking into account the new content size
                updateScrollCoordinates(pinLocX(getScrollX()), pinLocY(getScrollY()));
                if (!mScroller.isFinished()) {
                    // We are in the middle of a scroll.  Repin the final scroll
                    // position.
                    mScroller.setFinalX(pinLocX(mScroller.getFinalX()));
                    mScroller.setFinalY(pinLocY(mScroller.getFinalY()));
                }
            }
            invalidate();
        }
        contentSizeChanged(updateLayout);
!!!5040652.java!!!	sendOurVisibleRect() : Rect
        if (mZoomManager.isPreventingWebkitUpdates()) return mLastVisibleRectSent;
        calcOurContentVisibleRect(mVisibleRect);
        // Rect.equals() checks for null input.
        if (!mVisibleRect.equals(mLastVisibleRectSent)) {
            if (!mBlockWebkitViewMessages) {
                mScrollOffset.set(mVisibleRect.left, mVisibleRect.top);
                mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
                mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,
                        mSendScrollEvent ? 1 : 0, mScrollOffset);
            }
            mLastVisibleRectSent.set(mVisibleRect);
            mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
        }
        if (mWebView.getGlobalVisibleRect(mGlobalVisibleRect)
                && !mGlobalVisibleRect.equals(mLastGlobalRect)) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "sendOurVisibleRect=(" + mGlobalVisibleRect.left + ","
                        + mGlobalVisibleRect.top + ",r=" + mGlobalVisibleRect.right + ",b="
                        + mGlobalVisibleRect.bottom);
            }
            // TODO: the global offset is only used by windowRect()
            // in ChromeClientAndroid ; other clients such as touch
            // and mouse events could return view + screen relative points.
            if (!mBlockWebkitViewMessages) {
                mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS, mGlobalVisibleRect);
            }
            mLastGlobalRect.set(mGlobalVisibleRect);
        }
        return mVisibleRect;
!!!5040780.java!!!	calcOurVisibleRect(inout r : Rect) : void
        mWebView.getGlobalVisibleRect(r, mGlobalVisibleOffset);
        r.offset(-mGlobalVisibleOffset.x, -mGlobalVisibleOffset.y);
!!!5040908.java!!!	calcOurContentVisibleRect(inout r : Rect) : void
        calcOurVisibleRect(r);
        r.left = viewToContentX(r.left);
        // viewToContentY will remove the total height of the title bar.  Add
        // the visible height back in to account for the fact that if the title
        // bar is partially visible, the part of the visible rect which is
        // displaying our content is displaced by that amount.
        r.top = viewToContentY(r.top + getVisibleTitleHeightImpl());
        r.right = viewToContentX(r.right);
        r.bottom = viewToContentY(r.bottom);
!!!5041036.java!!!	calcOurContentVisibleRectF(inout r : RectF) : void
        calcOurVisibleRect(mTempContentVisibleRect);
        viewToContentVisibleRect(r, mTempContentVisibleRect);
!!!5041164.java!!!	sendViewSizeZoom(inout force : boolean) : boolean
        if (mBlockWebkitViewMessages) return false;
        if (mZoomManager.isPreventingWebkitUpdates()) return false;

        int viewWidth = getViewWidth();
        int newWidth = Math.round(viewWidth * mZoomManager.getInvScale());
        // This height could be fixed and be different from actual visible height.
        int viewHeight = getViewHeightWithTitle() - getTitleHeight();
        int newHeight = Math.round(viewHeight * mZoomManager.getInvScale());
        // Make the ratio more accurate than (newHeight / newWidth), since the
        // latter both are calculated and rounded.
        float heightWidthRatio = (float) viewHeight / viewWidth;
        /*
         * Because the native side may have already done a layout before the
         * View system was able to measure us, we have to send a height of 0 to
         * remove excess whitespace when we grow our width. This will trigger a
         * layout and a change in content size. This content size change will
         * mean that contentSizeChanged will either call this method directly or
         * indirectly from onSizeChanged.
         */
        if (newWidth > mLastWidthSent && mWrapContent) {
            newHeight = 0;
            heightWidthRatio = 0;
        }
        // Actual visible content height.
        int actualViewHeight = Math.round(getViewHeight() * mZoomManager.getInvScale());
        // Avoid sending another message if the dimensions have not changed.
        if (newWidth != mLastWidthSent || newHeight != mLastHeightSent || force ||
                actualViewHeight != mLastActualHeightSent) {
            ViewSizeData data = new ViewSizeData();
            data.mWidth = newWidth;
            data.mHeight = newHeight;
            data.mHeightWidthRatio = heightWidthRatio;
            data.mActualViewHeight = actualViewHeight;
            data.mTextWrapWidth = Math.round(viewWidth / mZoomManager.getTextWrapScale());
            data.mScale = mZoomManager.getScale();
            data.mIgnoreHeight = mZoomManager.isFixedLengthAnimationInProgress()
                    && !mHeightCanMeasure;
            data.mAnchorX = mZoomManager.getDocumentAnchorX();
            data.mAnchorY = mZoomManager.getDocumentAnchorY();
            mWebViewCore.sendMessage(EventHub.VIEW_SIZE_CHANGED, data);
            mLastWidthSent = newWidth;
            mLastHeightSent = newHeight;
            mLastActualHeightSent = actualViewHeight;
            mZoomManager.clearDocumentAnchor();
            return true;
        }
        return false;
!!!5041292.java!!!	updateDoubleTapZoom(in doubleTapZoom : int) : void
        mZoomManager.updateDoubleTapZoom(doubleTapZoom);
!!!5041420.java!!!	computeRealHorizontalScrollRange() : int
        if (mDrawHistory) {
            return mHistoryWidth;
        } else {
            // to avoid rounding error caused unnecessary scrollbar, use floor
            return (int) Math.floor(mContentWidth * mZoomManager.getScale());
        }
!!!5041548.java!!!	computeHorizontalScrollRange() : int
        int range = computeRealHorizontalScrollRange();

        // Adjust reported range if overscrolled to compress the scroll bars
        final int scrollX = getScrollX();
        final int overscrollRight = computeMaxScrollX();
        if (scrollX < 0) {
            range -= scrollX;
        } else if (scrollX > overscrollRight) {
            range += scrollX - overscrollRight;
        }

        return range;
!!!5041676.java!!!	computeHorizontalScrollOffset() : int
        return Math.max(getScrollX(), 0);
!!!5041804.java!!!	computeRealVerticalScrollRange() : int
        if (mDrawHistory) {
            return mHistoryHeight;
        } else {
            // to avoid rounding error caused unnecessary scrollbar, use floor
            return (int) Math.floor(mContentHeight * mZoomManager.getScale());
        }
!!!5041932.java!!!	computeVerticalScrollRange() : int
        int range = computeRealVerticalScrollRange();

        // Adjust reported range if overscrolled to compress the scroll bars
        final int scrollY = getScrollY();
        final int overscrollBottom = computeMaxScrollY();
        if (scrollY < 0) {
            range -= scrollY;
        } else if (scrollY > overscrollBottom) {
            range += scrollY - overscrollBottom;
        }

        return range;
!!!5042060.java!!!	computeVerticalScrollOffset() : int
        return Math.max(getScrollY() - getTitleHeight(), 0);
!!!5042188.java!!!	computeVerticalScrollExtent() : int
        return getViewHeight();
!!!5042316.java!!!	onDrawVerticalScrollBar(inout canvas : Canvas, inout scrollBar : Drawable, in l : int, in t : int, in r : int, in b : int) : void
        if (getScrollY() < 0) {
            t -= getScrollY();
        }
        scrollBar.setBounds(l, t + getVisibleTitleHeightImpl(), r, b);
        scrollBar.draw(canvas);
!!!5042444.java!!!	onOverScrolled(in scrollX : int, in scrollY : int, inout clampedX : boolean, inout clampedY : boolean) : void
        // Special-case layer scrolling so that we do not trigger normal scroll
        // updating.
        if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
            scrollEditText(scrollX, scrollY);
            return;
        }
        if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
            scrollLayerTo(scrollX, scrollY);
            animateHandles();
            return;
        }
        mInOverScrollMode = false;
        int maxX = computeMaxScrollX();
        int maxY = computeMaxScrollY();
        if (maxX == 0) {
            // do not over scroll x if the page just fits the screen
            scrollX = pinLocX(scrollX);
        } else if (scrollX < 0 || scrollX > maxX) {
            mInOverScrollMode = true;
        }
        if (scrollY < 0 || scrollY > maxY) {
            mInOverScrollMode = true;
        }

        int oldX = getScrollX();
        int oldY = getScrollY();

        mWebViewPrivate.super_scrollTo(scrollX, scrollY);

        animateHandles();

        if (mOverScrollGlow != null) {
            mOverScrollGlow.pullGlow(getScrollX(), getScrollY(), oldX, oldY, maxX, maxY);
        }
!!!5042572.java!!!	getUrl() : String
        WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
        return h != null ? h.getUrl() : null;
!!!5042700.java!!!	getOriginalUrl() : String
        WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
        return h != null ? h.getOriginalUrl() : null;
!!!5042828.java!!!	getTitle() : String
        WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
        return h != null ? h.getTitle() : null;
!!!5042956.java!!!	getFavicon() : Bitmap
        WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
        return h != null ? h.getFavicon() : null;
!!!5043084.java!!!	getTouchIconUrl() : String
        WebHistoryItemClassic h = mCallbackProxy.getBackForwardList().getCurrentItem();
        return h != null ? h.getTouchIconUrl() : null;
!!!5043212.java!!!	getProgress() : int
        return mCallbackProxy.getProgress();
!!!5043340.java!!!	getContentHeight() : int
        return mContentHeight;
!!!5043468.java!!!	getContentWidth() : int
        return mContentWidth;
!!!5043596.java!!!	getPageBackgroundColor() : int
        if (mNativeClass == 0) return Color.WHITE;
        return nativeGetBackgroundColor(mNativeClass);
!!!5043724.java!!!	pauseTimers() : void
        mWebViewCore.sendMessage(EventHub.PAUSE_TIMERS);
!!!5043852.java!!!	resumeTimers() : void
        mWebViewCore.sendMessage(EventHub.RESUME_TIMERS);
!!!5043980.java!!!	onPause() : void
        if (!mIsPaused) {
            mIsPaused = true;
            mWebViewCore.sendMessage(EventHub.ON_PAUSE);
            // We want to pause the current playing video when switching out
            // from the current WebView/tab.
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.pauseAndDispatch();
            }
            if (mNativeClass != 0) {
                nativeSetPauseDrawing(mNativeClass, true);
            }

            cancelDialogs();
            WebCoreThreadWatchdog.pause();
        }
!!!5044108.java!!!	onWindowVisibilityChanged(in visibility : int) : void
        updateDrawingState();
!!!5044236.java!!!	updateDrawingState() : void
        if (mNativeClass == 0 || mIsPaused) return;
        if (mWebView.getWindowVisibility() != View.VISIBLE) {
            nativeSetPauseDrawing(mNativeClass, true);
        } else if (mWebView.getVisibility() != View.VISIBLE) {
            nativeSetPauseDrawing(mNativeClass, true);
        } else {
            nativeSetPauseDrawing(mNativeClass, false);
        }
!!!5044364.java!!!	onResume() : void
        if (mIsPaused) {
            mIsPaused = false;
            mWebViewCore.sendMessage(EventHub.ON_RESUME);
            if (mNativeClass != 0) {
                nativeSetPauseDrawing(mNativeClass, false);
            }
        }
        // We get a call to onResume for new WebViews (i.e. mIsPaused will be false). We need
        // to ensure that the Watchdog thread is running for the new WebView, so call
        // it outside the if block above.
        WebCoreThreadWatchdog.resume();
!!!5044492.java!!!	isPaused() : boolean
        return mIsPaused;
!!!5044620.java!!!	freeMemory() : void
        mWebViewCore.sendMessage(EventHub.FREE_MEMORY);
!!!5044748.java!!!	clearCache(inout includeDiskFiles : boolean) : void
        // Note: this really needs to be a static method as it clears cache for all
        // WebView. But we need mWebViewCore to send message to WebCore thread, so
        // we can't make this static.
        mWebViewCore.sendMessage(EventHub.CLEAR_CACHE,
                includeDiskFiles ? 1 : 0, 0);
!!!5044876.java!!!	clearFormData() : void
        if (mAutoCompletePopup != null) {
            mAutoCompletePopup.clearAdapter();
        }
!!!5045004.java!!!	clearHistory() : void
        mCallbackProxy.getBackForwardList().setClearPending();
        mWebViewCore.sendMessage(EventHub.CLEAR_HISTORY);
!!!5045132.java!!!	clearSslPreferences() : void
        mWebViewCore.sendMessage(EventHub.CLEAR_SSL_PREF_TABLE);
!!!5045260.java!!!	copyBackForwardList() : WebBackForwardListClassic
        return mCallbackProxy.getBackForwardList().clone();
!!!5045388.java!!!	setFindListener(inout listener : FindListener) : void
         mFindListener = listener;
!!!5045516.java!!!	findNext(inout forward : boolean) : void
        if (0 == mNativeClass) return; // client isn't initialized
        if (mFindRequest != null) {
            mWebViewCore.sendMessage(EventHub.FIND_NEXT, forward ? 1 : 0, mFindRequest);
        }
!!!5045644.java!!!	findAll(in find : String) : int
        return findAllBody(find, false);
!!!5045772.java!!!	findAllAsync(in find : String) : void
        findAllBody(find, true);
!!!5045900.java!!!	findAllBody(in find : String, inout isAsync : boolean) : int
        if (0 == mNativeClass) return 0; // client isn't initialized
        mFindRequest = null;
        if (find == null) return 0;
        mWebViewCore.removeMessages(EventHub.FIND_ALL);
        mFindRequest = new WebViewCore.FindAllRequest(find);
        if (isAsync) {
            mWebViewCore.sendMessage(EventHub.FIND_ALL, mFindRequest);
            return 0; // no need to wait for response
        }
        synchronized(mFindRequest) {
            try {
                mWebViewCore.sendMessageAtFrontOfQueue(EventHub.FIND_ALL, mFindRequest);
                while (mFindRequest.mMatchCount == -1) {
                    mFindRequest.wait();
                }
            }
            catch (InterruptedException e) {
                return 0;
            }
            return mFindRequest.mMatchCount;
        }
!!!5046028.java!!!	showFindDialog(in text : String, inout showIme : boolean) : boolean
        FindActionModeCallback callback = new FindActionModeCallback(mContext);
        if (mWebView.getParent() == null || mWebView.startActionMode(callback) == null) {
            // Could not start the action mode, so end Find on page
            return false;
        }
        mCachedOverlappingActionModeHeight = -1;
        mFindCallback = callback;
        setFindIsUp(true);
        mFindCallback.setWebView(this);
        if (showIme) {
            mFindCallback.showSoftInput();
        } else if (text != null) {
            mFindCallback.setText(text);
            mFindCallback.findAll();
            return true;
        }
        if (text == null) {
            text = mFindRequest == null ? null : mFindRequest.mSearchText;
        }
        if (text != null) {
            mFindCallback.setText(text);
            mFindCallback.findAll();
        }
        return true;
!!!5046156.java!!!	setFindIsUp(inout isUp : boolean) : void
        mFindIsUp = isUp;
!!!5046284.java!!!	findAddress(in addr : String) : String
        return findAddress(addr, false);
!!!5046412.java!!!	findAddress(in addr : String, inout caseInsensitive : boolean) : String
        return WebViewCore.nativeFindAddress(addr, caseInsensitive);
!!!5046540.java!!!	clearMatches() : void
        if (mNativeClass == 0)
            return;
        mWebViewCore.removeMessages(EventHub.FIND_ALL);
        mWebViewCore.sendMessage(EventHub.FIND_ALL, null);
!!!5046668.java!!!	notifyFindDialogDismissed() : void
        mFindCallback = null;
        mCachedOverlappingActionModeHeight = -1;
        if (mWebViewCore == null) {
            return;
        }
        clearMatches();
        setFindIsUp(false);
        // Now that the dialog has been removed, ensure that we scroll to a
        // location that is not beyond the end of the page.
        pinScrollTo(getScrollX(), getScrollY(), false, 0);
        invalidate();
!!!5046796.java!!!	documentHasImages(inout response : Message) : void
        if (response == null) {
            return;
        }
        mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES, response);
!!!5046924.java!!!	stopScroll() : void
        mScroller.forceFinished(true);
        mLastVelocity = 0;
!!!5047052.java!!!	computeScroll() : void
        if (mScroller.computeScrollOffset()) {
            int oldX = getScrollX();
            int oldY = getScrollY();
            int x = mScroller.getCurrX();
            int y = mScroller.getCurrY();
            invalidate();  // So we draw again

            if (!mScroller.isFinished()) {
                int rangeX = computeMaxScrollX();
                int rangeY = computeMaxScrollY();
                int overflingDistance = mOverflingDistance;

                // Use the layer's scroll data if needed.
                if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
                    oldX = mScrollingLayerRect.left;
                    oldY = mScrollingLayerRect.top;
                    rangeX = mScrollingLayerRect.right;
                    rangeY = mScrollingLayerRect.bottom;
                    // No overscrolling for layers.
                    overflingDistance = 0;
                } else if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
                    oldX = getTextScrollX();
                    oldY = getTextScrollY();
                    rangeX = getMaxTextScrollX();
                    rangeY = getMaxTextScrollY();
                    overflingDistance = 0;
                }

                mWebViewPrivate.overScrollBy(x - oldX, y - oldY, oldX, oldY,
                        rangeX, rangeY,
                        overflingDistance, overflingDistance, false);

                if (mOverScrollGlow != null) {
                    mOverScrollGlow.absorbGlow(x, y, oldX, oldY, rangeX, rangeY);
                }
            } else {
                if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
                    // Update the layer position instead of WebView.
                    scrollLayerTo(x, y);
                } else if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
                    scrollEditText(x, y);
                } else {
                    setScrollXRaw(x);
                    setScrollYRaw(y);
                }
                abortAnimation();
                nativeSetIsScrolling(false);
                if (!mBlockWebkitViewMessages) {
                    WebViewCore.resumePriority();
                    if (!mSelectingText) {
                        WebViewCore.resumeUpdatePicture(mWebViewCore);
                    }
                }
                if (oldX != getScrollX() || oldY != getScrollY()) {
                    sendOurVisibleRect();
                }
            }
        } else {
            mWebViewPrivate.super_computeScroll();
        }
!!!5047180.java!!!	scrollLayerTo(in x : int, in y : int) : void
        int dx = mScrollingLayerRect.left - x;
        int dy = mScrollingLayerRect.top - y;
        if ((dx == 0 && dy == 0) || mNativeClass == 0) {
            return;
        }
        if (mSelectingText) {
            if (mSelectCursorBaseLayerId == mCurrentScrollingLayerId) {
                mSelectCursorBase.offset(dx, dy);
                mSelectCursorBaseTextQuad.offset(dx, dy);
            }
            if (mSelectCursorExtentLayerId == mCurrentScrollingLayerId) {
                mSelectCursorExtent.offset(dx, dy);
                mSelectCursorExtentTextQuad.offset(dx, dy);
            }
        }
        if (mAutoCompletePopup != null &&
                mCurrentScrollingLayerId == mEditTextLayerId) {
            mEditTextContentBounds.offset(dx, dy);
            mAutoCompletePopup.resetRect();
        }
        nativeScrollLayer(mNativeClass, mCurrentScrollingLayerId, x, y);
        mScrollingLayerRect.left = x;
        mScrollingLayerRect.top = y;
        mWebViewCore.sendMessage(WebViewCore.EventHub.SCROLL_LAYER, mCurrentScrollingLayerId,
                mScrollingLayerRect);
        mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY());
        invalidate();
!!!5047308.java!!!	computeDuration(in dx : int, in dy : int) : int
        int distance = Math.max(Math.abs(dx), Math.abs(dy));
        int duration = distance * 1000 / STD_SPEED;
        return Math.min(duration, MAX_DURATION);
!!!5047436.java!!!	pinScrollBy(in dx : int, in dy : int, inout animate : boolean, in animationDuration : int) : boolean
        return pinScrollTo(getScrollX() + dx, getScrollY() + dy, animate, animationDuration);
!!!5047564.java!!!	pinScrollTo(in x : int, in y : int, inout animate : boolean, in animationDuration : int) : boolean
        abortAnimation();
        x = pinLocX(x);
        y = pinLocY(y);
        int dx = x - getScrollX();
        int dy = y - getScrollY();

        if ((dx | dy) == 0) {
            return false;
        }
        if (animate) {
            //        Log.d(LOGTAG, "startScroll: " + dx + " " + dy);
            mScroller.startScroll(getScrollX(), getScrollY(), dx, dy,
                    animationDuration > 0 ? animationDuration : computeDuration(dx, dy));
            invalidate();
        } else {
            mWebView.scrollTo(x, y);
        }
        return true;
!!!5047692.java!!!	setContentScrollBy(in cx : int, in cy : int, inout animate : boolean) : boolean
        if (mDrawHistory) {
            // disallow WebView to change the scroll position as History Picture
            // is used in the view system.
            // TODO: as we switchOutDrawHistory when trackball or navigation
            // keys are hit, this should be safe. Right?
            return false;
        }
        cx = contentToViewDimension(cx);
        cy = contentToViewDimension(cy);
        if (mHeightCanMeasure) {
            // move our visible rect according to scroll request
            if (cy != 0) {
                Rect tempRect = new Rect();
                calcOurVisibleRect(tempRect);
                tempRect.offset(cx, cy);
                mWebView.requestRectangleOnScreen(tempRect);
            }
            // FIXME: We scroll horizontally no matter what because currently
            // ScrollView and ListView will not scroll horizontally.
            // FIXME: Why do we only scroll horizontally if there is no
            // vertical scroll?
//                Log.d(LOGTAG, "setContentScrollBy cy=" + cy);
            return cy == 0 && cx != 0 && pinScrollBy(cx, 0, animate, 0);
        } else {
            return pinScrollBy(cx, cy, animate, 0);
        }
!!!5047820.java!!!	onPageStarted(in url : String) : void
        // every time we start a new page, we want to reset the
        // WebView certificate:  if the new site is secure, we
        // will reload it and get a new certificate set;
        // if the new site is not secure, the certificate must be
        // null, and that will be the case
        mWebView.setCertificate(null);

        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().onPageStarted(url);
        }

        // Don't start out editing.
        mIsEditingText = false;
!!!5047948.java!!!	onPageFinished(in url : String) : void
        mZoomManager.onPageFinished(url);

        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().onPageFinished(url);
        }
!!!5048076.java!!!	contentScrollTo(in cx : int, in cy : int, inout animate : boolean) : void
        if (mDrawHistory) {
            // disallow WebView to change the scroll position as History Picture
            // is used in the view system.
            return;
        }
        int vx = contentToViewX(cx);
        int vy = contentToViewY(cy);
        pinScrollTo(vx, vy, animate, 0);
!!!5048204.java!!!	contentSizeChanged(inout updateLayout : boolean) : void
        // suppress 0,0 since we usually see real dimensions soon after
        // this avoids drawing the prev content in a funny place. If we find a
        // way to consolidate these notifications, this check may become
        // obsolete
        if ((mContentWidth | mContentHeight) == 0) {
            return;
        }

        if (mHeightCanMeasure) {
            if (mWebView.getMeasuredHeight() != contentToViewDimension(mContentHeight)
                    || updateLayout) {
                mWebView.requestLayout();
            }
        } else if (mWidthCanMeasure) {
            if (mWebView.getMeasuredWidth() != contentToViewDimension(mContentWidth)
                    || updateLayout) {
                mWebView.requestLayout();
            }
        } else {
            // If we don't request a layout, try to send our view size to the
            // native side to ensure that WebCore has the correct dimensions.
            sendViewSizeZoom(false);
        }
!!!5048332.java!!!	setWebViewClient(inout client : WebViewClient) : void
        mCallbackProxy.setWebViewClient(client);
!!!5048460.java!!!	getWebViewClient() : WebViewClient
        return mCallbackProxy.getWebViewClient();
!!!5048588.java!!!	setDownloadListener(inout listener : DownloadListener) : void
        mCallbackProxy.setDownloadListener(listener);
!!!5048716.java!!!	setWebChromeClient(inout client : WebChromeClient) : void
        mCallbackProxy.setWebChromeClient(client);
!!!5048844.java!!!	getWebChromeClient() : WebChromeClient
        return mCallbackProxy.getWebChromeClient();
!!!5048972.java!!!	setWebBackForwardListClient(inout client : WebBackForwardListClient) : void
        mCallbackProxy.setWebBackForwardListClient(client);
!!!5049100.java!!!	getWebBackForwardListClient() : WebBackForwardListClient
        return mCallbackProxy.getWebBackForwardListClient();
!!!5049228.java!!!	setPictureListener(inout listener : PictureListener) : void
        mPictureListener = listener;
!!!5049356.java!!!	externalRepresentation(inout callback : Message) : void
        mWebViewCore.sendMessage(EventHub.REQUEST_EXT_REPRESENTATION, callback);
!!!5049484.java!!!	documentAsText(inout callback : Message) : void
        mWebViewCore.sendMessage(EventHub.REQUEST_DOC_AS_TEXT, callback);
!!!5049612.java!!!	addJavascriptInterface(inout object : Object, in name : String) : void

        if (object == null) {
            return;
        }
        WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();

        arg.mObject = object;
        arg.mInterfaceName = name;

        // starting with JELLY_BEAN_MR1, annotations are mandatory for enabling access to
        // methods that are accessible from JS.
        if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            arg.mRequireAnnotation = true;
        } else {
            arg.mRequireAnnotation = false;
        }
        mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
!!!5049740.java!!!	removeJavascriptInterface(in interfaceName : String) : void
        if (mWebViewCore != null) {
            WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
            arg.mInterfaceName = interfaceName;
            mWebViewCore.sendMessage(EventHub.REMOVE_JS_INTERFACE, arg);
        }
!!!5049868.java!!!	getSettings() : WebSettingsClassic
        return (mWebViewCore != null) ? mWebViewCore.getSettings() : null;
!!!5049996.java!!!	getPluginList() : PluginList
        return new PluginList();
!!!5050252.java!!!	finalize() : void
        try {
            destroy();
        } finally {
            super.finalize();
        }
!!!5050380.java!!!	drawContent(inout canvas : Canvas) : void
        if (mDrawHistory) {
            canvas.scale(mZoomManager.getScale(), mZoomManager.getScale());
            canvas.drawPicture(mHistoryPicture);
            return;
        }
        if (mNativeClass == 0) return;

        boolean animateZoom = mZoomManager.isFixedLengthAnimationInProgress();
        boolean animateScroll = ((!mScroller.isFinished()
                || mVelocityTracker != null)
                && (mTouchMode != TOUCH_DRAG_MODE ||
                mHeldMotionless != MOTIONLESS_TRUE));
        if (mTouchMode == TOUCH_DRAG_MODE) {
            if (mHeldMotionless == MOTIONLESS_PENDING) {
                mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
                mHeldMotionless = MOTIONLESS_FALSE;
            }
            if (mHeldMotionless == MOTIONLESS_FALSE) {
                mPrivateHandler.sendMessageDelayed(mPrivateHandler
                        .obtainMessage(DRAG_HELD_MOTIONLESS), MOTIONLESS_TIME);
                mHeldMotionless = MOTIONLESS_PENDING;
            }
        }
        int saveCount = canvas.save();
        if (animateZoom) {
            mZoomManager.animateZoom(canvas);
        } else if (!canvas.isHardwareAccelerated()) {
            canvas.scale(mZoomManager.getScale(), mZoomManager.getScale());
        }

        boolean UIAnimationsRunning = false;
        // Currently for each draw we compute the animation values;
        // We may in the future decide to do that independently.
        if (mNativeClass != 0 && !canvas.isHardwareAccelerated()
                && nativeEvaluateLayersAnimations(mNativeClass)) {
            UIAnimationsRunning = true;
            // If we have unfinished (or unstarted) animations,
            // we ask for a repaint. We only need to do this in software
            // rendering (with hardware rendering we already have a different
            // method of requesting a repaint)
            mWebViewCore.sendMessage(EventHub.NOTIFY_ANIMATION_STARTED);
            invalidate();
        }

        // decide which adornments to draw
        int extras = DRAW_EXTRAS_NONE;
        if (!mFindIsUp && mShowTextSelectionExtra) {
            extras = DRAW_EXTRAS_SELECTION;
        }

        calcOurContentVisibleRectF(mVisibleContentRect);
        if (canvas.isHardwareAccelerated()) {
            Rect invScreenRect = mIsWebViewVisible ? mInvScreenRect : null;
            Rect screenRect = mIsWebViewVisible ? mScreenRect : null;

            int functor = nativeCreateDrawGLFunction(mNativeClass, invScreenRect,
                    screenRect, mVisibleContentRect, getScale(), extras);
            ((HardwareCanvas) canvas).callDrawGLFunction(functor);
            if (mHardwareAccelSkia != getSettings().getHardwareAccelSkiaEnabled()) {
                mHardwareAccelSkia = getSettings().getHardwareAccelSkiaEnabled();
                nativeUseHardwareAccelSkia(mHardwareAccelSkia);
            }

        } else {
            DrawFilter df = null;
            if (mZoomManager.isZoomAnimating() || UIAnimationsRunning) {
                df = mZoomFilter;
            } else if (animateScroll) {
                df = mScrollFilter;
            }
            canvas.setDrawFilter(df);
            nativeDraw(canvas, mVisibleContentRect, mBackgroundColor, extras);
            canvas.setDrawFilter(null);
        }

        canvas.restoreToCount(saveCount);
        drawTextSelectionHandles(canvas);

        if (extras == DRAW_EXTRAS_CURSOR_RING) {
            if (mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                mTouchMode = TOUCH_SHORTPRESS_MODE;
            }
        }
!!!5050508.java!!!	drawOverScrollBackground(inout canvas : Canvas) : void
        if (mOverScrollBackground == null) {
            mOverScrollBackground = new Paint();
            Bitmap bm = BitmapFactory.decodeResource(
                    mContext.getResources(),
                    com.android.internal.R.drawable.status_bar_background);
            mOverScrollBackground.setShader(new BitmapShader(bm,
                    Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
            mOverScrollBorder = new Paint();
            mOverScrollBorder.setStyle(Paint.Style.STROKE);
            mOverScrollBorder.setStrokeWidth(0);
            mOverScrollBorder.setColor(0xffbbbbbb);
        }

        int top = 0;
        int right = computeRealHorizontalScrollRange();
        int bottom = top + computeRealVerticalScrollRange();
        // first draw the background and anchor to the top of the view
        canvas.save();
        canvas.translate(getScrollX(), getScrollY());
        canvas.clipRect(-getScrollX(), top - getScrollY(), right - getScrollX(), bottom
                - getScrollY(), Region.Op.DIFFERENCE);
        canvas.drawPaint(mOverScrollBackground);
        canvas.restore();
        // then draw the border
        canvas.drawRect(-1, top - 1, right, bottom, mOverScrollBorder);
        // next clip the region for the content
        canvas.clipRect(0, top, right, bottom);
!!!5050636.java!!!	onDraw(inout canvas : Canvas) : void
        if (inFullScreenMode()) {
            return; // no need to draw anything if we aren't visible.
        }
        // if mNativeClass is 0, the WebView is either destroyed or not
        // initialized. In either case, just draw the background color and return
        if (mNativeClass == 0) {
            canvas.drawColor(mBackgroundColor);
            return;
        }

        // if both mContentWidth and mContentHeight are 0, it means there is no
        // valid Picture passed to WebView yet. This can happen when WebView
        // just starts. Draw the background and return.
        if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
            canvas.drawColor(mBackgroundColor);
            return;
        }

        if (canvas.isHardwareAccelerated()) {
            mZoomManager.setHardwareAccelerated();
        } else {
            mWebViewCore.resumeWebKitDraw();
        }

        int saveCount = canvas.save();
        if (mInOverScrollMode && !getSettings()
                .getUseWebViewBackgroundForOverscrollBackground()) {
            drawOverScrollBackground(canvas);
        }

        canvas.translate(0, getTitleHeight());
        drawContent(canvas);
        canvas.restoreToCount(saveCount);

        if (AUTO_REDRAW_HACK && mAutoRedraw) {
            invalidate();
        }
        mWebViewCore.signalRepaintDone();

        if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
            invalidate();
        }

        if (mFocusTransition != null) {
            mFocusTransition.draw(canvas);
        } else if (shouldDrawHighlightRect()) {
            RegionIterator iter = new RegionIterator(mTouchHighlightRegion);
            Rect r = new Rect();
            while (iter.next(r)) {
                canvas.drawRect(r, mTouchHightlightPaint);
            }
        }
        if (DEBUG_TOUCH_HIGHLIGHT) {
            if (getSettings().getNavDump()) {
                if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                    if (mTouchCrossHairColor == null) {
                        mTouchCrossHairColor = new Paint();
                        mTouchCrossHairColor.setColor(Color.RED);
                    }
                    canvas.drawLine(mTouchHighlightX - mNavSlop,
                            mTouchHighlightY - mNavSlop, mTouchHighlightX
                                    + mNavSlop + 1, mTouchHighlightY + mNavSlop
                                    + 1, mTouchCrossHairColor);
                    canvas.drawLine(mTouchHighlightX + mNavSlop + 1,
                            mTouchHighlightY - mNavSlop, mTouchHighlightX
                                    - mNavSlop,
                            mTouchHighlightY + mNavSlop + 1,
                            mTouchCrossHairColor);
                }
            }
        }
!!!5050764.java!!!	removeTouchHighlight() : void
        setTouchHighlightRects(null);
!!!5050892.java!!!	setLayoutParams(inout params : LayoutParams) : void
        if (params.height == AbsoluteLayout.LayoutParams.WRAP_CONTENT) {
            mWrapContent = true;
        }
        mWebViewPrivate.super_setLayoutParams(params);
!!!5051020.java!!!	performLongClick() : boolean
        // performLongClick() is the result of a delayed message. If we switch
        // to windows overview, the WebView will be temporarily removed from the
        // view system. In that case, do nothing.
        if (mWebView.getParent() == null) return false;

        // A multi-finger gesture can look like a long press; make sure we don't take
        // long press actions if we're scaling.
        final ScaleGestureDetector detector = mZoomManager.getScaleGestureDetector();
        if (detector != null && detector.isInProgress()) {
            return false;
        }

        if (mSelectingText) return false; // long click does nothing on selection
        /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
        if (mWebViewPrivate.super_performLongClick()) {
            return true;
        }
        /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
        final boolean isSelecting = selectText();
        if (isSelecting) {
            mWebView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        } else if (focusCandidateIsEditableText()) {
            mSelectCallback = new SelectActionModeCallback();
            mSelectCallback.setWebView(this);
            mSelectCallback.setTextSelected(false);
            mWebView.startActionMode(mSelectCallback);
        }
        return isSelecting;
!!!5051148.java!!!	selectText() : boolean
        int x = viewToContentX(mLastTouchX + getScrollX());
        int y = viewToContentY(mLastTouchY + getScrollY());
        return selectText(x, y);
!!!5051276.java!!!	selectText(in x : int, in y : int) : boolean
        if (mWebViewCore == null) {
            return false;
        }
        mWebViewCore.sendMessage(EventHub.SELECT_WORD_AT, x, y);
        return true;
!!!5051404.java!!!	onConfigurationChanged(inout newConfig : Configuration) : void
        mCachedOverlappingActionModeHeight = -1;
        if (mSelectingText && mOrientation != newConfig.orientation) {
            selectionDone();
        }
        mOrientation = newConfig.orientation;
        if (mWebViewCore != null && !mBlockWebkitViewMessages) {
            mWebViewCore.sendMessage(EventHub.CLEAR_CONTENT);
        }
!!!5051532.java!!!	setBaseLayer(in layer : int, inout showVisualIndicator : boolean, inout isPictureAfterFirstLayout : boolean) : void
        if (mNativeClass == 0)
            return;
        boolean queueFull;
        final int scrollingLayer = (mTouchMode == TOUCH_DRAG_LAYER_MODE)
                ? mCurrentScrollingLayerId : 0;
        queueFull = nativeSetBaseLayer(mNativeClass, layer,
                                       showVisualIndicator, isPictureAfterFirstLayout,
                                       scrollingLayer);

        if (queueFull) {
            mWebViewCore.pauseWebKitDraw();
        } else {
            mWebViewCore.resumeWebKitDraw();
        }

        if (mHTML5VideoViewProxy != null) {
            mHTML5VideoViewProxy.setBaseLayer(layer);
        }
!!!5051660.java!!!	getBaseLayer() : int
        if (mNativeClass == 0) {
            return 0;
        }
        return nativeGetBaseLayer(mNativeClass);
!!!5051916.java!!!	onZoomAnimationEnd() : void
        mPrivateHandler.sendEmptyMessage(RELOCATE_AUTO_COMPLETE_POPUP);
!!!5052044.java!!!	onFixedLengthZoomAnimationStart() : void
        WebViewCore.pauseUpdatePicture(getWebViewCore());
        onZoomAnimationStart();
!!!5052172.java!!!	onFixedLengthZoomAnimationEnd() : void
        if (!mBlockWebkitViewMessages && !mSelectingText) {
            WebViewCore.resumeUpdatePicture(mWebViewCore);
        }
        onZoomAnimationEnd();
!!!5052812.java!!!	startSelectingText() : void
        mSelectingText = true;
        mShowTextSelectionExtra = true;
        animateHandles();
!!!5052940.java!!!	animateHandle(inout canShow : boolean, inout animator : ObjectAnimator, inout selectionPoint : Point, in selectionLayerId : int, inout alpha : SelectionHandleAlpha) : void
        boolean isVisible = canShow && mSelectingText
                && ((mSelectionStarted && mSelectDraggingCursor == selectionPoint)
                || isHandleVisible(selectionPoint, selectionLayerId));
        int targetValue = isVisible ? 255 : 0;
        if (targetValue != alpha.getTargetAlpha()) {
            alpha.setTargetAlpha(targetValue);
            animator.setIntValues(targetValue);
            animator.setDuration(SELECTION_HANDLE_ANIMATION_MS);
            animator.start();
        }
!!!5053068.java!!!	animateHandles() : void
        boolean canShowBase = mSelectingText;
        boolean canShowExtent = mSelectingText && !mIsCaretSelection;
        animateHandle(canShowBase, mBaseHandleAlphaAnimator, mSelectCursorBase,
                mSelectCursorBaseLayerId, mBaseAlpha);
        animateHandle(canShowExtent, mExtentHandleAlphaAnimator,
                mSelectCursorExtent, mSelectCursorExtentLayerId,
                mExtentAlpha);
!!!5053196.java!!!	endSelectingText() : void
        mSelectingText = false;
        mShowTextSelectionExtra = false;
        animateHandles();
!!!5053324.java!!!	ensureSelectionHandles() : void
        if (mSelectHandleCenter == null) {
            mSelectHandleCenter = mContext.getResources().getDrawable(
                    com.android.internal.R.drawable.text_select_handle_middle).mutate();
            mSelectHandleLeft = mContext.getResources().getDrawable(
                    com.android.internal.R.drawable.text_select_handle_left).mutate();
            mSelectHandleRight = mContext.getResources().getDrawable(
                    com.android.internal.R.drawable.text_select_handle_right).mutate();
            // All handles have the same height, so we can save effort with
            // this assumption.
            mSelectOffset = new Point(0,
                    -mSelectHandleLeft.getIntrinsicHeight());
        }
!!!5053452.java!!!	drawHandle(inout point : Point, in handleId : int, inout bounds : Rect, in alpha : int, inout canvas : Canvas) : void
        int offset;
        int width;
        int height;
        Drawable drawable;
        boolean isLeft = nativeIsHandleLeft(mNativeClass, handleId);
        if (isLeft) {
            drawable = mSelectHandleLeft;
            width = mSelectHandleLeft.getIntrinsicWidth();
            height = mSelectHandleLeft.getIntrinsicHeight();
            // Magic formula copied from TextView
            offset = (width * 3) / 4;
        } else {
            drawable = mSelectHandleRight;
            width = mSelectHandleRight.getIntrinsicWidth();
            height = mSelectHandleRight.getIntrinsicHeight();
            // Magic formula copied from TextView
            offset = width / 4;
        }
        int x = contentToViewDimension(point.x);
        int y = contentToViewDimension(point.y);
        bounds.set(x - offset, y, x - offset + width, y + height);
        drawable.setBounds(bounds);
        drawable.setAlpha(alpha);
        drawable.draw(canvas);
!!!5053580.java!!!	drawTextSelectionHandles(inout canvas : Canvas) : void
        if (mBaseAlpha.getAlpha() == 0 && mExtentAlpha.getAlpha() == 0) {
            return;
        }
        ensureSelectionHandles();
        if (mIsCaretSelection) {
            // Caret handle is centered
            int x = contentToViewDimension(mSelectCursorBase.x) -
                    (mSelectHandleCenter.getIntrinsicWidth() / 2);
            int y = contentToViewDimension(mSelectCursorBase.y);
            mSelectHandleBaseBounds.set(x, y,
                    x + mSelectHandleCenter.getIntrinsicWidth(),
                    y + mSelectHandleCenter.getIntrinsicHeight());
            mSelectHandleCenter.setBounds(mSelectHandleBaseBounds);
            mSelectHandleCenter.setAlpha(mBaseAlpha.getAlpha());
            mSelectHandleCenter.draw(canvas);
        } else {
            drawHandle(mSelectCursorBase, HANDLE_ID_BASE,
                    mSelectHandleBaseBounds, mBaseAlpha.getAlpha(), canvas);
            drawHandle(mSelectCursorExtent, HANDLE_ID_EXTENT,
                    mSelectHandleExtentBounds, mExtentAlpha.getAlpha(), canvas);
        }
!!!5053708.java!!!	isHandleVisible(inout selectionPoint : Point, in layerId : int) : boolean
        boolean isVisible = true;
        if (mIsEditingText) {
            isVisible = mEditTextContentBounds.contains(selectionPoint.x,
                    selectionPoint.y);
        }
        if (isVisible) {
            isVisible = nativeIsPointVisible(mNativeClass, layerId,
                    selectionPoint.x, selectionPoint.y);
        }
        return isVisible;
!!!5053836.java!!!	getSelectionHandles(inout handles : int) : void
        handles[0] = mSelectCursorBase.x;
        handles[1] = mSelectCursorBase.y;
        handles[2] = mSelectCursorExtent.x;
        handles[3] = mSelectCursorExtent.y;
!!!5053964.java!!!	drawHistory() : boolean
        return mDrawHistory;
!!!5054092.java!!!	getHistoryPictureWidth() : int
        return (mHistoryPicture != null) ? mHistoryPicture.getWidth() : 0;
!!!5054220.java!!!	switchOutDrawHistory() : void
        if (null == mWebViewCore) return; // CallbackProxy may trigger this
        if (mDrawHistory && (getProgress() == 100 || nativeHasContent())) {
            mDrawHistory = false;
            mHistoryPicture = null;
            invalidate();
            int oldScrollX = getScrollX();
            int oldScrollY = getScrollY();
            setScrollXRaw(pinLocX(getScrollX()));
            setScrollYRaw(pinLocY(getScrollY()));
            if (oldScrollX != getScrollX() || oldScrollY != getScrollY()) {
                mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), oldScrollX, oldScrollY);
            } else {
                sendOurVisibleRect();
            }
        }
!!!5054348.java!!!	deleteSelection(in start : int, in end : int) : void
        mTextGeneration++;
        WebViewCore.TextSelectionData data
                = new WebViewCore.TextSelectionData(start, end, 0);
        mWebViewCore.sendMessage(EventHub.DELETE_SELECTION, mTextGeneration, 0,
                data);
!!!5054476.java!!!	setSelection(in start : int, in end : int) : void
        if (mWebViewCore != null) {
            mWebViewCore.sendMessage(EventHub.SET_SELECTION, start, end);
        }
!!!5054604.java!!!	onCreateInputConnection(inout outAttrs : EditorInfo) : InputConnection
        if (mInputConnection == null) {
            mInputConnection = new WebViewInputConnection();
            mAutoCompletePopup = new AutoCompletePopup(this, mInputConnection);
        }
        mInputConnection.setupEditorInfo(outAttrs);
        return mInputConnection;
!!!5054732.java!!!	relocateAutoCompletePopup() : void
        if (mAutoCompletePopup != null) {
            mAutoCompletePopup.resetRect();
            mAutoCompletePopup.setText(mInputConnection.getEditable());
        }
!!!5054860.java!!!	displaySoftKeyboard(inout isTextView : boolean) : void
        InputMethodManager imm = (InputMethodManager)
                mContext.getSystemService(Context.INPUT_METHOD_SERVICE);

        // bring it back to the default level scale so that user can enter text
        boolean zoom = mZoomManager.getScale() < mZoomManager.getDefaultScale();
        if (zoom) {
            mZoomManager.setZoomCenter(mLastTouchX, mLastTouchY);
            mZoomManager.setZoomScale(mZoomManager.getDefaultScale(), false);
        }
        // Used by plugins and contentEditable.
        // Also used if the navigation cache is out of date, and
        // does not recognize that a textfield is in focus.  In that
        // case, use WebView as the targeted view.
        // see http://b/issue?id=2457459
        imm.showSoftInput(mWebView, 0);
!!!5054988.java!!!	hideSoftKeyboard() : void
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && (imm.isActive(mWebView))) {
            imm.hideSoftInputFromWindow(mWebView.getWindowToken(), 0);
        }
!!!5055116.java!!!	requestFormData(in name : String, in nodePointer : int, inout autoFillable : boolean, inout autoComplete : boolean) : void
        if (mWebViewCore.getSettings().getSaveFormData()) {
            Message update = mPrivateHandler.obtainMessage(REQUEST_FORM_DATA);
            update.arg1 = nodePointer;
            RequestFormData updater = new RequestFormData(name, getUrl(),
                    update, autoFillable, autoComplete);
            Thread t = new Thread(updater);
            t.start();
        }
!!!5055500.java!!!	dumpDisplayTree() : void
        nativeDumpDisplayTree(getUrl());
!!!5055628.java!!!	dumpDomTree(inout toFile : boolean) : void
        mWebViewCore.sendMessage(EventHub.DUMP_DOMTREE, toFile ? 1 : 0, 0);
!!!5055756.java!!!	dumpRenderTree(inout toFile : boolean) : void
        mWebViewCore.sendMessage(EventHub.DUMP_RENDERTREE, toFile ? 1 : 0, 0);
!!!5055884.java!!!	setUseMockDeviceOrientation() : void
        mWebViewCore.sendMessage(EventHub.SET_USE_MOCK_DEVICE_ORIENTATION);
!!!5056012.java!!!	setUseMockGeolocation() : void
        mWebViewCore.sendMessage(EventHub.SET_USE_MOCK_GEOLOCATION);
!!!5056140.java!!!	setMockGeolocationPosition(in latitude : double, in longitude : double, in accuracy : double) : void
        mWebViewCore.setMockGeolocationPosition(latitude, longitude, accuracy);
!!!5056268.java!!!	setMockGeolocationError(in code : int, in message : String) : void
        mWebViewCore.setMockGeolocationError(code, message);
!!!5056396.java!!!	setMockGeolocationPermission(inout allow : boolean) : void
        mWebViewCore.setMockGeolocationPermission(allow);
!!!5056524.java!!!	setMockDeviceOrientation(inout canProvideAlpha : boolean, in alpha : double, inout canProvideBeta : boolean, in beta : double, inout canProvideGamma : boolean, in gamma : double) : void
        mWebViewCore.setMockDeviceOrientation(canProvideAlpha, alpha, canProvideBeta, beta,
                canProvideGamma, gamma);
!!!5056652.java!!!	onKeyMultiple(in keyCode : int, in repeatCount : int, inout event : KeyEvent) : boolean
        if (mBlockWebkitViewMessages) {
            return false;
        }
        // send complex characters to webkit for use by JS and plugins
        if (keyCode == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null) {
            // pass the key to DOM
            sendBatchableInputMessage(EventHub.KEY_DOWN, 0, 0, event);
            sendBatchableInputMessage(EventHub.KEY_UP, 0, 0, event);
            // return true as DOM handles the key
            return true;
        }
        return false;
!!!5056780.java!!!	isEnterActionKey(in keyCode : int) : boolean
        return keyCode == KeyEvent.KEYCODE_DPAD_CENTER
                || keyCode == KeyEvent.KEYCODE_ENTER
                || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER;
!!!5056908.java!!!	onKeyPreIme(in keyCode : int, inout event : KeyEvent) : boolean
        if (mAutoCompletePopup != null) {
            return mAutoCompletePopup.onKeyPreIme(keyCode, event);
        }
        return false;
!!!5057036.java!!!	onKeyDown(in keyCode : int, inout event : KeyEvent) : boolean
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "keyDown at " + System.currentTimeMillis()
                    + "keyCode=" + keyCode
                    + ", " + event + ", unicode=" + event.getUnicodeChar());
        }
        if (mIsCaretSelection) {
            selectionDone();
        }
        if (mBlockWebkitViewMessages) {
            return false;
        }

        // don't implement accelerator keys here; defer to host application
        if (event.isCtrlPressed()) {
            return false;
        }

        if (mNativeClass == 0) {
            return false;
        }

        // do this hack up front, so it always works, regardless of touch-mode
        if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
            mAutoRedraw = !mAutoRedraw;
            if (mAutoRedraw) {
                invalidate();
            }
            return true;
        }

        // Bubble up the key event if
        // 1. it is a system key; or
        // 2. the host application wants to handle it;
        if (event.isSystem()
                || mCallbackProxy.uiOverrideKeyEvent(event)) {
            return false;
        }

        // See if the accessibility injector needs to handle this event.
        if (isAccessibilityInjectionEnabled()
                && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
            return true;
        }

        if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
            if (event.hasNoModifiers()) {
                pageUp(false);
                return true;
            } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                pageUp(true);
                return true;
            }
        }

        if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
            if (event.hasNoModifiers()) {
                pageDown(false);
                return true;
            } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                pageDown(true);
                return true;
            }
        }

        if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
            pageUp(true);
            return true;
        }

        if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
            pageDown(true);
            return true;
        }

        if (keyCode >= KeyEvent.KEYCODE_DPAD_UP
                && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
            switchOutDrawHistory();
        }

        if (isEnterActionKey(keyCode)) {
            switchOutDrawHistory();
            if (event.getRepeatCount() == 0) {
                if (mSelectingText) {
                    return true; // discard press if copy in progress
                }
                mGotCenterDown = true;
                mPrivateHandler.sendMessageDelayed(mPrivateHandler
                        .obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            }
        }

        if (getSettings().getNavDump()) {
            switch (keyCode) {
                case KeyEvent.KEYCODE_4:
                    dumpDisplayTree();
                    break;
                case KeyEvent.KEYCODE_5:
                case KeyEvent.KEYCODE_6:
                    dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                    break;
                case KeyEvent.KEYCODE_7:
                case KeyEvent.KEYCODE_8:
                    dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                    break;
            }
        }

        // pass the key to DOM
        sendKeyEvent(event);
        // return true as DOM handles the key
        return true;
!!!5057164.java!!!	onKeyUp(in keyCode : int, inout event : KeyEvent) : boolean
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "keyUp at " + System.currentTimeMillis()
                    + ", " + event + ", unicode=" + event.getUnicodeChar());
        }
        if (mBlockWebkitViewMessages) {
            return false;
        }

        if (mNativeClass == 0) {
            return false;
        }

        // special CALL handling when cursor node's href is "tel:XXX"
        if (keyCode == KeyEvent.KEYCODE_CALL
                && mInitialHitTestResult != null
                && mInitialHitTestResult.getType() == HitTestResult.PHONE_TYPE) {
            String text = mInitialHitTestResult.getExtra();
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            mContext.startActivity(intent);
            return true;
        }

        // Bubble up the key event if
        // 1. it is a system key; or
        // 2. the host application wants to handle it;
        if (event.isSystem()
                || mCallbackProxy.uiOverrideKeyEvent(event)) {
            return false;
        }

        // See if the accessibility injector needs to handle this event.
        if (isAccessibilityInjectionEnabled()
                && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
            return true;
        }

        if (isEnterActionKey(keyCode)) {
            // remove the long press message first
            mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
            mGotCenterDown = false;

            if (mSelectingText) {
                copySelection();
                selectionDone();
                return true; // discard press if copy in progress
            }
        }

        // pass the key to DOM
        sendKeyEvent(event);
        // return true as DOM handles the key
        return true;
!!!5057292.java!!!	startSelectActionMode() : boolean
        mSelectCallback = new SelectActionModeCallback();
        mSelectCallback.setTextSelected(!mIsCaretSelection);
        mSelectCallback.setWebView(this);
        if (mWebView.startActionMode(mSelectCallback) == null) {
            // There is no ActionMode, so do not allow the user to modify a
            // selection.
            selectionDone();
            return false;
        }
        mWebView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        return true;
!!!5057420.java!!!	showPasteWindow() : void
        ClipboardManager cm = (ClipboardManager)(mContext
                .getSystemService(Context.CLIPBOARD_SERVICE));
        if (cm.hasPrimaryClip()) {
            Point cursorPoint = new Point(contentToViewX(mSelectCursorBase.x),
                    contentToViewY(mSelectCursorBase.y));
            Point cursorTop = calculateBaseCaretTop();
            cursorTop.set(contentToViewX(cursorTop.x),
                    contentToViewY(cursorTop.y));

            int[] location = new int[2];
            mWebView.getLocationInWindow(location);
            int offsetX = location[0] - getScrollX();
            int offsetY = location[1] - getScrollY();
            cursorPoint.offset(offsetX, offsetY);
            cursorTop.offset(offsetX, offsetY);
            if (mPasteWindow == null) {
                mPasteWindow = new PastePopupWindow();
            }
            mPasteWindow.show(cursorPoint, cursorTop, location[0], location[1]);
        }
!!!5057548.java!!!	scaleAlongSegment(in x : int, in y : int, inout a : PointF, inout b : PointF) : float
        // The bottom line of the text box is line AB
        float abX = b.x - a.x;
        float abY = b.y - a.y;
        float ab2 = (abX * abX) + (abY * abY);

        // The line from first point in text bounds to bottom is AP
        float apX = x - a.x;
        float apY = y - a.y;
        float abDotAP = (apX * abX) + (apY * abY);
        float scale = abDotAP / ab2;
        return scale;
!!!5057676.java!!!	calculateBaseCaretTop() : Point
        return calculateCaretTop(mSelectCursorBase, mSelectCursorBaseTextQuad);
!!!5057804.java!!!	calculateDraggingCaretTop() : Point
        return calculateCaretTop(mSelectDraggingCursor, mSelectDraggingTextQuad);
!!!5057932.java!!!	calculateCaretTop(inout base : Point, inout quad : QuadF) : Point
        float scale = scaleAlongSegment(base.x, base.y, quad.p4, quad.p3);
        int x = Math.round(scaleCoordinate(scale, quad.p1.x, quad.p2.x));
        int y = Math.round(scaleCoordinate(scale, quad.p1.y, quad.p2.y));
        return new Point(x, y);
!!!5058060.java!!!	hidePasteButton() : void
        if (mPasteWindow != null) {
            mPasteWindow.hide();
        }
!!!5058188.java!!!	syncSelectionCursors() : void
        mSelectCursorBaseLayerId =
                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_BASE,
                        mSelectCursorBase, mSelectCursorBaseTextQuad);
        mSelectCursorExtentLayerId =
                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_EXTENT,
                        mSelectCursorExtent, mSelectCursorExtentTextQuad);
!!!5058316.java!!!	setupWebkitSelect() : boolean
        syncSelectionCursors();
        if (!mIsCaretSelection && !startSelectActionMode()) {
            selectionDone();
            return false;
        }
        startSelectingText();
        mTouchMode = TOUCH_DRAG_MODE;
        return true;
!!!5058444.java!!!	updateWebkitSelection(inout isSnapped : boolean) : void
        int handleId = (mSelectDraggingCursor == mSelectCursorBase)
                ? HANDLE_ID_BASE : HANDLE_ID_EXTENT;
        int x = mSelectDraggingCursor.x;
        int y = mSelectDraggingCursor.y;
        if (isSnapped) {
            // "center" the cursor in the snapping quad
            Point top = calculateDraggingCaretTop();
            x = Math.round((top.x + x) / 2);
            y = Math.round((top.y + y) / 2);
        }
        mWebViewCore.removeMessages(EventHub.SELECT_TEXT);
        mWebViewCore.sendMessageAtFrontOfQueue(EventHub.SELECT_TEXT,
                x, y, (Integer)handleId);
!!!5058572.java!!!	resetCaretTimer() : void
        mPrivateHandler.removeMessages(CLEAR_CARET_HANDLE);
        if (!mSelectionStarted) {
            mPrivateHandler.sendEmptyMessageDelayed(CLEAR_CARET_HANDLE,
                    CARET_HANDLE_STAMINA_MS);
        }
!!!5058700.java!!!	selectAll() : void
        mWebViewCore.sendMessage(EventHub.SELECT_ALL);
!!!5058828.java!!!	selectionDone() : void
        if (mSelectingText) {
            hidePasteButton();
            endSelectingText();
            // finish is idempotent, so this is fine even if selectionDone was
            // called by mSelectCallback.onDestroyActionMode
            if (mSelectCallback != null) {
                mSelectCallback.finish();
                mSelectCallback = null;
            }
            invalidate(); // redraw without selection
            mAutoScrollX = 0;
            mAutoScrollY = 0;
            mSentAutoScrollMessage = false;
        }
!!!5058956.java!!!	copySelection() : boolean
        boolean copiedSomething = false;
        String selection = getSelection();
        if (selection != null && selection != "") {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "copySelection \"" + selection + "\"");
            }
            Toast.makeText(mContext
                    , com.android.internal.R.string.text_copied
                    , Toast.LENGTH_SHORT).show();
            copiedSomething = true;
            ClipboardManager cm = (ClipboardManager)mContext
                    .getSystemService(Context.CLIPBOARD_SERVICE);
            cm.setText(selection);
            int[] handles = new int[4];
            getSelectionHandles(handles);
            mWebViewCore.sendMessage(EventHub.COPY_TEXT, handles);
        }
        invalidate(); // remove selection region and pointer
        return copiedSomething;
!!!5059084.java!!!	cutSelection() : void
        copySelection();
        int[] handles = new int[4];
        getSelectionHandles(handles);
        mWebViewCore.sendMessage(EventHub.DELETE_TEXT, handles);
!!!5059212.java!!!	pasteFromClipboard() : void
        ClipboardManager cm = (ClipboardManager)mContext
                .getSystemService(Context.CLIPBOARD_SERVICE);
        ClipData clipData = cm.getPrimaryClip();
        if (clipData != null) {
            ClipData.Item clipItem = clipData.getItemAt(0);
            CharSequence pasteText = clipItem.getText();
            if (mInputConnection != null) {
                mInputConnection.replaceSelection(pasteText);
            }
        }
!!!5059340.java!!!	getSelection() : String
        if (mNativeClass == 0) return "";
        return nativeGetSelection();
!!!5059468.java!!!	onAttachedToWindow() : void
        if (mWebView.hasWindowFocus()) setActive(true);

        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().toggleAccessibilityFeedback(true);
        }

        updateHwAccelerated();
!!!5059596.java!!!	onDetachedFromWindow() : void
        clearHelpers();
        mZoomManager.dismissZoomPicker();
        if (mWebView.hasWindowFocus()) setActive(false);

        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().toggleAccessibilityFeedback(false);
        }

        updateHwAccelerated();

        ensureFunctorDetached();
!!!5059724.java!!!	onVisibilityChanged(inout changedView : View, in visibility : int) : void
        // The zoomManager may be null if the webview is created from XML that
        // specifies the view's visibility param as not visible (see http://b/2794841)
        if (visibility != View.VISIBLE && mZoomManager != null) {
            mZoomManager.dismissZoomPicker();
        }
        updateDrawingState();
!!!5059852.java!!!	setActive(inout active : boolean) : void
        if (active) {
            if (mWebView.hasFocus()) {
                // If our window regained focus, and we have focus, then begin
                // drawing the cursor ring
                mDrawCursorRing = true;
                setFocusControllerActive(true);
            } else {
                mDrawCursorRing = false;
                setFocusControllerActive(false);
            }
        } else {
            if (!mZoomManager.isZoomPickerVisible()) {
                /*
                 * The external zoom controls come in their own window, so our
                 * window loses focus. Our policy is to not draw the cursor ring
                 * if our window is not focused, but this is an exception since
                 * the user can still navigate the web page with the zoom
                 * controls showing.
                 */
                mDrawCursorRing = false;
            }
            mKeysPressed.clear();
            mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
            mTouchMode = TOUCH_DONE_MODE;
            setFocusControllerActive(false);
        }
        invalidate();
!!!5059980.java!!!	onWindowFocusChanged(inout hasWindowFocus : boolean) : void
        setActive(hasWindowFocus);
        if (hasWindowFocus) {
            JWebCoreJavaBridge.setActiveWebView(this);
            if (mPictureUpdatePausedForFocusChange) {
                WebViewCore.resumeUpdatePicture(mWebViewCore);
                mPictureUpdatePausedForFocusChange = false;
            }
        } else {
            JWebCoreJavaBridge.removeActiveWebView(this);
            final WebSettings settings = getSettings();
            if (settings != null && settings.enableSmoothTransition() &&
                    mWebViewCore != null && !WebViewCore.isUpdatePicturePaused(mWebViewCore)) {
                WebViewCore.pauseUpdatePicture(mWebViewCore);
                mPictureUpdatePausedForFocusChange = true;
            }
        }
!!!5060108.java!!!	setFocusControllerActive(inout active : boolean) : void
        if (mWebViewCore == null) return;
        mWebViewCore.sendMessage(EventHub.SET_ACTIVE, active ? 1 : 0, 0);
        // Need to send this message after the document regains focus.
        if (active && mListBoxMessage != null) {
            mWebViewCore.sendMessage(mListBoxMessage);
            mListBoxMessage = null;
        }
!!!5060236.java!!!	onFocusChanged(inout focused : boolean, in direction : int, inout previouslyFocusedRect : Rect) : void
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "MT focusChanged " + focused + ", " + direction);
        }
        if (focused) {
            mDrawCursorRing = true;
            setFocusControllerActive(true);
        } else {
            mDrawCursorRing = false;
            setFocusControllerActive(false);
            mKeysPressed.clear();
        }
        if (!mTouchHighlightRegion.isEmpty()) {
            mWebView.invalidate(mTouchHighlightRegion.getBounds());
        }
!!!5060364.java!!!	updateRectsForGL() : void
        // Use the getGlobalVisibleRect() to get the intersection among the parents
        // visible == false means we're clipped - send a null rect down to indicate that
        // we should not draw
        boolean visible = mWebView.getGlobalVisibleRect(mTempVisibleRect, mTempVisibleRectOffset);
        mInvScreenRect.set(mTempVisibleRect);
        if (visible) {
            // Then need to invert the Y axis, just for GL
            View rootView = mWebView.getRootView();
            int rootViewHeight = rootView.getHeight();
            mScreenRect.set(mInvScreenRect);
            int savedWebViewBottom = mInvScreenRect.bottom;
            mInvScreenRect.bottom = rootViewHeight - mInvScreenRect.top - getVisibleTitleHeightImpl();
            mInvScreenRect.top = rootViewHeight - savedWebViewBottom;
            mIsWebViewVisible = true;
        } else {
            mIsWebViewVisible = false;
        }

        mTempVisibleRect.offset(-mTempVisibleRectOffset.x, -mTempVisibleRectOffset.y);
        viewToContentVisibleRect(mVisibleContentRect, mTempVisibleRect);

        nativeUpdateDrawGLFunction(mNativeClass, mIsWebViewVisible ? mInvScreenRect : null,
                mIsWebViewVisible ? mScreenRect : null,
                mVisibleContentRect, getScale());
!!!5060492.java!!!	viewToContentVisibleRect(inout contentRect : RectF, inout viewRect : Rect) : void
        contentRect.left = viewToContentXf(viewRect.left) / mWebView.getScaleX();
        // viewToContentY will remove the total height of the title bar.  Add
        // the visible height back in to account for the fact that if the title
        // bar is partially visible, the part of the visible rect which is
        // displaying our content is displaced by that amount.
        contentRect.top = viewToContentYf(viewRect.top + getVisibleTitleHeightImpl())
                / mWebView.getScaleY();
        contentRect.right = viewToContentXf(viewRect.right) / mWebView.getScaleX();
        contentRect.bottom = viewToContentYf(viewRect.bottom) / mWebView.getScaleY();
!!!5060620.java!!!	setFrame(in left : int, in top : int, in right : int, in bottom : int) : boolean
        boolean changed = mWebViewPrivate.super_setFrame(left, top, right, bottom);
        if (!changed && mHeightCanMeasure) {
            // When mHeightCanMeasure is true, we will set mLastHeightSent to 0
            // in WebViewCore after we get the first layout. We do call
            // requestLayout() when we get contentSizeChanged(). But the View
            // system won't call onSizeChanged if the dimension is not changed.
            // In this case, we need to call sendViewSizeZoom() explicitly to
            // notify the WebKit about the new dimensions.
            sendViewSizeZoom(false);
        }
        updateRectsForGL();
        return changed;
!!!5060748.java!!!	onSizeChanged(in w : int, in h : int, in ow : int, in oh : int) : void
        // adjust the max viewport width depending on the view dimensions. This
        // is to ensure the scaling is not going insane. So do not shrink it if
        // the view size is temporarily smaller, e.g. when soft keyboard is up.
        int newMaxViewportWidth = (int) (Math.max(w, h) / mZoomManager.getDefaultMinZoomScale());
        if (newMaxViewportWidth > sMaxViewportWidth) {
            sMaxViewportWidth = newMaxViewportWidth;
        }

        mZoomManager.onSizeChanged(w, h, ow, oh);

        if (mLoadedPicture != null && mDelaySetPicture == null) {
            // Size changes normally result in a new picture
            // Re-set the loaded picture to simulate that
            // However, do not update the base layer as that hasn't changed
            setNewPicture(mLoadedPicture, false);
        }
        if (mIsEditingText) {
            scrollEditIntoView();
        }
        relocateAutoCompletePopup();
!!!5060876.java!!!	scrollEditIntoView() : void
        Rect visibleRect = new Rect(viewToContentX(getScrollX()),
                viewToContentY(getScrollY()),
                viewToContentX(getScrollX() + getWidth()),
                viewToContentY(getScrollY() + getViewHeightWithTitle()));
        if (visibleRect.contains(mEditTextContentBounds)) {
            return; // no need to scroll
        }
        syncSelectionCursors();
        nativeFindMaxVisibleRect(mNativeClass, mEditTextLayerId, visibleRect);
        final int buffer = Math.max(1, viewToContentDimension(EDIT_RECT_BUFFER));
        Rect showRect = new Rect(
                Math.max(0, mEditTextContentBounds.left - buffer),
                Math.max(0, mEditTextContentBounds.top - buffer),
                mEditTextContentBounds.right + buffer,
                mEditTextContentBounds.bottom + buffer);
        Point caretTop = calculateBaseCaretTop();
        if (visibleRect.width() < mEditTextContentBounds.width()) {
            // The whole edit won't fit in the width, so use the caret rect
            if (mSelectCursorBase.x < caretTop.x) {
                showRect.left = Math.max(0, mSelectCursorBase.x - buffer);
                showRect.right = caretTop.x + buffer;
            } else {
                showRect.left = Math.max(0, caretTop.x - buffer);
                showRect.right = mSelectCursorBase.x + buffer;
            }
        }
        if (visibleRect.height() < mEditTextContentBounds.height()) {
            // The whole edit won't fit in the height, so use the caret rect
            if (mSelectCursorBase.y > caretTop.y) {
                showRect.top = Math.max(0, caretTop.y - buffer);
                showRect.bottom = mSelectCursorBase.y + buffer;
            } else {
                showRect.top = Math.max(0, mSelectCursorBase.y - buffer);
                showRect.bottom = caretTop.y + buffer;
            }
        }

        if (visibleRect.contains(showRect)) {
            return; // no need to scroll
        }

        int scrollX = viewToContentX(getScrollX());
        if (visibleRect.left > showRect.left) {
            // We are scrolled too far
            scrollX += showRect.left - visibleRect.left;
        } else if (visibleRect.right < showRect.right) {
            // We aren't scrolled enough to include the right
            scrollX += showRect.right - visibleRect.right;
        }
        int scrollY = viewToContentY(getScrollY());
        if (visibleRect.top > showRect.top) {
            scrollY += showRect.top - visibleRect.top;
        } else if (visibleRect.bottom < showRect.bottom) {
            scrollY += showRect.bottom - visibleRect.bottom;
        }

        contentScrollTo(scrollX, scrollY, false);
!!!5061004.java!!!	onScrollChanged(in l : int, in t : int, in oldl : int, in oldt : int) : void
        if (!mInOverScrollMode) {
            sendOurVisibleRect();
            // update WebKit if visible title bar height changed. The logic is same
            // as getVisibleTitleHeightImpl.
            int titleHeight = getTitleHeight();
            if (Math.max(titleHeight - t, 0) != Math.max(titleHeight - oldt, 0)) {
                sendViewSizeZoom(false);
            }
        }
!!!5061132.java!!!	dispatchKeyEvent(inout event : KeyEvent) : boolean
        switch (event.getAction()) {
            case KeyEvent.ACTION_DOWN:
                mKeysPressed.add(Integer.valueOf(event.getKeyCode()));
                break;
            case KeyEvent.ACTION_MULTIPLE:
                // Always accept the action.
                break;
            case KeyEvent.ACTION_UP:
                int location = mKeysPressed.indexOf(Integer.valueOf(event.getKeyCode()));
                if (location == -1) {
                    // We did not receive the key down for this key, so do not
                    // handle the key up.
                    return false;
                } else {
                    // We did receive the key down.  Handle the key up, and
                    // remove it from our pressed keys.
                    mKeysPressed.remove(location);
                }
                break;
            default:
                // Accept the action.  This should not happen, unless a new
                // action is added to KeyEvent.
                break;
        }
        return mWebViewPrivate.super_dispatchKeyEvent(event);
!!!5061260.java!!!	inFullScreenMode() : boolean
        return mFullScreenHolder != null;
!!!5061388.java!!!	dismissFullScreenMode() : void
        if (inFullScreenMode()) {
            mFullScreenHolder.hide();
            mFullScreenHolder = null;
            invalidate();
        }
!!!5061516.java!!!	onPinchToZoomAnimationStart() : void
        // cancel the single touch handling
        cancelTouch();
        onZoomAnimationStart();
!!!5061644.java!!!	onPinchToZoomAnimationEnd(inout detector : ScaleGestureDetector) : void
        onZoomAnimationEnd();
        // start a drag, TOUCH_PINCH_DRAG, can't use TOUCH_INIT_MODE as
        // it may trigger the unwanted click, can't use TOUCH_DRAG_MODE
        // as it may trigger the unwanted fling.
        mTouchMode = TOUCH_PINCH_DRAG;
        mConfirmMove = true;
        startTouch(detector.getFocusX(), detector.getFocusY(), mLastTouchTime);
!!!5061772.java!!!	startScrollingLayer(in x : float, in y : float) : void
        if (mNativeClass == 0)
            return;

        int contentX = viewToContentX((int) x + getScrollX());
        int contentY = viewToContentY((int) y + getScrollY());
        mCurrentScrollingLayerId = nativeScrollableLayer(mNativeClass,
                contentX, contentY, mScrollingLayerRect, mScrollingLayerBounds);
        if (mCurrentScrollingLayerId != 0) {
            mTouchMode = TOUCH_DRAG_LAYER_MODE;
        }
!!!5061900.java!!!	onHoverEvent(inout event : MotionEvent) : boolean
        if (mNativeClass == 0) {
            return false;
        }
        int x = viewToContentX((int) event.getX() + getScrollX());
        int y = viewToContentY((int) event.getY() + getScrollY());
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, x, y);
        mWebViewPrivate.super_onHoverEvent(event);
        return true;
!!!5062028.java!!!	onTouchEvent(inout ev : MotionEvent) : boolean
        if (mNativeClass == 0 || (!mWebView.isClickable() && !mWebView.isLongClickable())) {
            return false;
        }

        if (mInputDispatcher == null) {
            return false;
        }

        if (mWebView.isFocusable() && mWebView.isFocusableInTouchMode()
                && !mWebView.isFocused()) {
            mWebView.requestFocus();
        }

        if (mInputDispatcher.postPointerEvent(ev, getScrollX(),
                getScrollY() - getTitleHeight(), mZoomManager.getInvScale())) {
            mInputDispatcher.dispatchUiEvents();
            return true;
        } else {
            Log.w(LOGTAG, "mInputDispatcher rejected the event!");
            return false;
        }
!!!5062156.java!!!	calculateDragAngle(in dx : int, in dy : int) : float
        dx = Math.abs(dx);
        dy = Math.abs(dy);
        return (float) Math.atan2(dy, dx);
!!!5062284.java!!!	handleTouchEventCommon(inout event : MotionEvent, in action : int, in x : int, in y : int) : void
        ScaleGestureDetector detector = mZoomManager.getScaleGestureDetector();

        long eventTime = event.getEventTime();

        // Due to the touch screen edge effect, a touch closer to the edge
        // always snapped to the edge. As getViewWidth() can be different from
        // getWidth() due to the scrollbar, adjusting the point to match
        // getViewWidth(). Same applied to the height.
        x = Math.min(x, getViewWidth() - 1);
        y = Math.min(y, getViewHeightWithTitle() - 1);

        int deltaX = mLastTouchX - x;
        int deltaY = mLastTouchY - y;
        int contentX = viewToContentX(x + getScrollX());
        int contentY = viewToContentY(y + getScrollY());

        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                mConfirmMove = false;
                if (!mEditTextScroller.isFinished()) {
                    mEditTextScroller.abortAnimation();
                }
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mConfirmMove = true;
                    nativeSetIsScrolling(false);
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    removeTouchHighlight();
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        mTouchMode = TOUCH_INIT_MODE;
                    }
                } else { // the normal case
                    mTouchMode = TOUCH_INIT_MODE;
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,
                                (eventTime - mLastTouchUpTime), eventTime);
                    }
                    mSelectionStarted = false;
                    if (mSelectingText) {
                        ensureSelectionHandles();
                        int shiftedY = y - getTitleHeight() + getScrollY();
                        int shiftedX = x + getScrollX();
                        if (mSelectHandleBaseBounds.contains(shiftedX, shiftedY)) {
                            mSelectionStarted = true;
                            mSelectDraggingCursor = mSelectCursorBase;
                            mSelectDraggingTextQuad = mSelectCursorBaseTextQuad;
                            if (mIsCaretSelection) {
                                mPrivateHandler.removeMessages(CLEAR_CARET_HANDLE);
                                hidePasteButton();
                            }
                        } else if (mSelectHandleExtentBounds
                                .contains(shiftedX, shiftedY)) {
                            mSelectionStarted = true;
                            mSelectDraggingCursor = mSelectCursorExtent;
                            mSelectDraggingTextQuad = mSelectCursorExtentTextQuad;
                        } else if (mIsCaretSelection) {
                            selectionDone();
                        }
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, "select=" + contentX + "," + contentY);
                        }
                    }
                }
                // Trigger the link
                if (!mSelectingText && (mTouchMode == TOUCH_INIT_MODE
                        || mTouchMode == TOUCH_DOUBLE_TAP_MODE)) {
                    mPrivateHandler.sendEmptyMessageDelayed(
                            SWITCH_TO_SHORTPRESS, TAP_TIMEOUT);
                    mPrivateHandler.sendEmptyMessageDelayed(
                            SWITCH_TO_LONGPRESS, LONG_PRESS_TIMEOUT);
                }
                startTouch(x, y, eventTime);
                if (mIsEditingText) {
                    mTouchInEditText = mEditTextContentBounds
                            .contains(contentX, contentY);
                }
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY)
                        >= mTouchSlopSquare) {
                    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    mConfirmMove = true;
                    if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mTouchMode = TOUCH_INIT_MODE;
                    }
                    removeTouchHighlight();
                }
                if (mSelectingText && mSelectionStarted) {
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, "extend=" + contentX + "," + contentY);
                    }
                    ViewParent parent = mWebView.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                    if (deltaX != 0 || deltaY != 0) {
                        int handleX = contentX +
                                viewToContentDimension(mSelectOffset.x);
                        int handleY = contentY +
                                viewToContentDimension(mSelectOffset.y);
                        mSelectDraggingCursor.set(handleX, handleY);
                        boolean inCursorText =
                                mSelectDraggingTextQuad.containsPoint(handleX, handleY);
                        boolean inEditBounds = mEditTextContentBounds
                                .contains(handleX, handleY);
                        if (mIsEditingText && !inEditBounds) {
                            beginScrollEdit();
                        } else {
                            endScrollEdit();
                        }
                        boolean snapped = false;
                        if (inCursorText || (mIsEditingText && !inEditBounds)) {
                            snapDraggingCursor();
                            snapped = true;
                        }
                        updateWebkitSelection(snapped);
                        if (!inCursorText && mIsEditingText && inEditBounds) {
                            // Visually snap even if we have moved the handle.
                            snapDraggingCursor();
                        }
                        mLastTouchX = x;
                        mLastTouchY = y;
                        invalidate();
                    }
                    break;
                }

                if (mTouchMode == TOUCH_DONE_MODE) {
                    // no dragging during scroll zoom animation, or when prevent
                    // default is yes
                    break;
                }
                if (mVelocityTracker == null) {
                    Log.e(LOGTAG, "Got null mVelocityTracker when "
                            + " mTouchMode = " + mTouchMode);
                } else {
                    mVelocityTracker.addMovement(event);
                }

                if (mTouchMode != TOUCH_DRAG_MODE &&
                        mTouchMode != TOUCH_DRAG_LAYER_MODE &&
                        mTouchMode != TOUCH_DRAG_TEXT_MODE) {

                    if (!mConfirmMove) {
                        break;
                    }

                    // Only lock dragging to one axis if we don't have a scale in progress.
                    // Scaling implies free-roaming movement. Note this is only ever a question
                    // if mZoomManager.supportsPanDuringZoom() is true.
                    mAverageAngle = calculateDragAngle(deltaX, deltaY);
                    if (detector == null || !detector.isInProgress()) {
                        // if it starts nearly horizontal or vertical, enforce it
                        if (mAverageAngle < HSLOPE_TO_START_SNAP) {
                            mSnapScrollMode = SNAP_X;
                            mSnapPositive = deltaX > 0;
                            mAverageAngle = ANGLE_HORIZ;
                        } else if (mAverageAngle > VSLOPE_TO_START_SNAP) {
                            mSnapScrollMode = SNAP_Y;
                            mSnapPositive = deltaY > 0;
                            mAverageAngle = ANGLE_VERT;
                        }
                    }

                    mTouchMode = TOUCH_DRAG_MODE;
                    mLastTouchX = x;
                    mLastTouchY = y;
                    deltaX = 0;
                    deltaY = 0;

                    startScrollingLayer(x, y);
                    startDrag();
                }

                // do pan
                boolean keepScrollBarsVisible = false;
                if (deltaX == 0 && deltaY == 0) {
                    keepScrollBarsVisible = true;
                } else {
                    mAverageAngle +=
                        (calculateDragAngle(deltaX, deltaY) - mAverageAngle)
                        / MMA_WEIGHT_N;
                    if (mSnapScrollMode != SNAP_NONE) {
                        if (mSnapScrollMode == SNAP_Y) {
                            // radical change means getting out of snap mode
                            if (mAverageAngle < VSLOPE_TO_BREAK_SNAP) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                        }
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (mAverageAngle > HSLOPE_TO_BREAK_SNAP) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                        }
                    } else {
                        if (mAverageAngle < HSLOPE_TO_START_SNAP) {
                            mSnapScrollMode = SNAP_X;
                            mSnapPositive = deltaX > 0;
                            mAverageAngle = (mAverageAngle + ANGLE_HORIZ) / 2;
                        } else if (mAverageAngle > VSLOPE_TO_START_SNAP) {
                            mSnapScrollMode = SNAP_Y;
                            mSnapPositive = deltaY > 0;
                            mAverageAngle = (mAverageAngle + ANGLE_VERT) / 2;
                        }
                    }
                    if (mSnapScrollMode != SNAP_NONE) {
                        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
                            deltaY = 0;
                        } else {
                            deltaX = 0;
                        }
                    }
                    if (deltaX * deltaX + deltaY * deltaY > mTouchSlopSquare) {
                        mHeldMotionless = MOTIONLESS_FALSE;
                    } else {
                        mHeldMotionless = MOTIONLESS_TRUE;
                        keepScrollBarsVisible = true;
                    }

                    mLastTouchTime = eventTime;
                    boolean allDrag = doDrag(deltaX, deltaY);
                    if (allDrag) {
                        mLastTouchX = x;
                        mLastTouchY = y;
                    } else {
                        int contentDeltaX = (int)Math.floor(deltaX * mZoomManager.getInvScale());
                        int roundedDeltaX = contentToViewDimension(contentDeltaX);
                        int contentDeltaY = (int)Math.floor(deltaY * mZoomManager.getInvScale());
                        int roundedDeltaY = contentToViewDimension(contentDeltaY);
                        mLastTouchX -= roundedDeltaX;
                        mLastTouchY -= roundedDeltaY;
                    }
                }

                break;
            }
            case MotionEvent.ACTION_UP: {
                if (mIsEditingText && mSelectionStarted) {
                    endScrollEdit();
                    mPrivateHandler.sendEmptyMessageDelayed(SCROLL_HANDLE_INTO_VIEW,
                            TEXT_SCROLL_FIRST_SCROLL_MS);
                    if (!mConfirmMove && mIsCaretSelection) {
                        showPasteWindow();
                        stopTouch();
                        break;
                    }
                }
                mLastTouchUpTime = eventTime;
                if (mSentAutoScrollMessage) {
                    mAutoScrollX = mAutoScrollY = 0;
                }
                switch (mTouchMode) {
                    case TOUCH_DOUBLE_TAP_MODE: // double tap
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        break;
                    case TOUCH_INIT_MODE: // tap
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (!mConfirmMove) {
                            if (mSelectingText) {
                                // tapping on selection or controls does nothing
                                if (!mSelectionStarted) {
                                    selectionDone();
                                }
                                break;
                            }
                            // only trigger double tap if the WebView is
                            // scalable
                            if (mTouchMode == TOUCH_INIT_MODE
                                    && (canZoomIn() || canZoomOut())) {
                                mPrivateHandler.sendEmptyMessageDelayed(
                                        RELEASE_SINGLE_TAP, ViewConfiguration
                                                .getDoubleTapTimeout());
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                    case TOUCH_DRAG_LAYER_MODE:
                    case TOUCH_DRAG_TEXT_MODE:
                        mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
                        // if the user waits a while w/o moving before the
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            if (mVelocityTracker == null) {
                                Log.e(LOGTAG, "Got null mVelocityTracker");
                            } else {
                                mVelocityTracker.addMovement(event);
                            }
                            // set to MOTIONLESS_IGNORE so that it won't keep
                            // removing and sending message in
                            // drawCoreAndCursorRing()
                            mHeldMotionless = MOTIONLESS_IGNORE;
                            doFling();
                            break;
                        } else {
                            if (mScroller.springBack(getScrollX(), getScrollY(), 0,
                                    computeMaxScrollX(), 0,
                                    computeMaxScrollY())) {
                                invalidate();
                            }
                        }
                        // redraw in high-quality, as we're done dragging
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                        // fall through
                    case TOUCH_DRAG_START_MODE:
                        // TOUCH_DRAG_START_MODE should not happen for the real
                        // device as we almost certain will get a MOVE. But this
                        // is possible on emulator.
                        mLastVelocity = 0;
                        WebViewCore.resumePriority();
                        if (!mSelectingText) {
                            WebViewCore.resumeUpdatePicture(mWebViewCore);
                        }
                        break;
                }
                stopTouch();
                break;
            }
            case MotionEvent.ACTION_CANCEL: {
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    mScroller.springBack(getScrollX(), getScrollY(), 0,
                            computeMaxScrollX(), 0, computeMaxScrollY());
                    invalidate();
                }
                cancelTouch();
                break;
            }
        }
!!!5062412.java!!!	getTextScrollSpeed(in coordinate : int, in min : int, in max : int) : float
        if (coordinate < min) {
            return (coordinate - min) * TEXT_SCROLL_RATE;
        } else if (coordinate >= max) {
            return (coordinate - max + 1) * TEXT_SCROLL_RATE;
        } else {
            return 0.0f;
        }
!!!5062540.java!!!	getSelectionCoordinate(in coordinate : int, in min : int, in max : int) : int
        return Math.max(Math.min(coordinate, max), min);
!!!5062668.java!!!	beginScrollEdit() : void
        if (mLastEditScroll == 0) {
            mLastEditScroll = SystemClock.uptimeMillis() -
                    TEXT_SCROLL_FIRST_SCROLL_MS;
            scrollEditWithCursor();
        }
!!!5062796.java!!!	scrollDraggedSelectionHandleIntoView() : void
        if (mSelectDraggingCursor == null) {
            return;
        }
        int x = mSelectDraggingCursor.x;
        int y = mSelectDraggingCursor.y;
        if (!mEditTextContentBounds.contains(x,y)) {
            int left = Math.min(0, x - mEditTextContentBounds.left - EDIT_RECT_BUFFER);
            int right = Math.max(0, x - mEditTextContentBounds.right + EDIT_RECT_BUFFER);
            int deltaX = left + right;
            int above = Math.min(0, y - mEditTextContentBounds.top - EDIT_RECT_BUFFER);
            int below = Math.max(0, y - mEditTextContentBounds.bottom + EDIT_RECT_BUFFER);
            int deltaY = above + below;
            if (deltaX != 0 || deltaY != 0) {
                int scrollX = getTextScrollX() + deltaX;
                int scrollY = getTextScrollY() + deltaY;
                scrollX = clampBetween(scrollX, 0, getMaxTextScrollX());
                scrollY = clampBetween(scrollY, 0, getMaxTextScrollY());
                scrollEditText(scrollX, scrollY);
            }
        }
!!!5062924.java!!!	endScrollEdit() : void
        mLastEditScroll = 0;
!!!5063052.java!!!	clampBetween(in value : int, in min : int, in max : int) : int
        return Math.max(min, Math.min(value, max));
!!!5063180.java!!!	getTextScrollDelta(in speed : float, in deltaT : long) : int
        float distance = speed * deltaT;
        int intDistance = (int)Math.floor(distance);
        float probability = distance - intDistance;
        if (Math.random() < probability) {
            intDistance++;
        }
        return intDistance;
!!!5063308.java!!!	scrollEditWithCursor() : void
        if (mLastEditScroll != 0) {
            int x = viewToContentX(mLastTouchX + getScrollX() + mSelectOffset.x);
            float scrollSpeedX = getTextScrollSpeed(x, mEditTextContentBounds.left,
                    mEditTextContentBounds.right);
            int y = viewToContentY(mLastTouchY + getScrollY() + mSelectOffset.y);
            float scrollSpeedY = getTextScrollSpeed(y, mEditTextContentBounds.top,
                    mEditTextContentBounds.bottom);
            if (scrollSpeedX == 0.0f && scrollSpeedY == 0.0f) {
                endScrollEdit();
            } else {
                long currentTime = SystemClock.uptimeMillis();
                long timeSinceLastUpdate = currentTime - mLastEditScroll;
                int deltaX = getTextScrollDelta(scrollSpeedX, timeSinceLastUpdate);
                int deltaY = getTextScrollDelta(scrollSpeedY, timeSinceLastUpdate);
                int scrollX = getTextScrollX() + deltaX;
                scrollX = clampBetween(scrollX, 0, getMaxTextScrollX());
                int scrollY = getTextScrollY() + deltaY;
                scrollY = clampBetween(scrollY, 0, getMaxTextScrollY());

                mLastEditScroll = currentTime;
                if (scrollX == getTextScrollX() && scrollY == getTextScrollY()) {
                    // By probability no text scroll this time. Try again later.
                    mPrivateHandler.sendEmptyMessageDelayed(SCROLL_EDIT_TEXT,
                            TEXT_SCROLL_FIRST_SCROLL_MS);
                } else {
                    int selectionX = getSelectionCoordinate(x,
                            mEditTextContentBounds.left, mEditTextContentBounds.right);
                    int selectionY = getSelectionCoordinate(y,
                            mEditTextContentBounds.top, mEditTextContentBounds.bottom);
                    int oldX = mSelectDraggingCursor.x;
                    int oldY = mSelectDraggingCursor.y;
                    mSelectDraggingCursor.set(selectionX, selectionY);
                    updateWebkitSelection(false);
                    scrollEditText(scrollX, scrollY);
                    mSelectDraggingCursor.set(oldX, oldY);
                }
            }
        }
!!!5063436.java!!!	startTouch(in x : float, in y : float, in eventTime : long) : void
        // Remember where the motion event started
        mStartTouchX = mLastTouchX = Math.round(x);
        mStartTouchY = mLastTouchY = Math.round(y);
        mLastTouchTime = eventTime;
        mVelocityTracker = VelocityTracker.obtain();
        mSnapScrollMode = SNAP_NONE;
!!!5063564.java!!!	startDrag() : void
        WebViewCore.reducePriority();
        // to get better performance, pause updating the picture
        WebViewCore.pauseUpdatePicture(mWebViewCore);
        nativeSetIsScrolling(true);

        if (mHorizontalScrollBarMode != SCROLLBAR_ALWAYSOFF
                || mVerticalScrollBarMode != SCROLLBAR_ALWAYSOFF) {
            mZoomManager.invokeZoomPicker();
        }
!!!5063692.java!!!	doDrag(in deltaX : int, in deltaY : int) : boolean
        boolean allDrag = true;
        if ((deltaX | deltaY) != 0) {
            int oldX = getScrollX();
            int oldY = getScrollY();
            int rangeX = computeMaxScrollX();
            int rangeY = computeMaxScrollY();
            final int contentX = (int)Math.floor(deltaX * mZoomManager.getInvScale());
            final int contentY = (int)Math.floor(deltaY * mZoomManager.getInvScale());

            // Assume page scrolling and change below if we're wrong
            mTouchMode = TOUCH_DRAG_MODE;

            // Check special scrolling before going to main page scrolling.
            if (mIsEditingText && mTouchInEditText && canTextScroll(deltaX, deltaY)) {
                // Edit text scrolling
                oldX = getTextScrollX();
                rangeX = getMaxTextScrollX();
                deltaX = contentX;
                oldY = getTextScrollY();
                rangeY = getMaxTextScrollY();
                deltaY = contentY;
                mTouchMode = TOUCH_DRAG_TEXT_MODE;
                allDrag = false;
            } else if (mCurrentScrollingLayerId != 0) {
                // Check the scrolling bounds to see if we will actually do any
                // scrolling.  The rectangle is in document coordinates.
                final int maxX = mScrollingLayerRect.right;
                final int maxY = mScrollingLayerRect.bottom;
                final int resultX = clampBetween(maxX, 0,
                        mScrollingLayerRect.left + contentX);
                final int resultY = clampBetween(maxY, 0,
                        mScrollingLayerRect.top + contentY);

                if (resultX != mScrollingLayerRect.left
                        || resultY != mScrollingLayerRect.top
                        || (contentX | contentY) == 0) {
                    // In case we switched to dragging the page.
                    mTouchMode = TOUCH_DRAG_LAYER_MODE;
                    deltaX = contentX;
                    deltaY = contentY;
                    oldX = mScrollingLayerRect.left;
                    oldY = mScrollingLayerRect.top;
                    rangeX = maxX;
                    rangeY = maxY;
                    allDrag = false;
                }
            }

            if (mOverScrollGlow != null) {
                mOverScrollGlow.setOverScrollDeltas(deltaX, deltaY);
            }

            mWebViewPrivate.overScrollBy(deltaX, deltaY, oldX, oldY,
                    rangeX, rangeY,
                    mOverscrollDistance, mOverscrollDistance, true);
            if (mOverScrollGlow != null && mOverScrollGlow.isAnimating()) {
                invalidate();
            }
        }
        mZoomManager.keepZoomPickerVisible();
        return allDrag;
!!!5063820.java!!!	stopTouch() : void
        if (mScroller.isFinished() && !mSelectingText
                && (mTouchMode == TOUCH_DRAG_MODE
                || mTouchMode == TOUCH_DRAG_LAYER_MODE)) {
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            nativeSetIsScrolling(false);
        }

        // we also use mVelocityTracker == null to tell us that we are
        // not "moving around", so we can take the slower/prettier
        // mode in the drawing code
        if (mVelocityTracker != null) {
            mVelocityTracker.recycle();
            mVelocityTracker = null;
        }

        // Release any pulled glows
        if (mOverScrollGlow != null) {
            mOverScrollGlow.releaseAll();
        }

        if (mSelectingText) {
            mSelectionStarted = false;
            syncSelectionCursors();
            if (mIsCaretSelection) {
                resetCaretTimer();
            }
            invalidate();
        }
!!!5063948.java!!!	cancelTouch() : void
        // we also use mVelocityTracker == null to tell us that we are
        // not "moving around", so we can take the slower/prettier
        // mode in the drawing code
        if (mVelocityTracker != null) {
            mVelocityTracker.recycle();
            mVelocityTracker = null;
        }

        if ((mTouchMode == TOUCH_DRAG_MODE
                || mTouchMode == TOUCH_DRAG_LAYER_MODE) && !mSelectingText) {
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            nativeSetIsScrolling(false);
        }
        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
        mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
        removeTouchHighlight();
        mHeldMotionless = MOTIONLESS_TRUE;
        mTouchMode = TOUCH_DONE_MODE;
!!!5064076.java!!!	snapDraggingCursor() : void
        float scale = scaleAlongSegment(
                mSelectDraggingCursor.x, mSelectDraggingCursor.y,
                mSelectDraggingTextQuad.p4, mSelectDraggingTextQuad.p3);
        // clamp scale to ensure point is on the bottom segment
        scale = Math.max(0.0f, scale);
        scale = Math.min(scale, 1.0f);
        float newX = scaleCoordinate(scale,
                mSelectDraggingTextQuad.p4.x, mSelectDraggingTextQuad.p3.x);
        float newY = scaleCoordinate(scale,
                mSelectDraggingTextQuad.p4.y, mSelectDraggingTextQuad.p3.y);
        int x = Math.round(newX);
        int y = Math.round(newY);
        if (mIsEditingText) {
            x = clampBetween(x, mEditTextContentBounds.left,
                    mEditTextContentBounds.right);
            y = clampBetween(y, mEditTextContentBounds.top,
                    mEditTextContentBounds.bottom);
        }
        mSelectDraggingCursor.set(x, y);
!!!5064204.java!!!	scaleCoordinate(in scale : float, in coord1 : float, in coord2 : float) : float
        float diff = coord2 - coord1;
        return coord1 + (scale * diff);
!!!5064332.java!!!	onGenericMotionEvent(inout event : MotionEvent) : boolean
        if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_SCROLL: {
                    final float vscroll;
                    final float hscroll;
                    if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                        vscroll = 0;
                        hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    } else {
                        vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                    }
                    if (hscroll != 0 || vscroll != 0) {
                        final int vdelta = (int) (vscroll *
                                mWebViewPrivate.getVerticalScrollFactor());
                        final int hdelta = (int) (hscroll *
                                mWebViewPrivate.getHorizontalScrollFactor());

                        abortAnimation();
                        int oldTouchMode = mTouchMode;
                        startScrollingLayer(event.getX(), event.getY());
                        doDrag(hdelta, vdelta);
                        mTouchMode = oldTouchMode;
                        return true;
                    }
                }
            }
        }
        return mWebViewPrivate.super_onGenericMotionEvent(event);
!!!5064460.java!!!	setMapTrackballToArrowKeys(inout setMap : boolean) : void
        mMapTrackballToArrowKeys = setMap;
!!!5064588.java!!!	resetTrackballTime() : void
        mTrackballLastTime = 0;
!!!5064716.java!!!	onTrackballEvent(inout ev : MotionEvent) : boolean
        long time = ev.getEventTime();
        if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
            if (ev.getY() > 0) pageDown(true);
            if (ev.getY() < 0) pageUp(true);
            return true;
        }
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            if (mSelectingText) {
                return true; // discard press if copy in progress
            }
            mTrackballDown = true;
            if (mNativeClass == 0) {
                return false;
            }
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "onTrackballEvent down ev=" + ev
                        + " time=" + time
                        + " mLastCursorTime=" + mLastCursorTime);
            }
            if (mWebView.isInTouchMode()) mWebView.requestFocusFromTouch();
            return false; // let common code in onKeyDown at it
        }
        if (ev.getAction() == MotionEvent.ACTION_UP) {
            // LONG_PRESS_CENTER is set in common onKeyDown
            mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
            mTrackballDown = false;
            mTrackballUpTime = time;
            if (mSelectingText) {
                copySelection();
                selectionDone();
                return true; // discard press if copy in progress
            }
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "onTrackballEvent up ev=" + ev
                        + " time=" + time
                );
            }
            return false; // let common code in onKeyUp at it
        }
        if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) ||
                AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (DebugFlags.WEB_VIEW) Log.v(LOGTAG, "onTrackballEvent gmail quit");
            return false;
        }
        if (mTrackballDown) {
            if (DebugFlags.WEB_VIEW) Log.v(LOGTAG, "onTrackballEvent down quit");
            return true; // discard move if trackball is down
        }
        if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
            if (DebugFlags.WEB_VIEW) Log.v(LOGTAG, "onTrackballEvent up timeout quit");
            return true;
        }
        // TODO: alternatively we can do panning as touch does
        switchOutDrawHistory();
        if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "onTrackballEvent time="
                        + time + " last=" + mTrackballLastTime);
            }
            mTrackballFirstTime = time;
            mTrackballXMove = mTrackballYMove = 0;
        }
        mTrackballLastTime = time;
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "onTrackballEvent ev=" + ev + " time=" + time);
        }
        mTrackballRemainsX += ev.getX();
        mTrackballRemainsY += ev.getY();
        doTrackball(time, ev.getMetaState());
        return true;
!!!5064844.java!!!	scaleTrackballX(in xRate : float, in width : int) : int
        int xMove = (int) (xRate / TRACKBALL_SCALE * width);
        int nextXMove = xMove;
        if (xMove > 0) {
            if (xMove > mTrackballXMove) {
                xMove -= mTrackballXMove;
            }
        } else if (xMove < mTrackballXMove) {
            xMove -= mTrackballXMove;
        }
        mTrackballXMove = nextXMove;
        return xMove;
!!!5064972.java!!!	scaleTrackballY(in yRate : float, in height : int) : int
        int yMove = (int) (yRate / TRACKBALL_SCALE * height);
        int nextYMove = yMove;
        if (yMove > 0) {
            if (yMove > mTrackballYMove) {
                yMove -= mTrackballYMove;
            }
        } else if (yMove < mTrackballYMove) {
            yMove -= mTrackballYMove;
        }
        mTrackballYMove = nextYMove;
        return yMove;
!!!5065100.java!!!	keyCodeToSoundsEffect(in keyCode : int) : int
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_UP:
                return SoundEffectConstants.NAVIGATION_UP;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                return SoundEffectConstants.NAVIGATION_RIGHT;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                return SoundEffectConstants.NAVIGATION_DOWN;
            case KeyEvent.KEYCODE_DPAD_LEFT:
                return SoundEffectConstants.NAVIGATION_LEFT;
        }
        return 0;
!!!5065228.java!!!	doTrackball(in time : long, in metaState : int) : void
        int elapsed = (int) (mTrackballLastTime - mTrackballFirstTime);
        if (elapsed == 0) {
            elapsed = TRACKBALL_TIMEOUT;
        }
        float xRate = mTrackballRemainsX * 1000 / elapsed;
        float yRate = mTrackballRemainsY * 1000 / elapsed;
        int viewWidth = getViewWidth();
        int viewHeight = getViewHeight();
        float ax = Math.abs(xRate);
        float ay = Math.abs(yRate);
        float maxA = Math.max(ax, ay);
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "doTrackball elapsed=" + elapsed
                    + " xRate=" + xRate
                    + " yRate=" + yRate
                    + " mTrackballRemainsX=" + mTrackballRemainsX
                    + " mTrackballRemainsY=" + mTrackballRemainsY);
        }
        int width = mContentWidth - viewWidth;
        int height = mContentHeight - viewHeight;
        if (width < 0) width = 0;
        if (height < 0) height = 0;
        ax = Math.abs(mTrackballRemainsX * TRACKBALL_MULTIPLIER);
        ay = Math.abs(mTrackballRemainsY * TRACKBALL_MULTIPLIER);
        maxA = Math.max(ax, ay);
        int count = Math.max(0, (int) maxA);
        int oldScrollX = getScrollX();
        int oldScrollY = getScrollY();
        if (count > 0) {
            int selectKeyCode = ax < ay ? mTrackballRemainsY < 0 ?
                    KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN :
                    mTrackballRemainsX < 0 ? KeyEvent.KEYCODE_DPAD_LEFT :
                    KeyEvent.KEYCODE_DPAD_RIGHT;
            count = Math.min(count, TRACKBALL_MOVE_COUNT);
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "doTrackball keyCode=" + selectKeyCode
                        + " count=" + count
                        + " mTrackballRemainsX=" + mTrackballRemainsX
                        + " mTrackballRemainsY=" + mTrackballRemainsY);
            }
            if (mNativeClass != 0) {
                for (int i = 0; i < count; i++) {
                    letPageHandleNavKey(selectKeyCode, time, true, metaState);
                }
                letPageHandleNavKey(selectKeyCode, time, false, metaState);
            }
            mTrackballRemainsX = mTrackballRemainsY = 0;
        }
        if (count >= TRACKBALL_SCROLL_COUNT) {
            int xMove = scaleTrackballX(xRate, width);
            int yMove = scaleTrackballY(yRate, height);
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "doTrackball pinScrollBy"
                        + " count=" + count
                        + " xMove=" + xMove + " yMove=" + yMove
                        + " mScrollX-oldScrollX=" + (getScrollX()-oldScrollX)
                        + " mScrollY-oldScrollY=" + (getScrollY()-oldScrollY)
                        );
            }
            if (Math.abs(getScrollX() - oldScrollX) > Math.abs(xMove)) {
                xMove = 0;
            }
            if (Math.abs(getScrollY() - oldScrollY) > Math.abs(yMove)) {
                yMove = 0;
            }
            if (xMove != 0 || yMove != 0) {
                pinScrollBy(xMove, yMove, true, 0);
            }
        }
!!!5065356.java!!!	computeMaxScrollX() : int
        return Math.max(computeRealHorizontalScrollRange() - getViewWidth(), 0);
!!!5065484.java!!!	computeMaxScrollY() : int
        return Math.max(computeRealVerticalScrollRange() + getTitleHeight()
                - getViewHeightWithTitle(), 0);
!!!5065612.java!!!	updateScrollCoordinates(in x : int, in y : int) : boolean
        int oldX = getScrollX();
        int oldY = getScrollY();
        setScrollXRaw(x);
        setScrollYRaw(y);
        if (oldX != getScrollX() || oldY != getScrollY()) {
            mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), oldX, oldY);
            return true;
        } else {
            return false;
        }
!!!5065740.java!!!	flingScroll(in vx : int, in vy : int) : void
        mScroller.fling(getScrollX(), getScrollY(), vx, vy, 0, computeMaxScrollX(), 0,
                computeMaxScrollY(), mOverflingDistance, mOverflingDistance);
        invalidate();
!!!5065868.java!!!	doFling() : void
        if (mVelocityTracker == null) {
            return;
        }
        int maxX = computeMaxScrollX();
        int maxY = computeMaxScrollY();

        mVelocityTracker.computeCurrentVelocity(1000, mMaximumFling);
        int vx = (int) mVelocityTracker.getXVelocity();
        int vy = (int) mVelocityTracker.getYVelocity();

        int scrollX = getScrollX();
        int scrollY = getScrollY();
        int overscrollDistance = mOverscrollDistance;
        int overflingDistance = mOverflingDistance;

        // Use the layer's scroll data if applicable.
        if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
            scrollX = mScrollingLayerRect.left;
            scrollY = mScrollingLayerRect.top;
            maxX = mScrollingLayerRect.right;
            maxY = mScrollingLayerRect.bottom;
            // No overscrolling for layers.
            overscrollDistance = overflingDistance = 0;
        } else if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
            scrollX = getTextScrollX();
            scrollY = getTextScrollY();
            maxX = getMaxTextScrollX();
            maxY = getMaxTextScrollY();
            // No overscrolling for edit text.
            overscrollDistance = overflingDistance = 0;
        }

        if (mSnapScrollMode != SNAP_NONE) {
            if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
                vy = 0;
            } else {
                vx = 0;
            }
        }
        if ((maxX == 0 && vy == 0) || (maxY == 0 && vx == 0)) {
            WebViewCore.resumePriority();
            if (!mSelectingText) {
                WebViewCore.resumeUpdatePicture(mWebViewCore);
            }
            if (mScroller.springBack(scrollX, scrollY, 0, maxX, 0, maxY)) {
                invalidate();
            }
            return;
        }
        float currentVelocity = mScroller.getCurrVelocity();
        float velocity = (float) Math.hypot(vx, vy);
        if (mLastVelocity > 0 && currentVelocity > 0 && velocity
                > mLastVelocity * MINIMUM_VELOCITY_RATIO_FOR_ACCELERATION) {
            float deltaR = (float) (Math.abs(Math.atan2(mLastVelY, mLastVelX)
                    - Math.atan2(vy, vx)));
            final float circle = (float) (Math.PI) * 2.0f;
            if (deltaR > circle * 0.9f || deltaR < circle * 0.1f) {
                vx += currentVelocity * mLastVelX / mLastVelocity;
                vy += currentVelocity * mLastVelY / mLastVelocity;
                velocity = (float) Math.hypot(vx, vy);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, "doFling vx= " + vx + " vy=" + vy);
                }
            } else if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, "doFling missed " + deltaR / circle);
            }
        } else if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, "doFling start last=" + mLastVelocity
                    + " current=" + currentVelocity
                    + " vx=" + vx + " vy=" + vy
                    + " maxX=" + maxX + " maxY=" + maxY
                    + " scrollX=" + scrollX + " scrollY=" + scrollY
                    + " layer=" + mCurrentScrollingLayerId);
        }

        // Allow sloppy flings without overscrolling at the edges.
        if ((scrollX == 0 || scrollX == maxX) && Math.abs(vx) < Math.abs(vy)) {
            vx = 0;
        }
        if ((scrollY == 0 || scrollY == maxY) && Math.abs(vy) < Math.abs(vx)) {
            vy = 0;
        }

        if (overscrollDistance < overflingDistance) {
            if ((vx > 0 && scrollX == -overscrollDistance) ||
                    (vx < 0 && scrollX == maxX + overscrollDistance)) {
                vx = 0;
            }
            if ((vy > 0 && scrollY == -overscrollDistance) ||
                    (vy < 0 && scrollY == maxY + overscrollDistance)) {
                vy = 0;
            }
        }

        mLastVelX = vx;
        mLastVelY = vy;
        mLastVelocity = velocity;

        // no horizontal overscroll if the content just fits
        mScroller.fling(scrollX, scrollY, -vx, -vy, 0, maxX, 0, maxY,
                maxX == 0 ? 0 : overflingDistance, overflingDistance);

        invalidate();
!!!5065996.java!!!	getZoomControls() : View
        if (!getSettings().supportZoom()) {
            Log.w(LOGTAG, "This WebView doesn't support zoom.");
            return null;
        }
        return mZoomManager.getExternalZoomPicker();
!!!5066124.java!!!	dismissZoomControl() : void
        mZoomManager.dismissZoomPicker();
!!!5066252.java!!!	getDefaultZoomScale() : float
        return mZoomManager.getDefaultScale();
!!!5066380.java!!!	getZoomOverviewScale() : float
        return mZoomManager.getZoomOverviewScale();
!!!5066508.java!!!	canZoomIn() : boolean
        return mZoomManager.canZoomIn();
!!!5066636.java!!!	canZoomOut() : boolean
        return mZoomManager.canZoomOut();
!!!5066764.java!!!	zoomIn() : boolean
        return mZoomManager.zoomIn();
!!!5066892.java!!!	zoomOut() : boolean
        return mZoomManager.zoomOut();
!!!5067020.java!!!	isRectFitOnScreen(inout rect : Rect) : boolean
        final int rectWidth = rect.width();
        final int rectHeight = rect.height();
        final int viewWidth = getViewWidth();
        final int viewHeight = getViewHeightWithTitle();
        float scale = Math.min((float) viewWidth / rectWidth, (float) viewHeight / rectHeight);
        scale = mZoomManager.computeScaleWithLimits(scale);
        return !mZoomManager.willScaleTriggerZoom(scale)
                && contentToViewX(rect.left) >= getScrollX()
                && contentToViewX(rect.right) <= getScrollX() + viewWidth
                && contentToViewY(rect.top) >= getScrollY()
                && contentToViewY(rect.bottom) <= getScrollY() + viewHeight;
!!!5067148.java!!!	centerFitRect(inout rect : Rect) : void
        final int rectWidth = rect.width();
        final int rectHeight = rect.height();
        final int viewWidth = getViewWidth();
        final int viewHeight = getViewHeightWithTitle();
        float scale = Math.min((float) viewWidth / rectWidth, (float) viewHeight
                / rectHeight);
        scale = mZoomManager.computeScaleWithLimits(scale);
        if (!mZoomManager.willScaleTriggerZoom(scale)) {
            pinScrollTo(contentToViewX(rect.left + rectWidth / 2) - viewWidth / 2,
                    contentToViewY(rect.top + rectHeight / 2) - viewHeight / 2,
                    true, 0);
        } else {
            float actualScale = mZoomManager.getScale();
            float oldScreenX = rect.left * actualScale - getScrollX();
            float rectViewX = rect.left * scale;
            float rectViewWidth = rectWidth * scale;
            float newMaxWidth = mContentWidth * scale;
            float newScreenX = (viewWidth - rectViewWidth) / 2;
            // pin the newX to the WebView
            if (newScreenX > rectViewX) {
                newScreenX = rectViewX;
            } else if (newScreenX > (newMaxWidth - rectViewX - rectViewWidth)) {
                newScreenX = viewWidth - (newMaxWidth - rectViewX);
            }
            float zoomCenterX = (oldScreenX * scale - newScreenX * actualScale)
                    / (scale - actualScale);
            float oldScreenY = rect.top * actualScale + getTitleHeight()
                    - getScrollY();
            float rectViewY = rect.top * scale + getTitleHeight();
            float rectViewHeight = rectHeight * scale;
            float newMaxHeight = mContentHeight * scale + getTitleHeight();
            float newScreenY = (viewHeight - rectViewHeight) / 2;
            // pin the newY to the WebView
            if (newScreenY > rectViewY) {
                newScreenY = rectViewY;
            } else if (newScreenY > (newMaxHeight - rectViewY - rectViewHeight)) {
                newScreenY = viewHeight - (newMaxHeight - rectViewY);
            }
            float zoomCenterY = (oldScreenY * scale - newScreenY * actualScale)
                    / (scale - actualScale);
            mZoomManager.setZoomCenter(zoomCenterX, zoomCenterY);
            mZoomManager.startZoomAnimation(scale, false);
        }
!!!5067276.java!!!	overrideLoading(in url : String) : void
        mCallbackProxy.uiOverrideUrlLoading(url);
!!!5067404.java!!!	requestFocus(in direction : int, inout previouslyFocusedRect : Rect) : boolean
        // Check if we are destroyed
        if (mWebViewCore == null) return false;
        // FIXME: If a subwindow is showing find, and the user touches the
        // background window, it can steal focus.
        if (mFindIsUp) return false;
        boolean result = false;
        result = mWebViewPrivate.super_requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus()
                && !mWebView.isInTouchMode()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            mWebViewCore.sendMessage(EventHub.SET_INITIAL_FOCUS, fakeKeyDirection);
        }
        return result;
!!!5067532.java!!!	onMeasure(in widthMeasureSpec : int, in heightMeasureSpec : int) : void
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);

        int measuredHeight = heightSize;
        int measuredWidth = widthSize;

        // Grab the content size from WebViewCore.
        int contentHeight = contentToViewDimension(mContentHeight);
        int contentWidth = contentToViewDimension(mContentWidth);

//        Log.d(LOGTAG, "------- measure " + heightMode);

        if (heightMode != MeasureSpec.EXACTLY) {
            mHeightCanMeasure = true;
            measuredHeight = contentHeight;
            if (heightMode == MeasureSpec.AT_MOST) {
                // If we are larger than the AT_MOST height, then our height can
                // no longer be measured and we should scroll internally.
                if (measuredHeight > heightSize) {
                    measuredHeight = heightSize;
                    mHeightCanMeasure = false;
                    measuredHeight |= View.MEASURED_STATE_TOO_SMALL;
                }
            }
        } else {
            mHeightCanMeasure = false;
        }
        if (mNativeClass != 0) {
            nativeSetHeightCanMeasure(mHeightCanMeasure);
        }
        // For the width, always use the given size unless unspecified.
        if (widthMode == MeasureSpec.UNSPECIFIED) {
            mWidthCanMeasure = true;
            measuredWidth = contentWidth;
        } else {
            if (measuredWidth < contentWidth) {
                measuredWidth |= View.MEASURED_STATE_TOO_SMALL;
            }
            mWidthCanMeasure = false;
        }

        synchronized (this) {
            mWebViewPrivate.setMeasuredDimension(measuredWidth, measuredHeight);
        }
!!!5067660.java!!!	requestChildRectangleOnScreen(inout child : View, inout rect : Rect, inout immediate : boolean) : boolean
        if (mNativeClass == 0) {
            return false;
        }
        // don't scroll while in zoom animation. When it is done, we will adjust
        // the necessary components
        if (mZoomManager.isFixedLengthAnimationInProgress()) {
            return false;
        }

        rect.offset(child.getLeft() - child.getScrollX(),
                child.getTop() - child.getScrollY());

        Rect content = new Rect(viewToContentX(getScrollX()),
                viewToContentY(getScrollY()),
                viewToContentX(getScrollX() + getWidth()
                - mWebView.getVerticalScrollbarWidth()),
                viewToContentY(getScrollY() + getViewHeightWithTitle()));
        int screenTop = contentToViewY(content.top);
        int screenBottom = contentToViewY(content.bottom);
        int height = screenBottom - screenTop;
        int scrollYDelta = 0;

        if (rect.bottom > screenBottom) {
            int oneThirdOfScreenHeight = height / 3;
            if (rect.height() > 2 * oneThirdOfScreenHeight) {
                // If the rectangle is too tall to fit in the bottom two thirds
                // of the screen, place it at the top.
                scrollYDelta = rect.top - screenTop;
            } else {
                // If the rectangle will still fit on screen, we want its
                // top to be in the top third of the screen.
                scrollYDelta = rect.top - (screenTop + oneThirdOfScreenHeight);
            }
        } else if (rect.top < screenTop) {
            scrollYDelta = rect.top - screenTop;
        }

        int screenLeft = contentToViewX(content.left);
        int screenRight = contentToViewX(content.right);
        int width = screenRight - screenLeft;
        int scrollXDelta = 0;

        if (rect.right > screenRight && rect.left > screenLeft) {
            if (rect.width() > width) {
                scrollXDelta += (rect.left - screenLeft);
            } else {
                scrollXDelta += (rect.right - screenRight);
            }
        } else if (rect.left < screenLeft) {
            scrollXDelta -= (screenLeft - rect.left);
        }

        if ((scrollYDelta | scrollXDelta) != 0) {
            return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
        }

        return false;
!!!5067788.java!!!	replaceTextfieldText(in oldStart : int, in oldEnd : int, in replace : String, in newStart : int, in newEnd : int) : void
        WebViewCore.ReplaceTextData arg = new WebViewCore.ReplaceTextData();
        arg.mReplace = replace;
        arg.mNewStart = newStart;
        arg.mNewEnd = newEnd;
        mTextGeneration++;
        arg.mTextGeneration = mTextGeneration;
        sendBatchableInputMessage(EventHub.REPLACE_TEXT, oldStart, oldEnd, arg);
!!!5067916.java!!!	passToJavaScript(in currentText : String, inout event : KeyEvent) : void
        // check if mWebViewCore has been destroyed
        if (mWebViewCore == null) {
            return;
        }
        WebViewCore.JSKeyData arg = new WebViewCore.JSKeyData();
        arg.mEvent = event;
        arg.mCurrentText = currentText;
        // Increase our text generation number, and pass it to webcore thread
        mTextGeneration++;
        mWebViewCore.sendMessage(EventHub.PASS_TO_JS, mTextGeneration, 0, arg);
        // WebKit's document state is not saved until about to leave the page.
        // To make sure the host application, like Browser, has the up to date
        // document state when it goes to background, we force to save the
        // document state.
        mWebViewCore.removeMessages(EventHub.SAVE_DOCUMENT_STATE);
        mWebViewCore.sendMessageDelayed(EventHub.SAVE_DOCUMENT_STATE, null, 1000);
!!!5068044.java!!!	getWebViewCore() : WebViewCore
        return mWebViewCore;
!!!5068172.java!!!	canTextScroll(in directionX : int, in directionY : int) : boolean
        int scrollX = getTextScrollX();
        int scrollY = getTextScrollY();
        int maxScrollX = getMaxTextScrollX();
        int maxScrollY = getMaxTextScrollY();
        boolean canScrollX = (directionX > 0)
                ? (scrollX < maxScrollX)
                : (scrollX > 0);
        boolean canScrollY = (directionY > 0)
                ? (scrollY < maxScrollY)
                : (scrollY > 0);
        return canScrollX || canScrollY;
!!!5068300.java!!!	getTextScrollX() : int
        return -mEditTextContent.left;
!!!5068428.java!!!	getTextScrollY() : int
        return -mEditTextContent.top;
!!!5068556.java!!!	getMaxTextScrollX() : int
        return Math.max(0, mEditTextContent.width() - mEditTextContentBounds.width());
!!!5068684.java!!!	getMaxTextScrollY() : int
        return Math.max(0, mEditTextContent.height() - mEditTextContentBounds.height());
!!!5078540.java!!!	setHitTestTypeFromUrl(in url : String) : void
        String substr = null;
        if (url.startsWith(SCHEME_GEO)) {
            mInitialHitTestResult.setType(HitTestResult.GEO_TYPE);
            substr = url.substring(SCHEME_GEO.length());
        } else if (url.startsWith(SCHEME_TEL)) {
            mInitialHitTestResult.setType(HitTestResult.PHONE_TYPE);
            substr = url.substring(SCHEME_TEL.length());
        } else if (url.startsWith(SCHEME_MAILTO)) {
            mInitialHitTestResult.setType(HitTestResult.EMAIL_TYPE);
            substr = url.substring(SCHEME_MAILTO.length());
        } else {
            mInitialHitTestResult.setType(HitTestResult.SRC_ANCHOR_TYPE);
            mInitialHitTestResult.setExtra(url);
            return;
        }
        try {
            mInitialHitTestResult.setExtra(URLDecoder.decode(substr, "UTF-8"));
        } catch (Throwable e) {
            Log.w(LOGTAG, "Failed to decode URL! " + substr, e);
            mInitialHitTestResult.setType(HitTestResult.UNKNOWN_TYPE);
        }
!!!5078668.java!!!	setHitTestResult(inout hit : WebKitHitTest) : void
        if (hit == null) {
            mInitialHitTestResult = null;
            return;
        }
        mInitialHitTestResult = new HitTestResult();
        if (hit.mLinkUrl != null) {
            setHitTestTypeFromUrl(hit.mLinkUrl);
            if (hit.mImageUrl != null
                    && mInitialHitTestResult.getType() == HitTestResult.SRC_ANCHOR_TYPE) {
                mInitialHitTestResult.setType(HitTestResult.SRC_IMAGE_ANCHOR_TYPE);
                mInitialHitTestResult.setExtra(hit.mImageUrl);
            }
        } else if (hit.mImageUrl != null) {
            mInitialHitTestResult.setType(HitTestResult.IMAGE_TYPE);
            mInitialHitTestResult.setExtra(hit.mImageUrl);
        } else if (hit.mEditable) {
            mInitialHitTestResult.setType(HitTestResult.EDIT_TEXT_TYPE);
        } else if (hit.mIntentUrl != null) {
            setHitTestTypeFromUrl(hit.mIntentUrl);
        }
!!!5078796.java!!!	shouldDrawHighlightRect() : boolean
        if (mFocusedNode == null || mInitialHitTestResult == null) {
            return false;
        }
        if (mTouchHighlightRegion.isEmpty()) {
            return false;
        }
        if (mFocusedNode.mHasFocus && !mWebView.isInTouchMode()) {
            return mDrawCursorRing && !mFocusedNode.mEditable;
        }
        if (mFocusedNode.mHasFocus && mFocusedNode.mEditable) {
            return false;
        }
        return mShowTapHighlight;
!!!5079820.java!!!	shouldAnimateTo(inout hit : WebKitHitTest) : boolean
        // TODO: Don't be annoying or throw out the animation entirely
        return false;
!!!5079948.java!!!	setTouchHighlightRects(inout hit : WebKitHitTest) : void
        FocusTransitionDrawable transition = null;
        if (shouldAnimateTo(hit)) {
            transition = new FocusTransitionDrawable(this);
        }
        Rect[] rects = hit != null ? hit.mTouchRects : null;
        if (!mTouchHighlightRegion.isEmpty()) {
            mWebView.invalidate(mTouchHighlightRegion.getBounds());
            if (transition != null) {
                transition.mPreviousRegion = new Region(mTouchHighlightRegion);
            }
            mTouchHighlightRegion.setEmpty();
        }
        if (rects != null) {
            mTouchHightlightPaint.setColor(hit.mTapHighlightColor);
            for (Rect rect : rects) {
                Rect viewRect = contentToViewRect(rect);
                // some sites, like stories in nytimes.com, set
                // mouse event handler in the top div. It is not
                // user friendly to highlight the div if it covers
                // more than half of the screen.
                if (viewRect.width() < getWidth() >> 1
                        || viewRect.height() < getHeight() >> 1) {
                    mTouchHighlightRegion.union(viewRect);
                } else if (DebugFlags.WEB_VIEW) {
                    Log.d(LOGTAG, "Skip the huge selection rect:"
                            + viewRect);
                }
            }
            mWebView.invalidate(mTouchHighlightRegion.getBounds());
            if (transition != null && transition.mPreviousRegion != null) {
                transition.mNewRegion = new Region(mTouchHighlightRegion);
                mFocusTransition = transition;
                ObjectAnimator animator = ObjectAnimator.ofFloat(
                        mFocusTransition, "progress", 1f);
                animator.start();
            }
        }
!!!5080204.java!!!	pageSwapCallback(inout notifyAnimationStarted : boolean) : void
        if (DebugFlags.MEASURE_PAGE_SWAP_FPS) {
            long now = System.currentTimeMillis();
            long diff = now - mLastSwapTime;
            mAverageSwapFps = ((1000.0 / diff) + mAverageSwapFps) / 2;
            Log.d(LOGTAG, "page swap fps: " + mAverageSwapFps);
            mLastSwapTime = now;
        }
        mWebViewCore.resumeWebKitDraw();
        if (notifyAnimationStarted) {
            mWebViewCore.sendMessage(EventHub.NOTIFY_ANIMATION_STARTED);
        }
        if (mWebView instanceof PageSwapDelegate) {
            // This provides a hook for ProfiledWebView to observe the tile page swaps.
            ((PageSwapDelegate) mWebView).onPageSwapOccurred(notifyAnimationStarted);
        }

        if (mPictureListener != null) {
            // trigger picture listener for hardware layers. Software layers are
            // triggered in setNewPicture
            mPictureListener.onNewPicture(getWebView(), capturePicture());
        }
!!!5080332.java!!!	setNewPicture(in draw : DrawData, inout updateBaseLayer : boolean) : void
        if (mNativeClass == 0) {
            if (mDelaySetPicture != null) {
                throw new IllegalStateException("Tried to setNewPicture with"
                        + " a delay picture already set! (memory leak)");
            }
            // Not initialized yet, delay set
            mDelaySetPicture = draw;
            return;
        }
        WebViewCore.ViewState viewState = draw.mViewState;
        boolean isPictureAfterFirstLayout = viewState != null;

        if (updateBaseLayer) {
            setBaseLayer(draw.mBaseLayer,
                    getSettings().getShowVisualIndicator(),
                    isPictureAfterFirstLayout);
        }
        final Point viewSize = draw.mViewSize;
        // We update the layout (i.e. request a layout from the
        // view system) if the last view size that we sent to
        // WebCore matches the view size of the picture we just
        // received in the fixed dimension.
        final boolean updateLayout = viewSize.x == mLastWidthSent
                && viewSize.y == mLastHeightSent;
        // Don't send scroll event for picture coming from webkit,
        // since the new picture may cause a scroll event to override
        // the saved history scroll position.
        mSendScrollEvent = false;
        recordNewContentSize(draw.mContentSize.x,
                draw.mContentSize.y, updateLayout);
        if (isPictureAfterFirstLayout) {
            // Reset the last sent data here since dealing with new page.
            mLastWidthSent = 0;
            mZoomManager.onFirstLayout(draw);
            int scrollX = viewState.mShouldStartScrolledRight
                    ? getContentWidth() : viewState.mScrollX;
            int scrollY = viewState.mScrollY;
            contentScrollTo(scrollX, scrollY, false);
            if (!mDrawHistory) {
                // As we are on a new page, hide the keyboard
                hideSoftKeyboard();
            }
        }
        mSendScrollEvent = true;

        int functor = 0;
        boolean forceInval = isPictureAfterFirstLayout;
        ViewRootImpl viewRoot = mWebView.getViewRootImpl();
        if (mWebView.isHardwareAccelerated()
                && mWebView.getLayerType() != View.LAYER_TYPE_SOFTWARE
                && viewRoot != null) {
            functor = nativeGetDrawGLFunction(mNativeClass);
            if (functor != 0) {
                // force an invalidate if functor attach not successful
                forceInval |= !viewRoot.attachFunctor(functor);
            }
        }

        if (functor == 0
                || forceInval
                || mWebView.getLayerType() != View.LAYER_TYPE_NONE) {
            // invalidate the screen so that the next repaint will show new content
            // TODO: partial invalidate
            mWebView.invalidate();
        }

        // update the zoom information based on the new picture
        if (mZoomManager.onNewPicture(draw))
            invalidate();

        if (isPictureAfterFirstLayout) {
            mViewManager.postReadyToDrawAll();
        }
        scrollEditWithCursor();

        if (mPictureListener != null) {
            if (!mWebView.isHardwareAccelerated()
                    || mWebView.getLayerType() == View.LAYER_TYPE_SOFTWARE) {
                // trigger picture listener for software layers. Hardware layers are
                // triggered in pageSwapCallback
                mPictureListener.onNewPicture(getWebView(), capturePicture());
            }
        }
!!!5080460.java!!!	updateTextSelectionFromMessage(in nodePointer : int, in textGeneration : int, inout data : TextSelectionData) : void
        if (textGeneration == mTextGeneration) {
            if (mInputConnection != null && mFieldPointer == nodePointer) {
                mInputConnection.setSelection(data.mStart, data.mEnd);
            }
        }
        nativeSetTextSelection(mNativeClass, data.mSelectTextPtr);

        if ((data.mSelectionReason == TextSelectionData.REASON_ACCESSIBILITY_INJECTOR)
                || (!mSelectingText && data.mStart != data.mEnd
                        && data.mSelectionReason != TextSelectionData.REASON_SELECT_WORD)) {
            selectionDone();
            mShowTextSelectionExtra = true;
            invalidate();
            return;
        }

        if (data.mSelectTextPtr != 0 &&
                (data.mStart != data.mEnd ||
                (mFieldPointer == nodePointer && mFieldPointer != 0) ||
                (nodePointer == 0 && data.mStart == 0 && data.mEnd == 0))) {
            mIsEditingText = (mFieldPointer == nodePointer) && nodePointer != 0;
            mIsCaretSelection = (data.mStart == data.mEnd && nodePointer != 0);
            if (mIsCaretSelection &&
                    (mInputConnection == null ||
                    mInputConnection.getEditable().length() == 0)) {
                // There's no text, don't show caret handle.
                selectionDone();
            } else {
                if (!mSelectingText) {
                    setupWebkitSelect();
                } else {
                    syncSelectionCursors();
                }
                animateHandles();
                if (mIsCaretSelection) {
                    resetCaretTimer();
                }
            }
        } else {
            selectionDone();
        }
        invalidate();
!!!5080588.java!!!	scrollEditText(in scrollX : int, in scrollY : int) : void
        // Scrollable edit text. Scroll it.
        float maxScrollX = getMaxTextScrollX();
        float scrollPercentX = ((float)scrollX)/maxScrollX;
        mEditTextContent.offsetTo(-scrollX, -scrollY);
        mWebViewCore.removeMessages(EventHub.SCROLL_TEXT_INPUT);
        mWebViewCore.sendMessage(EventHub.SCROLL_TEXT_INPUT, 0,
                scrollY, (Float)scrollPercentX);
        animateHandles();
!!!5080716.java!!!	beginTextBatch() : void
        mIsBatchingTextChanges = true;
!!!5080844.java!!!	commitTextBatch() : void
        if (mWebViewCore != null) {
            mWebViewCore.sendMessages(mBatchedTextChanges);
        }
        mBatchedTextChanges.clear();
        mIsBatchingTextChanges = false;
!!!5080972.java!!!	sendBatchableInputMessage(in what : int, in arg1 : int, in arg2 : int, inout obj : Object) : void
        if (mWebViewCore == null) {
            return;
        }
        Message message = Message.obtain(null, what, arg1, arg2, obj);
        if (mIsBatchingTextChanges) {
            mBatchedTextChanges.add(message);
        } else {
            mWebViewCore.sendMessage(message);
        }
